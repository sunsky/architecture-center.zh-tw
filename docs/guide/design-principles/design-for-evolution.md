---
title: 為變更設計
titleSuffix: Azure Application Architecture Guide
description: 進化的設計是連續創新的關鍵。
author: MikeWasson
ms.date: 08/30/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: seojan19
ms.openlocfilehash: 4a1ed92f70660f16c07b4b472c3ef358af4319c9
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/20/2019
ms.locfileid: "58245699"
---
# <a name="design-for-evolution"></a><span data-ttu-id="4a7ce-103">進化的設計</span><span class="sxs-lookup"><span data-stu-id="4a7ce-103">Design for evolution</span></span>

## <a name="an-evolutionary-design-is-key-for-continuous-innovation"></a><span data-ttu-id="4a7ce-104">進化的設計是連續創新的關鍵</span><span class="sxs-lookup"><span data-stu-id="4a7ce-104">An evolutionary design is key for continuous innovation</span></span>

<span data-ttu-id="4a7ce-105">所有成功的應用程式會隨著時間變更，無論是要修正錯誤、加入新功能、納入新技術，或讓現有的系統更可擴充且可復原。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-105">All successful applications change over time, whether to fix bugs, add new features, bring in new technologies, or make existing systems more scalable and resilient.</span></span> <span data-ttu-id="4a7ce-106">如果應用程式的所有部分都緊密結合，會變得難以在系統中引入變更。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-106">If all the parts of an application are tightly coupled, it becomes very hard to introduce changes into the system.</span></span> <span data-ttu-id="4a7ce-107">應用程式的一個組件中的變更可能會破壞另一個組件，或導致變更在整個程式碼基底中起漣漪。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-107">A change in one part of the application may break another part, or cause changes to ripple through the entire codebase.</span></span>

<span data-ttu-id="4a7ce-108">此問題並不限於整合型應用程式。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-108">This problem is not limited to monolithic applications.</span></span> <span data-ttu-id="4a7ce-109">可以將應用程式分解成服務，但仍呈現將導致系統僵化和脆弱的那種緊密結合。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-109">An application can be decomposed into services, but still exhibit the sort of tight coupling that leaves the system rigid and brittle.</span></span> <span data-ttu-id="4a7ce-110">但是，當服務的設計要演化時，小組可以創新和持續提供新功能。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-110">But when services are designed to evolve, teams can innovate and continuously deliver new features.</span></span>

<span data-ttu-id="4a7ce-111">微服務正成為達到演化設計的一種常見方式，因為它們可處理此處所列的許多考量。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-111">Microservices are becoming a popular way to achieve an evolutionary design, because they address many of the considerations listed here.</span></span>

## <a name="recommendations"></a><span data-ttu-id="4a7ce-112">建議</span><span class="sxs-lookup"><span data-stu-id="4a7ce-112">Recommendations</span></span>

<span data-ttu-id="4a7ce-113">**強制高一致性和鬆散結合**。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-113">**Enforce high cohesion and loose coupling**.</span></span> <span data-ttu-id="4a7ce-114">如果服務提供邏輯上同屬的功能，則服務具*凝聚力*。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-114">A service is *cohesive* if it provides functionality that logically belongs together.</span></span> <span data-ttu-id="4a7ce-115">如果您可以變更一項服務，而不需要其他變更，則服務是*鬆散結合*。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-115">Services are *loosely coupled* if you can change one service without changing the other.</span></span> <span data-ttu-id="4a7ce-116">高凝聚力通常是指一個函式中的變更將需要其他相關的函式中的變更。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-116">High cohesion generally means that changes in one function will require changes in other related functions.</span></span> <span data-ttu-id="4a7ce-117">如果您發現更新服務時需要對其他服務協調更新，它可能是您的服務不具凝聚力的徵兆。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-117">If you find that updating a service requires coordinated updates to other services, it may be a sign that your services are not cohesive.</span></span> <span data-ttu-id="4a7ce-118">網域導向設計 (DDD) 的目標之一是識別這些界限。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-118">One of the goals of domain-driven design (DDD) is to identify those boundaries.</span></span>

<span data-ttu-id="4a7ce-119">**封裝網域知識**。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-119">**Encapsulate domain knowledge**.</span></span> <span data-ttu-id="4a7ce-120">當用戶端取用服務時，強制網域的商務規則的責任應不會在落在用戶端上。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-120">When a client consumes a service, the responsibility for enforcing the business rules of the domain should not fall on the client.</span></span> <span data-ttu-id="4a7ce-121">相反地，服務應該封裝屬於其責任的所有網域知識。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-121">Instead, the service should encapsulate all of the domain knowledge that falls under its responsibility.</span></span> <span data-ttu-id="4a7ce-122">否則，每個用戶端必須強制商務規則，而且會獲得到分散在應用程式不同部分的網域知識。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-122">Otherwise, every client has to enforce the business rules, and you end up with domain knowledge spread across different parts of the application.</span></span>

<span data-ttu-id="4a7ce-123">**非同步傳訊入門**。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-123">**Use asynchronous messaging**.</span></span> <span data-ttu-id="4a7ce-124">非同步傳訊是從使用者中分離訊息產生者的方式。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-124">Asynchronous messaging is a way to decouple the message producer from the consumer.</span></span> <span data-ttu-id="4a7ce-125">產生者不相依於取用者回應訊息，或採取任何特殊動作。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-125">The producer does not depend on the consumer responding to the message or taking any particular action.</span></span> <span data-ttu-id="4a7ce-126">利用 pub/sub 架構，產生者可能甚至不知道正在使用訊息的是誰。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-126">With a pub/sub architecture, the producer may not even know who is consuming the message.</span></span> <span data-ttu-id="4a7ce-127">新服務可以輕鬆地使用訊息，而不需對產生者進行任何修改。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-127">New services can easily consume the messages without any modifications to the producer.</span></span>

<span data-ttu-id="4a7ce-128">**請勿將網域知識建置到閘道**。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-128">**Don't build domain knowledge into a gateway**.</span></span> <span data-ttu-id="4a7ce-129">閘道在微服務架構中，對於要求路由、通訊協定轉譯、負載平衡或驗證之類可能很有用。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-129">Gateways can be useful in a microservices architecture, for things like request routing, protocol translation, load balancing, or authentication.</span></span> <span data-ttu-id="4a7ce-130">不過，閘道應該限制在這類基礎結構功能。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-130">However, the gateway should be restricted to this sort of infrastructure functionality.</span></span> <span data-ttu-id="4a7ce-131">它不應該實作任何網域知識，以避免成為大量相依性。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-131">It should not implement any domain knowledge, to avoid becoming a heavy dependency.</span></span>

<span data-ttu-id="4a7ce-132">**公開開放式介面**。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-132">**Expose open interfaces**.</span></span> <span data-ttu-id="4a7ce-133">避免建立位居服務之間位置的自訂轉譯層。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-133">Avoid creating custom translation layers that sit between services.</span></span> <span data-ttu-id="4a7ce-134">相反地，服務應該使用定義完善的 API 合約公開 API。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-134">Instead, a service should expose an API with a well-defined API contract.</span></span> <span data-ttu-id="4a7ce-135">API 應該設定版本，使得您可以將 API 持續改進同時維持回溯相容性。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-135">The API should be versioned, so that you can evolve the API while maintaining backward compatibility.</span></span> <span data-ttu-id="4a7ce-136">這樣一來，您可以更新服務，而不需對依存於它的所有上游服務協調更新。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-136">That way, you can update a service without coordinating updates to all of the upstream services that depend on it.</span></span> <span data-ttu-id="4a7ce-137">公眾對應的服務應該透過 HTTP 公開 RESTful API。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-137">Public facing services should expose a RESTful API over HTTP.</span></span> <span data-ttu-id="4a7ce-138">基於效能考量，後端服務可能會使用 RPC 樣式的傳訊通訊協定。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-138">Backend services might use an RPC-style messaging protocol for performance reasons.</span></span>

<span data-ttu-id="4a7ce-139">**針對服務合約設計和測試**。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-139">**Design and test against service contracts**.</span></span> <span data-ttu-id="4a7ce-140">當服務公開定義完善的 API 時，您可以對這些 API 進行開發及測試。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-140">When services expose well-defined APIs, you can develop and test against those APIs.</span></span> <span data-ttu-id="4a7ce-141">這樣一來，您可以開發及測試個別服務，而不需能加速其所有相依服務。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-141">That way, you can develop and test an individual service without spinning up all of its dependent services.</span></span> <span data-ttu-id="4a7ce-142">(當然，您仍會對實際服務執行整合和負載測試。)</span><span class="sxs-lookup"><span data-stu-id="4a7ce-142">(Of course, you would still perform integration and load testing against the real services.)</span></span>

<span data-ttu-id="4a7ce-143">**從網域邏輯抽取出基礎結構**。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-143">**Abstract infrastructure away from domain logic**.</span></span> <span data-ttu-id="4a7ce-144">不要將網域邏輯與基礎結構相關的功能 (例如傳訊或持續性) 混合。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-144">Don't let domain logic get mixed up with infrastructure-related functionality, such as messaging or persistence.</span></span> <span data-ttu-id="4a7ce-145">否則，網域邏輯中的變更將需要對基礎結構層進行更新，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-145">Otherwise, changes in the domain logic will require updates to the infrastructure layers and vice versa.</span></span>

<span data-ttu-id="4a7ce-146">**將跨領域考量卸載至個別服務**。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-146">**Offload cross-cutting concerns to a separate service**.</span></span> <span data-ttu-id="4a7ce-147">例如，如果數個服務需要驗證要求，您可以將這項功能移到它自己的服務。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-147">For example, if several services need to authenticate requests, you could move this functionality into its own service.</span></span> <span data-ttu-id="4a7ce-148">然後您可以持續演化驗證服務 &mdash; 比方說，藉由新增新的驗證流程&mdash;但沒有碰觸的任何使用該服務。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-148">Then you could evolve the authentication service &mdash; for example, by adding a new authentication flow &mdash; without touching any of the services that use it.</span></span>

<span data-ttu-id="4a7ce-149">**獨立部署服務**。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-149">**Deploy services independently**.</span></span> <span data-ttu-id="4a7ce-150">當 DevOps 小組可以部署與應用程式中其他服務無關的單一服務時，更新可以更快速且安全地進行。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-150">When the DevOps team can deploy a single service independently of other services in the application, updates can happen more quickly and safely.</span></span> <span data-ttu-id="4a7ce-151">錯誤修正和新功能可以以更一般的頻率推出。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-151">Bug fixes and new features can be rolled out at a more regular cadence.</span></span> <span data-ttu-id="4a7ce-152">設計應用程式和發佈程序以支援獨立更新。</span><span class="sxs-lookup"><span data-stu-id="4a7ce-152">Design both the application and the release process to support independent updates.</span></span>
