---
title: Azure Kubernetes Service (AKS) 上的微服務架構
description: 在 Azure Kubernetes Service (AKS) 上部署微服務架構
author: MikeWasson
ms.date: 12/10/2018
ms.topic: reference-architecture
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: c8ce4c77666ab7b9c55e6f144d514fadc6b6ad73
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/20/2019
ms.locfileid: "58246079"
---
# <a name="microservices-architecture-on-azure-kubernetes-service-aks"></a><span data-ttu-id="937dc-103">Azure Kubernetes Service (AKS) 上的微服務架構</span><span class="sxs-lookup"><span data-stu-id="937dc-103">Microservices architecture on Azure Kubernetes Service (AKS)</span></span>

<span data-ttu-id="937dc-104">此參考架構顯示部署至 Azure Kubernetes Service (AKS) 的微服務應用程式。</span><span class="sxs-lookup"><span data-stu-id="937dc-104">This reference architectures shows a microservices application deployed to Azure Kubernetes Service (AKS).</span></span> <span data-ttu-id="937dc-105">其顯示的基本 AKS 組態可作為大多數部署的起點。</span><span class="sxs-lookup"><span data-stu-id="937dc-105">It shows a basic AKS configuration that can be the starting point for most deployments.</span></span> <span data-ttu-id="937dc-106">更進階的選項 (包括進階網路功能選項) 將會在個別的參考架構中說明。</span><span class="sxs-lookup"><span data-stu-id="937dc-106">More advanced options, including advanced networking options, will be covered in a separate reference architecture.</span></span>

<span data-ttu-id="937dc-107">本文假設您已有 Kubernetes 的基本知識。</span><span class="sxs-lookup"><span data-stu-id="937dc-107">This article assumes basic knowledge of Kubernetes.</span></span> <span data-ttu-id="937dc-108">本文主要著重於在 AKS 上執行微服務架構的基礎結構與 DevOps 考量。</span><span class="sxs-lookup"><span data-stu-id="937dc-108">The article focuses mainly on the infrastructure and DevOps considerations of running a microservices architecture on AKS.</span></span> <span data-ttu-id="937dc-109">如需有關如何從網域導向設計 (DDD) 觀點來設計微服務的指引，請參閱[在 Azure 上設計、建置及操作微服務](/azure/architecture/microservices)。</span><span class="sxs-lookup"><span data-stu-id="937dc-109">For guidance on how to design microservices from a Domain Driven Design (DDD) perspective, see [Designing, building, and operating microservices on Azure](/azure/architecture/microservices).</span></span>

![AKS 參考架構](./_images/aks.png)

## <a name="architecture"></a><span data-ttu-id="937dc-111">架構</span><span class="sxs-lookup"><span data-stu-id="937dc-111">Architecture</span></span>

<span data-ttu-id="937dc-112">此架構由下列元件組成。</span><span class="sxs-lookup"><span data-stu-id="937dc-112">The architecture consists of the following components.</span></span>

<span data-ttu-id="937dc-113">**Azure Kubernetes Service** (AKS)。</span><span class="sxs-lookup"><span data-stu-id="937dc-113">**Azure Kubernetes Service** (AKS).</span></span> <span data-ttu-id="937dc-114">AKS 是一項 Azure 服務，用來部署受控的 Kubernetes 叢集。</span><span class="sxs-lookup"><span data-stu-id="937dc-114">AKS is an Azure service that deploys a managed Kubernetes cluster.</span></span> 

<span data-ttu-id="937dc-115">**Kubernetes 叢集**。</span><span class="sxs-lookup"><span data-stu-id="937dc-115">**Kubernetes cluster**.</span></span> <span data-ttu-id="937dc-116">AKS 負責部署 Kubernetes 叢集及管理 Kubernetes 主機。</span><span class="sxs-lookup"><span data-stu-id="937dc-116">AKS is responsible for deploying the Kubernetes cluster and for managing the Kubernetes masters.</span></span> <span data-ttu-id="937dc-117">您只需管理代理程式節點。</span><span class="sxs-lookup"><span data-stu-id="937dc-117">You only manage the agent nodes.</span></span>

<span data-ttu-id="937dc-118">**虛擬網路**。</span><span class="sxs-lookup"><span data-stu-id="937dc-118">**Virtual network**.</span></span> <span data-ttu-id="937dc-119">根據預設，AKS 會建立要在其中部署代理程式節點的虛擬網路。</span><span class="sxs-lookup"><span data-stu-id="937dc-119">By default, AKS creates a virtual network to deploy the agent nodes into.</span></span> <span data-ttu-id="937dc-120">針對更進階的案例，您可以先建立虛擬網路，以便控制子網路的設定方式、內部部署連線能力和 IP 位址等項目。</span><span class="sxs-lookup"><span data-stu-id="937dc-120">For more advanced scenarios, you can create the virtual network first, which lets you control things like how the subnets are configured, on-premises connectivity, and IP addressing.</span></span> <span data-ttu-id="937dc-121">如需詳細資訊，請參閱[在 Azure Kubernetes Service (AKS) 中設定進階網路](/azure/aks/configure-advanced-networking)。</span><span class="sxs-lookup"><span data-stu-id="937dc-121">For more information, see [Configure advanced networking in Azure Kubernetes Service (AKS)](/azure/aks/configure-advanced-networking).</span></span>

<span data-ttu-id="937dc-122">**輸入**。</span><span class="sxs-lookup"><span data-stu-id="937dc-122">**Ingress**.</span></span> <span data-ttu-id="937dc-123">輸入會將 HTTP (S) 路由公開給叢集內的服務。</span><span class="sxs-lookup"><span data-stu-id="937dc-123">An ingress exposes HTTP(S) routes to services inside the cluster.</span></span> <span data-ttu-id="937dc-124">如需詳細資訊，請參閱下面的 [API 閘道](#api-gateway)一節。</span><span class="sxs-lookup"><span data-stu-id="937dc-124">For more information, see the section [API Gateway](#api-gateway) below.</span></span>

<span data-ttu-id="937dc-125">**外部資料存放區**。</span><span class="sxs-lookup"><span data-stu-id="937dc-125">**External data stores**.</span></span> <span data-ttu-id="937dc-126">微服務通常是無狀態，並且會將狀態寫入外部資料存放區，例如 Azure SQL Database 或 Cosmos DB。</span><span class="sxs-lookup"><span data-stu-id="937dc-126">Microservices are typically stateless and write state to external data stores, such as Azure SQL Database or Cosmos DB.</span></span>

<span data-ttu-id="937dc-127">**Azure Active Directory**。</span><span class="sxs-lookup"><span data-stu-id="937dc-127">**Azure Active Directory**.</span></span> <span data-ttu-id="937dc-128">AKS 會使用 Azure Active Directory (Azure AD) 身分識別來建立及管理其他 Azure 資源，例如 Azure 負載平衡器。</span><span class="sxs-lookup"><span data-stu-id="937dc-128">AKS uses an Azure Active Directory (Azure AD) identity to create and manage other Azure resources such as Azure load balancers.</span></span> <span data-ttu-id="937dc-129">也建議您將 Azure AD 用於用戶端應用程式中的使用者驗證。</span><span class="sxs-lookup"><span data-stu-id="937dc-129">Azure AD is also recommended for user authentication in client applications.</span></span>

<span data-ttu-id="937dc-130">**Azure Container Registry**。</span><span class="sxs-lookup"><span data-stu-id="937dc-130">**Azure Container Registry**.</span></span> <span data-ttu-id="937dc-131">您可以使用 Container Registry 來儲存部署到叢集的私人 Docker 映像。</span><span class="sxs-lookup"><span data-stu-id="937dc-131">Use Container Registry to store private Docker images, which are deployed to the cluster.</span></span> <span data-ttu-id="937dc-132">AKS 可以使用其 Azure AD 身分識別向 Container Registry 進行驗證。</span><span class="sxs-lookup"><span data-stu-id="937dc-132">AKS can authenticate with Container Registry using its Azure AD identity.</span></span> <span data-ttu-id="937dc-133">請注意，AKS 不會要求使用 Azure Container Registry。</span><span class="sxs-lookup"><span data-stu-id="937dc-133">Note that AKS does not require Azure Container Registry.</span></span> <span data-ttu-id="937dc-134">您可以使用其他容器登錄，例如 Docker Hub。</span><span class="sxs-lookup"><span data-stu-id="937dc-134">You can use other container registries, such as Docker Hub.</span></span>

<span data-ttu-id="937dc-135">**Azure Pipelines**。</span><span class="sxs-lookup"><span data-stu-id="937dc-135">**Azure Pipelines**.</span></span> <span data-ttu-id="937dc-136">管線是 Azure DevOps Services 的一部分，可執行自動化組建、測試及部署。</span><span class="sxs-lookup"><span data-stu-id="937dc-136">Pipelines is part of Azure DevOps Services and runs automated builds, tests, and deployments.</span></span> <span data-ttu-id="937dc-137">您也可以使用 Jenkins 等第三方 CI/CD 解決方案。</span><span class="sxs-lookup"><span data-stu-id="937dc-137">You can also use third-party CI/CD solutions such as Jenkins.</span></span> 

<span data-ttu-id="937dc-138">**Helm**。</span><span class="sxs-lookup"><span data-stu-id="937dc-138">**Helm**.</span></span> <span data-ttu-id="937dc-139">Helm 是 Kubernetes 的套件管理員 &mdash; 可用來將 Kubernetes 物件組合成一個您可以發佈、部署、設定版本和更新的單元。</span><span class="sxs-lookup"><span data-stu-id="937dc-139">Helm is as a package manager for Kubernetes &mdash; a way to bundle Kubernetes objects into a single unit that you can publish, deploy, version, and update.</span></span>

<span data-ttu-id="937dc-140">**Azure 監視器**。</span><span class="sxs-lookup"><span data-stu-id="937dc-140">**Azure Monitor**.</span></span> <span data-ttu-id="937dc-141">Azure 監視器會收集並儲存計量和記錄，包括解決方案中 Azure 服務的平台計量和應用程式遙測。</span><span class="sxs-lookup"><span data-stu-id="937dc-141">Azure Monitor collects and stores metrics and logs, including platform metrics for the Azure services in the solution and application telemetry.</span></span> <span data-ttu-id="937dc-142">您可以使用此資料來監視應用程式、設定警示和儀表板，以及對失敗執行根本原因分析。</span><span class="sxs-lookup"><span data-stu-id="937dc-142">Use this data to monitor the application, set up alerts and dashboards, and perform root cause analysis of failures.</span></span> <span data-ttu-id="937dc-143">Azure 監視器會與 AKS 整合，以收集控制器、節點和容器中的計量，以及容器記錄和主要節點記錄。</span><span class="sxs-lookup"><span data-stu-id="937dc-143">Azure Monitor integrates with AKS to collect metrics from controllers, nodes, and containers, as well as container logs and master node logs.</span></span>

## <a name="design-considerations"></a><span data-ttu-id="937dc-144">設計考量</span><span class="sxs-lookup"><span data-stu-id="937dc-144">Design considerations</span></span>

<span data-ttu-id="937dc-145">雖然有許多建議做法適用於 AKS 上執行的其他工作負載，但是此參考架構著重於微服務架構。</span><span class="sxs-lookup"><span data-stu-id="937dc-145">This reference architecture is focused on microservices architectures, although many of the recommended practices will apply to other workloads running on AKS.</span></span>

### <a name="microservices"></a><span data-ttu-id="937dc-146">微服務</span><span class="sxs-lookup"><span data-stu-id="937dc-146">Microservices</span></span>

<span data-ttu-id="937dc-147">使用 Kubernetes Service 物件為 Kubernetes 中的微服務建立模型是最自然的方式。</span><span class="sxs-lookup"><span data-stu-id="937dc-147">The Kubernetes Service object is a natural way to model microservices in Kubernetes.</span></span> <span data-ttu-id="937dc-148">微服務是鬆散耦合且可獨立部署的程式碼單元。</span><span class="sxs-lookup"><span data-stu-id="937dc-148">A microservice is a loosely coupled, independently deployable unit of code.</span></span> <span data-ttu-id="937dc-149">微服務通常會透過定義完善的 API 進行通訊，並且可透過某種形式的服務探索來加以探索。</span><span class="sxs-lookup"><span data-stu-id="937dc-149">Microservices typically communicate through well-defined APIs, and are discoverable through some form of service discovery.</span></span> <span data-ttu-id="937dc-150">Kubernetes Service 物件會提供一組符合這些需求的功能：</span><span class="sxs-lookup"><span data-stu-id="937dc-150">The Kubernetes Service object provides a set of capabilities that match these requirements:</span></span>

- <span data-ttu-id="937dc-151">IP 位址。</span><span class="sxs-lookup"><span data-stu-id="937dc-151">IP address.</span></span> <span data-ttu-id="937dc-152">Service 物件會為 Pod (ReplicaSet) 群組提供靜態內部 IP 位址。</span><span class="sxs-lookup"><span data-stu-id="937dc-152">The Service object provides a static internal IP address for a group of pods (ReplicaSet).</span></span> <span data-ttu-id="937dc-153">建立或移動 Pod 時，一律可在此內部 IP 位址上連線到服務。</span><span class="sxs-lookup"><span data-stu-id="937dc-153">As pods are created or moved around, the service is always reachable at this internal IP address.</span></span>

- <span data-ttu-id="937dc-154">負載平衡。</span><span class="sxs-lookup"><span data-stu-id="937dc-154">Load balancing.</span></span> <span data-ttu-id="937dc-155">傳送至服務 IP 位址的流量會負載平衡到 Pod。</span><span class="sxs-lookup"><span data-stu-id="937dc-155">Traffic sent to the service's IP address is load balanced to the pods.</span></span> 

- <span data-ttu-id="937dc-156">服務探索。</span><span class="sxs-lookup"><span data-stu-id="937dc-156">Service discovery.</span></span> <span data-ttu-id="937dc-157">Kubernetes DNS 服務會指派內部 DNS 項目給服務。</span><span class="sxs-lookup"><span data-stu-id="937dc-157">Services are assigned internal DNS entries by the Kubernetes DNS service.</span></span> <span data-ttu-id="937dc-158">這表示 API 閘道可以使用 DNS 名稱呼叫後端服務。</span><span class="sxs-lookup"><span data-stu-id="937dc-158">That means the API gateway can call a backend service using the DNS name.</span></span> <span data-ttu-id="937dc-159">服務對服務通訊可以使用相同的機制。</span><span class="sxs-lookup"><span data-stu-id="937dc-159">The same mechanism can be used for service-to-service communication.</span></span> <span data-ttu-id="937dc-160">DNS 項目會依據命名空間來組織，因此，如果您的命名空間對應至限界內容，則服務的 DNS 名稱自然會對應至應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="937dc-160">The DNS entries are organized by namespace, so if your namespaces correspond to bounded contexts, then the DNS name for a service will map naturally to the application domain.</span></span>

<span data-ttu-id="937dc-161">下圖顯示服務和 Pod 之間的概念性關聯。</span><span class="sxs-lookup"><span data-stu-id="937dc-161">The following diagram show the conceptual relation between services and pods.</span></span> <span data-ttu-id="937dc-162">端點 IP 位址和連接埠的實際對應會由 kube-proxy (Kubernetes 網路 Proxy) 來完成。</span><span class="sxs-lookup"><span data-stu-id="937dc-162">The actual mapping to endpoint IP addresses and ports is done by kube-proxy, the Kubernetes network proxy.</span></span>

![服務和 Pod](./_images/aks-services.png)

### <a name="api-gateway"></a><span data-ttu-id="937dc-164">API Gateway</span><span class="sxs-lookup"><span data-stu-id="937dc-164">API Gateway</span></span>

<span data-ttu-id="937dc-165">「API 閘道」是位於外部用戶端與微服務之間的閘道。</span><span class="sxs-lookup"><span data-stu-id="937dc-165">An *API gateway* is a gateway that sits between external clients and the microservices.</span></span> <span data-ttu-id="937dc-166">它會作為反向 Proxy，將要求從用戶端路由傳送到微服務。</span><span class="sxs-lookup"><span data-stu-id="937dc-166">It acts as a reverse proxy, routing requests from clients to microservices.</span></span> <span data-ttu-id="937dc-167">它也會執行各種跨領域工作，例如驗證、SSL 終止和速率限制。</span><span class="sxs-lookup"><span data-stu-id="937dc-167">It may also perform various cross-cutting tasks such as authentication, SSL termination, and rate limiting.</span></span> 

<span data-ttu-id="937dc-168">閘道所提供的功能可以集合成一組，如下所示：</span><span class="sxs-lookup"><span data-stu-id="937dc-168">Functionality provided by a gateway can be grouped as follows:</span></span>

- <span data-ttu-id="937dc-169">[閘道路由](../../patterns/gateway-routing.md)：將用戶端要求路由至正確的後端服務。</span><span class="sxs-lookup"><span data-stu-id="937dc-169">[Gateway Routing](../../patterns/gateway-routing.md): Routing client requests to the right backend services.</span></span> <span data-ttu-id="937dc-170">這會為用戶端提供單一端點，並有助於讓用戶端與服務分離。</span><span class="sxs-lookup"><span data-stu-id="937dc-170">This provides a single endpoint for clients, and helps to decouple clients from services.</span></span>

- <span data-ttu-id="937dc-171">[閘道彙總](../../patterns/gateway-aggregation.md)：將多個要求彙總成單一要求，以減少用戶端與後端之間的對話。</span><span class="sxs-lookup"><span data-stu-id="937dc-171">[Gateway Aggregation](../../patterns/gateway-aggregation.md): Aggregation of multiple requests into a single request, to reduce chattiness between the client and the backend.</span></span>

- <span data-ttu-id="937dc-172">[閘道卸載](../../patterns/gateway-offloading.md)。</span><span class="sxs-lookup"><span data-stu-id="937dc-172">[Gateway Offloading](../../patterns/gateway-offloading.md).</span></span> <span data-ttu-id="937dc-173">閘道可從後端服務卸載功能，例如 SSL 終止、驗證、IP 允許清單或用戶端速率限制 (節流)。</span><span class="sxs-lookup"><span data-stu-id="937dc-173">A gateway can offload functionality from the backend services, such as SSL termination, authentication, IP whitelisting, or client rate limiting (throttling).</span></span>

<span data-ttu-id="937dc-174">API 閘道是一般的[微服務設計模式](https://microservices.io/patterns/apigateway.html)。</span><span class="sxs-lookup"><span data-stu-id="937dc-174">API gateways are a general [microservices design pattern](https://microservices.io/patterns/apigateway.html).</span></span> <span data-ttu-id="937dc-175">您可以使用數種不同的技術來實作 API 閘道。</span><span class="sxs-lookup"><span data-stu-id="937dc-175">They can be implemented using a number of different technologies.</span></span> <span data-ttu-id="937dc-176">最常見的實作可能是在叢集內部署邊緣路由器或反向 Proxy，例如 Nginx、HAProxy 或 Traefik。</span><span class="sxs-lookup"><span data-stu-id="937dc-176">Probably the most common implementation is to deploy an edge router or reverse proxy, such as Nginx, HAProxy, or Traefik, inside the cluster.</span></span> 

<span data-ttu-id="937dc-177">其他選項包括：</span><span class="sxs-lookup"><span data-stu-id="937dc-177">Other options include:</span></span>

- <span data-ttu-id="937dc-178">Azure 應用程式閘道和/或 Azure API 管理，這兩者都是放置於叢集外部的受控服務。</span><span class="sxs-lookup"><span data-stu-id="937dc-178">Azure Application Gateway and/or Azure API-Management, which are both managed services that reside outside of the cluster.</span></span> <span data-ttu-id="937dc-179">應用程式閘道輸入控制器目前為 Beta 版。</span><span class="sxs-lookup"><span data-stu-id="937dc-179">An Application Gateway Ingress Controller is currently in beta.</span></span>

- <span data-ttu-id="937dc-180">Azure Functions Proxy。</span><span class="sxs-lookup"><span data-stu-id="937dc-180">Azure Functions Proxies.</span></span> <span data-ttu-id="937dc-181">Proxy 可修改要求和回應，並根據 URL 路由要求。</span><span class="sxs-lookup"><span data-stu-id="937dc-181">Proxies can modify requests and responses and route requests based on URL.</span></span>

<span data-ttu-id="937dc-182">Kubernetes 的**輸入**資源類型會擷取 Proxy 伺服器的組態設定。</span><span class="sxs-lookup"><span data-stu-id="937dc-182">The Kubernetes **Ingress** resource type abstracts the configuration settings for a proxy server.</span></span> <span data-ttu-id="937dc-183">其會搭配提供基礎輸入實作的輸入控制器。</span><span class="sxs-lookup"><span data-stu-id="937dc-183">It works in conjunction with an ingress controller, which provides the underlying implementation of the Ingress.</span></span> <span data-ttu-id="937dc-184">適用於 Nginx、HAProxy、Traefik 和應用程式閘道 (預覽) 等的輸入控制器有很多種。</span><span class="sxs-lookup"><span data-stu-id="937dc-184">There are ingress controllers for Nginx, HAProxy, Traefik, and Application Gateway (preview), among others.</span></span>

<span data-ttu-id="937dc-185">輸入控制器會處理 Proxy 伺服器的設定。</span><span class="sxs-lookup"><span data-stu-id="937dc-185">The ingress controller handles configuring the proxy server.</span></span> <span data-ttu-id="937dc-186">這些設定通常需要複雜的組態檔，如果您不是專家，可能很難調整這些檔案，因此輸入控制器是很好的抽象功能。</span><span class="sxs-lookup"><span data-stu-id="937dc-186">Often these require complex configuration files, which can be hard to tune if you aren't an expert, so the ingress controller is a nice abstraction.</span></span> <span data-ttu-id="937dc-187">此外，輸入控制器可存取 Kubernetes API，因此可以對路由和負載平衡做出明智的決策。</span><span class="sxs-lookup"><span data-stu-id="937dc-187">In addition, the Ingress Controller has access to the Kubernetes API, so it can make intelligent decisions about routing and load balancing.</span></span> <span data-ttu-id="937dc-188">例如，Nginx 輸入控制器會略過 kube-proxy 網路 Proxy。</span><span class="sxs-lookup"><span data-stu-id="937dc-188">For example, the Nginx ingress controller bypasses the kube-proxy network proxy.</span></span>

<span data-ttu-id="937dc-189">相反地，如果您需要完全掌控設定，您可以略過此抽象功能，然後手動設定 Proxy 伺服器。</span><span class="sxs-lookup"><span data-stu-id="937dc-189">On the other hand, if you need complete control over the settings, you may want to bypass this abstraction and configure the proxy server manually.</span></span> 

<span data-ttu-id="937dc-190">反向 Proxy 伺服器是潛在瓶頸或單一失敗點，因此請一律部署至少兩個複本以獲得高可用性。</span><span class="sxs-lookup"><span data-stu-id="937dc-190">A reverse proxy server is a potential bottleneck or single point of failure, so always deploy at least two replicas for high availability.</span></span>

### <a name="data-storage"></a><span data-ttu-id="937dc-191">資料儲存體</span><span class="sxs-lookup"><span data-stu-id="937dc-191">Data storage</span></span>

<span data-ttu-id="937dc-192">在微服務架構中，服務不應共用資料儲存體。</span><span class="sxs-lookup"><span data-stu-id="937dc-192">In a microservices architecture, services should not share data storage.</span></span> <span data-ttu-id="937dc-193">每個服務都應該將自己的私用資料放在個別邏輯儲存體，以避免服務之間有隱藏的相依性。</span><span class="sxs-lookup"><span data-stu-id="937dc-193">Each service should own its own private data in a separate logical storage, to avoid hidden dependencies among services.</span></span> <span data-ttu-id="937dc-194">這是為了避免服務彼此意外結合，如果服務共用相同的基礎資料結構描述，就可能發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="937dc-194">The reason is to avoid unintentional coupling between services, which can happen when services share the same underlying data schemas.</span></span> <span data-ttu-id="937dc-195">此外，若服務能管理自己的資料存放區，即可針對服務的特定需求來使用正確的資料存放區。</span><span class="sxs-lookup"><span data-stu-id="937dc-195">Also, when services manage their own data stores, they can use the right data store for their particular requirements.</span></span> <span data-ttu-id="937dc-196">如需詳細資訊，請參閱[設計微服務：資料考量](/azure/architecture/microservices/data-considerations)。</span><span class="sxs-lookup"><span data-stu-id="937dc-196">For more information, see [Designing microservices: Data considerations](/azure/architecture/microservices/data-considerations).</span></span>

<span data-ttu-id="937dc-197">請避免將永續性資料儲存在本機叢集存放區，因為這樣會將資料繫結至節點。</span><span class="sxs-lookup"><span data-stu-id="937dc-197">Avoid storing persistent data in local cluster storage, because that ties the data to the node.</span></span> <span data-ttu-id="937dc-198">因此，</span><span class="sxs-lookup"><span data-stu-id="937dc-198">Instead,</span></span> 

- <span data-ttu-id="937dc-199">請使用外部服務，例如 Azure SQL Database 或 Cosmos DB，或是</span><span class="sxs-lookup"><span data-stu-id="937dc-199">Use an external service such as Azure SQL Database or Cosmos DB, *or*</span></span>

- <span data-ttu-id="937dc-200">使用 Azure 磁碟或 Azure 檔案服務掛接永續性磁碟區。</span><span class="sxs-lookup"><span data-stu-id="937dc-200">Mount a persistent volume using Azure Disks or Azure Files.</span></span> <span data-ttu-id="937dc-201">如果有多個 Pod 需要共用相同的磁碟區，請使用 Azure 檔案服務。</span><span class="sxs-lookup"><span data-stu-id="937dc-201">Use Azure Files if the same volume needs to be shared by multiple pods.</span></span>

### <a name="namespaces"></a><span data-ttu-id="937dc-202">命名空間</span><span class="sxs-lookup"><span data-stu-id="937dc-202">Namespaces</span></span>

<span data-ttu-id="937dc-203">您可以使用命名空間來組織叢集內的服務。</span><span class="sxs-lookup"><span data-stu-id="937dc-203">Use namespaces to organize services within the cluster.</span></span> <span data-ttu-id="937dc-204">Kubernetes 叢集中的每個物件都會屬於一個命名空間。</span><span class="sxs-lookup"><span data-stu-id="937dc-204">Every object in a Kubernetes cluster belongs to a namespace.</span></span> <span data-ttu-id="937dc-205">根據預設，當您建立新的物件時，此物件會進入 `default` 命名空間。</span><span class="sxs-lookup"><span data-stu-id="937dc-205">By default, when you create a new object, it goes into the `default` namespace.</span></span> <span data-ttu-id="937dc-206">但是較好的做法是建立更具描述性的命名空間，以協助組織叢集中的資源。</span><span class="sxs-lookup"><span data-stu-id="937dc-206">But it's a good practice to create namespaces that are more descriptive to help organize the resources in the cluster.</span></span>

<span data-ttu-id="937dc-207">首先，命名空間有助於防止命名衝突。</span><span class="sxs-lookup"><span data-stu-id="937dc-207">First, namespaces help prevent naming collisions.</span></span> <span data-ttu-id="937dc-208">當多個小組都將微服務部署到相同的叢集中時，就可能有數百個微服務，如果這些微服務都進入相同命名空間，就會變得難以管理。</span><span class="sxs-lookup"><span data-stu-id="937dc-208">When multiple teams deploy microservices into the same cluster, with possibly hundreds of microservices, it gets hard to manage if they all go into the same namespace.</span></span> <span data-ttu-id="937dc-209">此外，命名空間可讓您：</span><span class="sxs-lookup"><span data-stu-id="937dc-209">In addition, namespaces allow you to:</span></span>

- <span data-ttu-id="937dc-210">將資源限制套用至命名空間，如此一來，指派到該命名空間的 Pod 集合總數就不會超過命名空間的資源配額。</span><span class="sxs-lookup"><span data-stu-id="937dc-210">Apply resource constraints to a namespace, so that the total set of pods assigned to that namespace cannot exceed the resource quota of the namespace.</span></span>

- <span data-ttu-id="937dc-211">在命名空間層級上套用原則，包括 RBAC 和安全性原則。</span><span class="sxs-lookup"><span data-stu-id="937dc-211">Apply policies at the namespace level, including RBAC and security policies.</span></span>

<span data-ttu-id="937dc-212">針對微服務架構，請考慮將微服務組織到限界內容中，並為每個限界內容建立命名空間。</span><span class="sxs-lookup"><span data-stu-id="937dc-212">For a microservices architecture, considering organizing the microservices into bounded contexts, and creating namespaces for each bounded context.</span></span> <span data-ttu-id="937dc-213">例如，與「訂單履行」限界內容相關的所有微服務可進入相同的命名空間。</span><span class="sxs-lookup"><span data-stu-id="937dc-213">For example, all microservices related to the "Order Fulfillment" bounded context could go into the same namespace.</span></span> <span data-ttu-id="937dc-214">或者，為每個開發小組建立命名空間。</span><span class="sxs-lookup"><span data-stu-id="937dc-214">Alternatively, create a namespace for each development team.</span></span>

<span data-ttu-id="937dc-215">將公用程式服務放入他們自己的個別命名空間中。</span><span class="sxs-lookup"><span data-stu-id="937dc-215">Place utility services into their own separate namespace.</span></span> <span data-ttu-id="937dc-216">例如，您可能會部署 Elasticsearch 或 Prometheus 來監視叢集，或部署適用於 Helm 的 Tiller。</span><span class="sxs-lookup"><span data-stu-id="937dc-216">For example, you might deploy Elasticsearch or Prometheus for cluster monitoring, or Tiller for Helm.</span></span>

## <a name="scalability-considerations"></a><span data-ttu-id="937dc-217">延展性考量</span><span class="sxs-lookup"><span data-stu-id="937dc-217">Scalability considerations</span></span>

<span data-ttu-id="937dc-218">Kubernetes 支援兩個層級上的相應放大：</span><span class="sxs-lookup"><span data-stu-id="937dc-218">Kubernetes supports scale-out at two levels:</span></span>

- <span data-ttu-id="937dc-219">調整配置給部署的 Pod 數目。</span><span class="sxs-lookup"><span data-stu-id="937dc-219">Scale the number of pods allocated to a deployment.</span></span>
- <span data-ttu-id="937dc-220">調整叢集中的節點數目，以增加叢集可用的計算資源總數。</span><span class="sxs-lookup"><span data-stu-id="937dc-220">Scale the nodes in the cluster, to increase the total compute resources available to the cluster.</span></span>

<span data-ttu-id="937dc-221">雖然您可以手動相應放大 Pod 和節點數，但我們建議您使用自動調整功能，將服務在高負載下會耗盡資源的機會降到最低。</span><span class="sxs-lookup"><span data-stu-id="937dc-221">Although you can scale out pods and nodes manually, we recommend using autoscaling, to minimize the chance that services will become resource starved under high load.</span></span> <span data-ttu-id="937dc-222">自動調整策略必須同時將 Pod 和節點納入考量。</span><span class="sxs-lookup"><span data-stu-id="937dc-222">An autoscaling strategy must take both pods and nodes into account.</span></span> <span data-ttu-id="937dc-223">如果您只相應放大 Pod 數，最後會達到節點的資源限制。</span><span class="sxs-lookup"><span data-stu-id="937dc-223">If you just scale out the pods, eventually you will reach the resource limits of the nodes.</span></span> 

### <a name="pod-autoscaling"></a><span data-ttu-id="937dc-224">Pod 自動調整</span><span class="sxs-lookup"><span data-stu-id="937dc-224">Pod autoscaling</span></span>

<span data-ttu-id="937dc-225">水平 Pod 自動調整程式 (HPA) 會根據觀察到的 CPU、記憶體或自訂計量來調整 Pod。</span><span class="sxs-lookup"><span data-stu-id="937dc-225">The Horizontal Pod Autoscaler (HPA) scales pods based on observed CPU, memory, or custom metrics.</span></span> <span data-ttu-id="937dc-226">若要設定水平 Pod 調整，請指定目標計量 (例如，70% 的 CPU)，以及複本的最小和最大數目。</span><span class="sxs-lookup"><span data-stu-id="937dc-226">To configure horizontal pod scaling, you specify a target metric (for example, 70% of CPU), and the minimum and maximum number of replicas.</span></span> <span data-ttu-id="937dc-227">您應對服務進行負載測試，以導出這些數字。</span><span class="sxs-lookup"><span data-stu-id="937dc-227">You should load test your services to derive these numbers.</span></span>

<span data-ttu-id="937dc-228">自動調整的副作用是 Pod 可能會在發生相應放大和相應縮小事件時頻繁地建立或收回。</span><span class="sxs-lookup"><span data-stu-id="937dc-228">A side-effect of autoscaling is that pods may be created or evicted more frequently, as scale-out and scale-in events happen.</span></span> <span data-ttu-id="937dc-229">若要減輕這個副作用：</span><span class="sxs-lookup"><span data-stu-id="937dc-229">To mitigate the effects of this:</span></span>

- <span data-ttu-id="937dc-230">使用整備度探查讓 Kubernetes 知道新 Pod 何時可接受流量。</span><span class="sxs-lookup"><span data-stu-id="937dc-230">Use readiness probes to let Kubernetes know when a new pod is ready to accept traffic.</span></span>
- <span data-ttu-id="937dc-231">使用 Pod 中斷預算來限制服務一次可以收回幾個 Pod。</span><span class="sxs-lookup"><span data-stu-id="937dc-231">Use pod disruption budgets to limit how many pods can be evicted from a service at a time.</span></span>

### <a name="cluster-autoscaling"></a><span data-ttu-id="937dc-232">叢集自動調整</span><span class="sxs-lookup"><span data-stu-id="937dc-232">Cluster autoscaling</span></span>

<span data-ttu-id="937dc-233">叢集自動調整程式可調整節點的數目。</span><span class="sxs-lookup"><span data-stu-id="937dc-233">The cluster autoscaler scales the number of nodes.</span></span> <span data-ttu-id="937dc-234">如果由於資源限制而無法對 Pod 進行排程，則叢集自動調整程式就會佈建更多節點。</span><span class="sxs-lookup"><span data-stu-id="937dc-234">If pods can't be scheduled because of resource constraints, the cluster autoscaler will provision more nodes.</span></span>  <span data-ttu-id="937dc-235">(附註：AKS 與叢集自動調整程式之間的整合目前為預覽狀態。)</span><span class="sxs-lookup"><span data-stu-id="937dc-235">(Note: Integration between AKS and the cluster autoscaler is currently in preview.)</span></span>

<span data-ttu-id="937dc-236">HPA 會查看實際耗用的資源或執行中 Pod 的其他計量，而叢集自動調整程式會為尚未進行排程的 Pod 佈建節點。</span><span class="sxs-lookup"><span data-stu-id="937dc-236">Whereas HPA looks at actual resources consumed or other metrics from running pods, the cluster autoscaler is provisioning nodes for pods that aren't scheduled yet.</span></span> <span data-ttu-id="937dc-237">因此，自動調整程式會查看部署中 Kubernetes Pod 規格上所指定的要求資源。</span><span class="sxs-lookup"><span data-stu-id="937dc-237">Therefore, it looks at the requested resources, as specified in the Kubernetes pod spec for a deployment.</span></span> <span data-ttu-id="937dc-238">使用負載測試來微調這些值。</span><span class="sxs-lookup"><span data-stu-id="937dc-238">Use load testing to fine-tune these values.</span></span>

<span data-ttu-id="937dc-239">您無法在建立叢集後變更 VM 大小，因此應該先進行一些初步容量規劃，以選擇適當的 VM 大小作為建立叢集時的代理程式節點。</span><span class="sxs-lookup"><span data-stu-id="937dc-239">You can't change the VM size after you create the cluster, so you should do some initial capacity planning to choose an appropriate VM size for the agent nodes when you create the cluster.</span></span> 

## <a name="availability-considerations"></a><span data-ttu-id="937dc-240">可用性考量</span><span class="sxs-lookup"><span data-stu-id="937dc-240">Availability considerations</span></span>

### <a name="health-probes"></a><span data-ttu-id="937dc-241">健康狀態探查</span><span class="sxs-lookup"><span data-stu-id="937dc-241">Health probes</span></span>

<span data-ttu-id="937dc-242">Kubernetes 會定義兩種可由 Pod 公開的健康情況探查類型：</span><span class="sxs-lookup"><span data-stu-id="937dc-242">Kubernetes defines two types of health probe that a pod can expose:</span></span>

- <span data-ttu-id="937dc-243">整備度探查：告訴 Kubernetes Pod 是否準備好接受要求。</span><span class="sxs-lookup"><span data-stu-id="937dc-243">Readiness probe: Tells Kubernetes whether the pod is ready to accept requests.</span></span>

- <span data-ttu-id="937dc-244">活躍度探查：告訴 Kubernetes 是否應移除 Pod，以及是否有新的執行個體啟動。</span><span class="sxs-lookup"><span data-stu-id="937dc-244">Liveness probe: Tells Kubernetes whether a pod should be removed and a new instance started.</span></span>

<span data-ttu-id="937dc-245">考慮使用哪個探查時，回想服務在 Kubernetes 中的運作方式可協助您做決定。</span><span class="sxs-lookup"><span data-stu-id="937dc-245">When thinking about probes, it's useful to recall how a service works in Kubernetes.</span></span> <span data-ttu-id="937dc-246">服務會有符合一組 (零或多個) Pod 的標籤選取器。</span><span class="sxs-lookup"><span data-stu-id="937dc-246">A service has a label selector that matches a set of (zero or more) pods.</span></span> <span data-ttu-id="937dc-247">Kubernetes 會將流量負載平衡至符合選取器的 Pod。</span><span class="sxs-lookup"><span data-stu-id="937dc-247">Kubernetes load balances traffic to the pods that match the selector.</span></span> <span data-ttu-id="937dc-248">只有成功啟動且狀況良好的 Pod 會接收流量。</span><span class="sxs-lookup"><span data-stu-id="937dc-248">Only pods that started successfully and are healthy receive traffic.</span></span> <span data-ttu-id="937dc-249">如果容器損毀，Kubernetes 會終止 Pod，並安排取代事宜。</span><span class="sxs-lookup"><span data-stu-id="937dc-249">If a container crashes, Kubernetes kills the pod and schedules a replacement.</span></span>

<span data-ttu-id="937dc-250">有時候，即使已成功啟動 Pod，Pod 仍可能尚未準備好接收流量。</span><span class="sxs-lookup"><span data-stu-id="937dc-250">Sometimes, a pod may not be ready to receive traffic, even though the pod started successfully.</span></span> <span data-ttu-id="937dc-251">例如，可能有初始設定工作，像是在容器中執行的應用程式要將項目載入記憶體或讀取設定資料。</span><span class="sxs-lookup"><span data-stu-id="937dc-251">For example, there may be initialization tasks, where the application running in the container loads things into memory or reads configuration data.</span></span> <span data-ttu-id="937dc-252">若要指出 Pod 健康情況良好但未準備好接收流量，可定義整備度探查。</span><span class="sxs-lookup"><span data-stu-id="937dc-252">To indicate that a pod is healthy but not ready to receive traffic, define a readiness probe.</span></span> 

<span data-ttu-id="937dc-253">活躍度探查所處理的狀況是，Pod 仍在執行但狀況不良，而且應該回收。</span><span class="sxs-lookup"><span data-stu-id="937dc-253">Liveness probes handle the case where a pod is still running, but is unhealthy and should be recycled.</span></span> <span data-ttu-id="937dc-254">例如，假設容器正在處理 HTTP 要求，但因為某些原因而停止回應。</span><span class="sxs-lookup"><span data-stu-id="937dc-254">For example, suppose that a container is serving HTTP requests but hangs for some reason.</span></span> <span data-ttu-id="937dc-255">容器沒有損毀，但已停止處理任何要求。</span><span class="sxs-lookup"><span data-stu-id="937dc-255">The container doesn't crash, but it has stopped serving any requests.</span></span> <span data-ttu-id="937dc-256">如果您定義 HTTP 活躍度探查，探查將會停止回應，並通知 Kubernetes 重新啟動 Pod。</span><span class="sxs-lookup"><span data-stu-id="937dc-256">If you define an HTTP liveness probe, the probe will stop responding and that informs Kubernetes to restart the pod.</span></span>

<span data-ttu-id="937dc-257">以下是設計探查時的一些考量：</span><span class="sxs-lookup"><span data-stu-id="937dc-257">Here are some considerations when designing probes:</span></span>

- <span data-ttu-id="937dc-258">如果您程式碼的啟動時間很長，則會有活躍度探查在啟動完成之前即回報失敗的風險。</span><span class="sxs-lookup"><span data-stu-id="937dc-258">If your code has a long startup time, there is a danger that a liveness probe will report failure before the startup completes.</span></span> <span data-ttu-id="937dc-259">若要避免這個問題，請使用 initialDelaySeconds 設定，這會延遲啟動探查。</span><span class="sxs-lookup"><span data-stu-id="937dc-259">To prevent this, use the initialDelaySeconds setting, which delays the probe from starting.</span></span>

- <span data-ttu-id="937dc-260">除非重新啟動 Pod 就有可能將 Pod 還原到狀況良好的狀態，否則活躍度探查並無幫助。</span><span class="sxs-lookup"><span data-stu-id="937dc-260">A liveness probe doesn't help unless restarting the pod is likely to restore it to a healthy state.</span></span> <span data-ttu-id="937dc-261">您可以使用活躍度探查來避免記憶體遺漏或未預期的鎖死，但重新啟動立即會再次失敗的 Pod 並無意義。</span><span class="sxs-lookup"><span data-stu-id="937dc-261">You can use a liveness probe to mitigate against memory leaks or unexpected deadlocks, but there's no point in restarting a pod that's going to immediately fail again.</span></span>

- <span data-ttu-id="937dc-262">有時候，整備度探查會用來檢查相依的服務。</span><span class="sxs-lookup"><span data-stu-id="937dc-262">Sometimes readiness probes are used to check dependent services.</span></span> <span data-ttu-id="937dc-263">例如，如果 Pod 在資料庫上有相依性，活躍度探查可能會檢查資料庫連線。</span><span class="sxs-lookup"><span data-stu-id="937dc-263">For example, if a pod has a dependency on a database, the liveness probe might check the database connection.</span></span> <span data-ttu-id="937dc-264">不過，此方法可能產生非預期的問題。</span><span class="sxs-lookup"><span data-stu-id="937dc-264">However, this approach can create unexpected problems.</span></span> <span data-ttu-id="937dc-265">外部服務可能會因為某些原因而暫時無法使用。</span><span class="sxs-lookup"><span data-stu-id="937dc-265">An external service might be temporarily unavailable for some reason.</span></span> <span data-ttu-id="937dc-266">這會造成服務中所有 Pod 的整備度探查失敗，造成負載平衡中的所有 Pod 遭到移除，並因此在上游產生連鎖性失敗。</span><span class="sxs-lookup"><span data-stu-id="937dc-266">That will cause the readiness probe to fail for all the pods in your service, causing all of them to be removed from load balancing, and thus creating cascading failures upstream.</span></span> <span data-ttu-id="937dc-267">更好的方法是在您服務中實作重試處理，讓您的服務可以正確地從暫時性失敗中復原。</span><span class="sxs-lookup"><span data-stu-id="937dc-267">A better approach is to implement retry handling within your service, so that your service can recover correctly from transient failures.</span></span>

### <a name="resource-constraints"></a><span data-ttu-id="937dc-268">資源限制</span><span class="sxs-lookup"><span data-stu-id="937dc-268">Resource constraints</span></span>

<span data-ttu-id="937dc-269">資源爭用可能會影響服務的可用性。</span><span class="sxs-lookup"><span data-stu-id="937dc-269">Resource contention can affect the availability of a service.</span></span> <span data-ttu-id="937dc-270">請為容器定義資源限制，以免單一容器拖垮叢集資源 (記憶體和 CPU)。</span><span class="sxs-lookup"><span data-stu-id="937dc-270">Define resource constraints for containers, so that a single container cannot overwhelm the cluster resources (memory and CPU).</span></span> <span data-ttu-id="937dc-271">針對非容器資源 (例如執行緒或網路連線)，請考慮使用[隔艙模式](/azure/architecture/patterns/bulkhead)來隔離資源。</span><span class="sxs-lookup"><span data-stu-id="937dc-271">For non-container resources, such as threads or network connections, consider using the [Bulkhead Pattern](/azure/architecture/patterns/bulkhead) to isolate resources.</span></span>

<span data-ttu-id="937dc-272">使用資源配額來限制命名空間允許的資源總數。</span><span class="sxs-lookup"><span data-stu-id="937dc-272">Use resource quotas to limit the total resources allowed for a namespace.</span></span> <span data-ttu-id="937dc-273">如此一來，前端就不能占用後端服務的資源，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="937dc-273">That way, the front end can't starve the backend services for resources or vice-versa.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="937dc-274">安全性考量</span><span class="sxs-lookup"><span data-stu-id="937dc-274">Security considerations</span></span>

### <a name="role-based-access-control-rbac"></a><span data-ttu-id="937dc-275">角色型存取控制 (RBAC)</span><span class="sxs-lookup"><span data-stu-id="937dc-275">Role based access control (RBAC)</span></span>

<span data-ttu-id="937dc-276">Kubernetes 和 Azure 均有角色型存取控制 (RBAC) 的機制：</span><span class="sxs-lookup"><span data-stu-id="937dc-276">Kubernetes and Azure both have mechanisms for role-based access control (RBAC):</span></span>

- <span data-ttu-id="937dc-277">Azure RBAC 會控制 Azure 中的資源存取權，包括建立新 Azure 資源的能力。</span><span class="sxs-lookup"><span data-stu-id="937dc-277">Azure RBAC controls access to resources in Azure, including the ability to create new Azure resources.</span></span> <span data-ttu-id="937dc-278">權限可以指派給使用者、群組或服務主體。</span><span class="sxs-lookup"><span data-stu-id="937dc-278">Permissions can be assigned to users, groups, or service principals.</span></span> <span data-ttu-id="937dc-279">(服務主體是由應用程式所使用的安全性身分識別)。</span><span class="sxs-lookup"><span data-stu-id="937dc-279">(A service principal is a security identity used by applications.)</span></span>

- <span data-ttu-id="937dc-280">Kubernetes RBAC 會控制 Kubernetes API 的權限。</span><span class="sxs-lookup"><span data-stu-id="937dc-280">Kubernetes RBAC controls permissions to the Kubernetes API.</span></span> <span data-ttu-id="937dc-281">例如，建立 Pod 和列出 Pod 都是可透過 RBAC 來允許 (或拒絕) 使用者執行的動作。</span><span class="sxs-lookup"><span data-stu-id="937dc-281">For example, creating pods and listing pods are actions that can be authorized (or denied) to a user through RBAC.</span></span> <span data-ttu-id="937dc-282">若要將 Kubernetes 權限指派給使用者，您可以建立「角色」和「角色繫結」：</span><span class="sxs-lookup"><span data-stu-id="937dc-282">To assign Kubernetes permissions to users, you create *roles* and *role bindings*:</span></span>

  - <span data-ttu-id="937dc-283">角色是可在命名空間內套用的一組權限。</span><span class="sxs-lookup"><span data-stu-id="937dc-283">A Role is a set of permissions that apply within a namespace.</span></span> <span data-ttu-id="937dc-284">權限會定義為資源 (Pod 和部署等) 上的動詞命令 (取得、更新、建立、刪除)。</span><span class="sxs-lookup"><span data-stu-id="937dc-284">Permissions are defined as verbs (get, update, create, delete) on resources (pods, deployments, etc.).</span></span>

  - <span data-ttu-id="937dc-285">RoleBinding 會將使用者或群組指派給角色 (Role)。</span><span class="sxs-lookup"><span data-stu-id="937dc-285">A RoleBinding assigns users or groups to a Role.</span></span>

  - <span data-ttu-id="937dc-286">另外還有 ClusterRole 物件，這類似於角色，但會套用到所有命名空間上的整個叢集。</span><span class="sxs-lookup"><span data-stu-id="937dc-286">There is also a ClusterRole object, which is like a Role but applies to the entire cluster, across all namespaces.</span></span> <span data-ttu-id="937dc-287">若要將使用者或群組指派給 ClusterRole，請建立 ClusterRoleBinding。</span><span class="sxs-lookup"><span data-stu-id="937dc-287">To assign users or groups to a ClusterRole, create a ClusterRoleBinding.</span></span>

<span data-ttu-id="937dc-288">AKS 會整合這兩種 RBAC 機制。</span><span class="sxs-lookup"><span data-stu-id="937dc-288">AKS integrates these two RBAC mechanisms.</span></span> <span data-ttu-id="937dc-289">建立 AKS 叢集時，您可以將其設定為使用 Azure AD 進行使用者驗證。</span><span class="sxs-lookup"><span data-stu-id="937dc-289">When you create an AKS cluster, you can configure it to use Azure AD for user authentication.</span></span> <span data-ttu-id="937dc-290">如需如何設定此動作的詳細資料，請參閱[整合 Azure Active Directory 與 Azure Kubernetes Service](/azure/aks/aad-integration)。</span><span class="sxs-lookup"><span data-stu-id="937dc-290">For details on how to set this up, see [Integrate Azure Active Directory with Azure Kubernetes Service](/azure/aks/aad-integration).</span></span>

<span data-ttu-id="937dc-291">完成此設定之後，想要存取 Kubernetes API (例如，透過 kubectl) 的使用者必須先使用其 Azure AD 認證登入。</span><span class="sxs-lookup"><span data-stu-id="937dc-291">Once this is configured, a user who wants to access the Kubernetes API (for example, through kubectl) must sign in using their Azure AD credentials.</span></span>

<span data-ttu-id="937dc-292">根據預設，Azure AD 使用者沒有叢集的存取權。</span><span class="sxs-lookup"><span data-stu-id="937dc-292">By default, an Azure AD user has no access to the cluster.</span></span> <span data-ttu-id="937dc-293">若要授與存取權，叢集管理員會建立參照 Azure AD 使用者或群組的 RoleBindings。</span><span class="sxs-lookup"><span data-stu-id="937dc-293">To grant access, the cluster administrator creates RoleBindings that refer to Azure AD users or groups.</span></span> <span data-ttu-id="937dc-294">如果使用者沒有執行特定作業的權限，則此動作會失敗。</span><span class="sxs-lookup"><span data-stu-id="937dc-294">If a user doesn't have permissions for a particular operation, it will fail.</span></span>

<span data-ttu-id="937dc-295">如果使用者預設為沒有存取權，那麼叢集管理員怎麼有權限先建立角色繫結？</span><span class="sxs-lookup"><span data-stu-id="937dc-295">If users have no access by default, how does the cluster admin have permission to create the role bindings in the first place?</span></span> <span data-ttu-id="937dc-296">AKS 叢集實際上有兩種用來呼叫 Kubernetes API 伺服器的認證類型：叢集使用者和叢集管理員。叢集管理員認證會授與叢集的完整存取。</span><span class="sxs-lookup"><span data-stu-id="937dc-296">An AKS cluster actually has two types of credentials for calling the Kubernetes API server: cluster user and cluster admin. The cluster admin credentials grant full access to the cluster.</span></span> <span data-ttu-id="937dc-297">Azure CLI 命令 `az aks get-credentials --admin` 會下載叢集管理員認證，並將其儲存到您的 kubeconfig 檔案。</span><span class="sxs-lookup"><span data-stu-id="937dc-297">The Azure CLI command `az aks get-credentials --admin` downloads the cluster admin credentials and saves them into your kubeconfig file.</span></span> <span data-ttu-id="937dc-298">叢集管理員可以使用此 kubeconfig 來建立角色和角色繫結。</span><span class="sxs-lookup"><span data-stu-id="937dc-298">The cluster administrator can use this kubeconfig to create roles and role bindings.</span></span>

<span data-ttu-id="937dc-299">由於叢集管理員認證的功能強大，因此使用 Azure RBAC 來限制其存取權：</span><span class="sxs-lookup"><span data-stu-id="937dc-299">Because the cluster admin credentials are so powerful, use Azure RBAC to restrict access to them:</span></span>

- <span data-ttu-id="937dc-300">「Azure Kubernetes Service 叢集管理員角色」有權下載叢集管理員認證。</span><span class="sxs-lookup"><span data-stu-id="937dc-300">The "Azure Kubernetes Service Cluster Admin Role" has permission to download the cluster admin credentials.</span></span> <span data-ttu-id="937dc-301">您應只將叢集管理員指派給此角色。</span><span class="sxs-lookup"><span data-stu-id="937dc-301">Only cluster administrators should be assigned to this role.</span></span>

- <span data-ttu-id="937dc-302">「Azure Kubernetes Service 叢集使用者角色」有權下載叢集使用者認證。</span><span class="sxs-lookup"><span data-stu-id="937dc-302">The "Azure Kubernetes Service Cluster User Role" has permission to download the cluster user credentials.</span></span> <span data-ttu-id="937dc-303">您可以將非管理員的使用者指派給這個角色。</span><span class="sxs-lookup"><span data-stu-id="937dc-303">Non-admin users can be assigned to this role.</span></span> <span data-ttu-id="937dc-304">此角色不會在叢集內的 Kubernetes 資源上提供任何特定權限 &mdash; 此角色只能讓使用者連線至 API 伺服器。</span><span class="sxs-lookup"><span data-stu-id="937dc-304">This role does not give any particular permissions on Kubernetes resources inside the cluster &mdash; it just allows a user to connect to the API server.</span></span> 

<span data-ttu-id="937dc-305">定義您的 RBAC 原則 (Kubernetes 和 Azure) 時，請考量您組織中的角色：</span><span class="sxs-lookup"><span data-stu-id="937dc-305">When you define your RBAC policies (both Kubernetes and Azure), think about the roles in your organization:</span></span>

- <span data-ttu-id="937dc-306">誰可以建立或刪除 AKS 叢集和下載管理員認證？</span><span class="sxs-lookup"><span data-stu-id="937dc-306">Who can create or delete an AKS cluster and download the admin credentials?</span></span>
- <span data-ttu-id="937dc-307">誰可以管理叢集？</span><span class="sxs-lookup"><span data-stu-id="937dc-307">Who can administer a cluster?</span></span>
- <span data-ttu-id="937dc-308">誰可以建立或更新命名空間內的資源？</span><span class="sxs-lookup"><span data-stu-id="937dc-308">Who can create or update resources within a namespace?</span></span>

<span data-ttu-id="937dc-309">以命名空間來界定 Kubernetes RBAC 權限的範圍是個好方法，請使用 Roles 和 RoleBindings，而不是 ClusterRoles 和 ClusterRoleBindings。</span><span class="sxs-lookup"><span data-stu-id="937dc-309">It's a good practice to scope Kubernetes RBAC permissions by namespace, using Roles and RoleBindings, rather than ClusterRoles and ClusterRoleBindings.</span></span>

<span data-ttu-id="937dc-310">最後有個問題，AKS 叢集有什麼權限可用來建立和管理 Azure 資源 (例如負載平衡器、網路功能或儲存體)。</span><span class="sxs-lookup"><span data-stu-id="937dc-310">Finally, there is the question of what permissions the AKS cluster has to create and manage Azure resources, such as load balancers, networking, or storage.</span></span> <span data-ttu-id="937dc-311">若要使用 Azure API 驗證叢集本身，叢集會使用 Azure AD 服務主體。</span><span class="sxs-lookup"><span data-stu-id="937dc-311">To authenticate itself with Azure APIs, the cluster uses an Azure AD service principal.</span></span> <span data-ttu-id="937dc-312">如果您未在建立叢集時指定服務主體，系統會自動建立一個。</span><span class="sxs-lookup"><span data-stu-id="937dc-312">If you don't specify a service principal when you create the cluster, one is created automatically.</span></span> <span data-ttu-id="937dc-313">不過，先建立服務主體，再將最低的 RBAC 權限指派給該服務主體是很好的安全性做法。</span><span class="sxs-lookup"><span data-stu-id="937dc-313">However, it's a good security practice to create the service principal first and assign the minimal RBAC permissions to it.</span></span> <span data-ttu-id="937dc-314">如需詳細資訊，請參閱[服務主體與 Azure Kubernetes Service](/azure/aks/kubernetes-service-principal)。</span><span class="sxs-lookup"><span data-stu-id="937dc-314">For more information, see [Service principals with Azure Kubernetes Service](/azure/aks/kubernetes-service-principal).</span></span>

### <a name="secrets-management-and-application-credentials"></a><span data-ttu-id="937dc-315">祕密管理和應用程式認證</span><span class="sxs-lookup"><span data-stu-id="937dc-315">Secrets management and application credentials</span></span>

<span data-ttu-id="937dc-316">應用程式和服務通常需要認證，才能連線到 Azure 儲存體或 SQL Database 等外部服務。</span><span class="sxs-lookup"><span data-stu-id="937dc-316">Applications and services often need credentials that allow them to connect to external services such as Azure Storage or SQL Database.</span></span> <span data-ttu-id="937dc-317">而所面臨的挑戰是保護這些認證的安全，以免遭到洩漏。</span><span class="sxs-lookup"><span data-stu-id="937dc-317">The challenge is to keep these credentials safe and not leak them.</span></span> 

<span data-ttu-id="937dc-318">針對Azure 資源，其中一個選項是使用受控識別。</span><span class="sxs-lookup"><span data-stu-id="937dc-318">For Azure resources, one option is to use managed identities.</span></span> <span data-ttu-id="937dc-319">受控識別的概念是應用程式或服務具有儲存在 Azure AD 中的身分識別，並會使用此身分識別向 Azure 服務進行驗證。</span><span class="sxs-lookup"><span data-stu-id="937dc-319">The idea of a managed identity is that an application or service has an identity stored in Azure AD, and uses this identity to authenticate with an Azure service.</span></span> <span data-ttu-id="937dc-320">應用程式或服務會在 Azure AD 中建立其服務主體，並使用 OAuth 2.0 權杖進行驗證。</span><span class="sxs-lookup"><span data-stu-id="937dc-320">The application or service has a Service Principal created for it in Azure AD, and authenticates using OAuth 2.0 tokens.</span></span> <span data-ttu-id="937dc-321">執行程序會呼叫 localhost 位址以取得權杖。</span><span class="sxs-lookup"><span data-stu-id="937dc-321">The executing process calls a localhost address to get the token.</span></span> <span data-ttu-id="937dc-322">如此一來，您就不需要儲存任何密碼或連接字串。</span><span class="sxs-lookup"><span data-stu-id="937dc-322">That way, you don't need to store any passwords or connection strings.</span></span> <span data-ttu-id="937dc-323">您可以藉由使用 [aad-pod-identity](https://github.com/Azure/aad-pod-identity) 專案將身分識別指派給個別的 Pod，以在 AKS 中使用受控識別。</span><span class="sxs-lookup"><span data-stu-id="937dc-323">You can use managed identities in AKS by assigning identities to individual pods, using the [aad-pod-identity](https://github.com/Azure/aad-pod-identity) project.</span></span>

<span data-ttu-id="937dc-324">目前，並非所有 Azure 服務都支援使用受控識別進行驗證。</span><span class="sxs-lookup"><span data-stu-id="937dc-324">Currently, not all Azure services support authentication using managed identities.</span></span> <span data-ttu-id="937dc-325">如需支援清單，請參閱[支援 Azure AD 驗證的 Azure 服務](/azure/active-directory/managed-identities-azure-resources/services-support-msi)。</span><span class="sxs-lookup"><span data-stu-id="937dc-325">For a list, see [Azure services that support Azure AD authentication](/azure/active-directory/managed-identities-azure-resources/services-support-msi).</span></span>

<span data-ttu-id="937dc-326">即使有受控識別，您仍可能需要儲存某些認證或其他應用程式祕密，以取得不支援受控識別的 Azure 服務、第三方服務和 API 金鑰等等。</span><span class="sxs-lookup"><span data-stu-id="937dc-326">Even with managed identities, you'll probably need to store some credentials or other application secrets, whether for Azure services that don't support managed identities, third-party services, API keys, and so on.</span></span> <span data-ttu-id="937dc-327">以下是可安全儲存祕密的一些選項：</span><span class="sxs-lookup"><span data-stu-id="937dc-327">Here are some options for storing secrets securely:</span></span>

- <span data-ttu-id="937dc-328">Azure Key Vault。</span><span class="sxs-lookup"><span data-stu-id="937dc-328">Azure Key Vault.</span></span> <span data-ttu-id="937dc-329">在 AKS 中，您可以將 Key Vault 中的一個或多個祕密掛接為磁碟區。</span><span class="sxs-lookup"><span data-stu-id="937dc-329">In AKS, you can mount one or more secrets from Key Vault as a volume.</span></span> <span data-ttu-id="937dc-330">磁碟區會從 Key Vault 讀取祕密。</span><span class="sxs-lookup"><span data-stu-id="937dc-330">The volume reads the secrets from Key Vault.</span></span> <span data-ttu-id="937dc-331">然後 Pod 就可以讀取祕密，就像是一般的磁碟區。</span><span class="sxs-lookup"><span data-stu-id="937dc-331">The pod can then read the secrets just like a regular volume.</span></span> <span data-ttu-id="937dc-332">如需詳細資訊，請參閱 GitHub 上的 [Kubernetes-KeyVault-FlexVolume](https://github.com/Azure/kubernetes-keyvault-flexvol) 專案。</span><span class="sxs-lookup"><span data-stu-id="937dc-332">For more information, see the [Kubernetes-KeyVault-FlexVolume](https://github.com/Azure/kubernetes-keyvault-flexvol) project on GitHub.</span></span>

    <span data-ttu-id="937dc-333">Pod 可使用 Pod 身分識別 (如上所述)，或使用 Azure AD 服務主體及用戶端密碼來驗證其本身。</span><span class="sxs-lookup"><span data-stu-id="937dc-333">The pod authenticates itself by using either a pod identity (described above) or by using an Azure AD Service Principal along with a client secret.</span></span> <span data-ttu-id="937dc-334">建議使用 Pod 身分識別，因為該案例中不需要用戶端密碼。</span><span class="sxs-lookup"><span data-stu-id="937dc-334">Using pod identities is recommended because the client secret isn't needed in that case.</span></span> 

- <span data-ttu-id="937dc-335">HashiCorp Vault。</span><span class="sxs-lookup"><span data-stu-id="937dc-335">HashiCorp Vault.</span></span> <span data-ttu-id="937dc-336">Kubernetes 應用程式可使用 Azure AD 受控識別向 HashiCorp Vault 進行驗證。</span><span class="sxs-lookup"><span data-stu-id="937dc-336">Kubernetes applications can authenticate with HashiCorp Vault using Azure AD managed identities.</span></span> <span data-ttu-id="937dc-337">請參閱 [HashiCorp Vault 可使用 Azure Active Directory](https://open.microsoft.com/2018/04/10/scaling-tips-hashicorp-vault-azure-active-directory/)。</span><span class="sxs-lookup"><span data-stu-id="937dc-337">See [HashiCorp Vault speaks Azure Active Directory](https://open.microsoft.com/2018/04/10/scaling-tips-hashicorp-vault-azure-active-directory/).</span></span> <span data-ttu-id="937dc-338">您可以將 Vault 本身部署到 Kubernetes，但建議您在應用程式叢集的個別專用叢集中執行該 Vault。</span><span class="sxs-lookup"><span data-stu-id="937dc-338">You can deploy Vault itself to Kubernetes, but it's recommend to run it in a separate dedicated cluster from your application cluster.</span></span> 

- <span data-ttu-id="937dc-339">Kubernetes 祕密。</span><span class="sxs-lookup"><span data-stu-id="937dc-339">Kubernetes secrets.</span></span> <span data-ttu-id="937dc-340">另一個選項是直接使用 Kubernetes 祕密。</span><span class="sxs-lookup"><span data-stu-id="937dc-340">Another option is simply to use Kubernetes secrets.</span></span> <span data-ttu-id="937dc-341">此選項最容易設定，但仍有一些挑戰。</span><span class="sxs-lookup"><span data-stu-id="937dc-341">This option is the easiest to configure but has some challenges.</span></span> <span data-ttu-id="937dc-342">祕密會儲存在 etcd，這是分散式的索引鍵-值存放區。</span><span class="sxs-lookup"><span data-stu-id="937dc-342">Secrets are stored in etcd, which is a distributed key-value store.</span></span> <span data-ttu-id="937dc-343">AKS [會對 etcd 進行待用加密](https://github.com/Azure/kubernetes-kms#azure-kubernetes-service-aks)。</span><span class="sxs-lookup"><span data-stu-id="937dc-343">AKS [encrypts etcd at rest](https://github.com/Azure/kubernetes-kms#azure-kubernetes-service-aks).</span></span> <span data-ttu-id="937dc-344">Microsoft 負責管理加密金鑰。</span><span class="sxs-lookup"><span data-stu-id="937dc-344">Microsoft manages the encryption keys.</span></span>

<span data-ttu-id="937dc-345">使用 HashiCorp Vault 或 Azure Key Vault 等系統有幾項優點，例如：</span><span class="sxs-lookup"><span data-stu-id="937dc-345">Using a system like HashiCorp Vault or Azure Key Vault provides several advantages, such as:</span></span>

- <span data-ttu-id="937dc-346">集中控制祕密。</span><span class="sxs-lookup"><span data-stu-id="937dc-346">Centralized control of secrets.</span></span>
- <span data-ttu-id="937dc-347">確保所有祕密都會進行待用加密。</span><span class="sxs-lookup"><span data-stu-id="937dc-347">Ensuring that all secrets are encrypted at rest.</span></span>
- <span data-ttu-id="937dc-348">集中管理金鑰。</span><span class="sxs-lookup"><span data-stu-id="937dc-348">Centralized key management.</span></span>
- <span data-ttu-id="937dc-349">對祕密進行存取控制。</span><span class="sxs-lookup"><span data-stu-id="937dc-349">Access control of secrets.</span></span>
- <span data-ttu-id="937dc-350">稽核</span><span class="sxs-lookup"><span data-stu-id="937dc-350">Auditing</span></span>

### <a name="pod-and-container-security"></a><span data-ttu-id="937dc-351">Pod 和容器安全性</span><span class="sxs-lookup"><span data-stu-id="937dc-351">Pod and container security</span></span>

<span data-ttu-id="937dc-352">這份清單並非詳盡無遺，但這裡有一些用來保護您 Pod 和容器的建議做法：</span><span class="sxs-lookup"><span data-stu-id="937dc-352">This list is certainly not exhaustive, but here are some recommended practices for securing your pods and containers:</span></span> 

<span data-ttu-id="937dc-353">請勿在具特殊權限的模式下執行容器。</span><span class="sxs-lookup"><span data-stu-id="937dc-353">Don't run containers in privileged mode.</span></span> <span data-ttu-id="937dc-354">具特殊權限的模式可讓容器存取主機上的所有裝置。</span><span class="sxs-lookup"><span data-stu-id="937dc-354">Privileged mode gives a container access to all devices on the host.</span></span> <span data-ttu-id="937dc-355">您可以設定 Pod 的安全性原則，以禁止在具特殊權限的模式下執行容器。</span><span class="sxs-lookup"><span data-stu-id="937dc-355">You can set Pod Security Policy to disallow containers from running in privileged mode.</span></span> 

<span data-ttu-id="937dc-356">可能的話，避免在容器內的根目錄中執行處理程序。</span><span class="sxs-lookup"><span data-stu-id="937dc-356">When possible, avoid running processes as root inside containers.</span></span> <span data-ttu-id="937dc-357">從安全性觀點來看，容器並不會提供完全的隔離，因此最好是以沒有特殊權限的使用者身分來執行容器程序。</span><span class="sxs-lookup"><span data-stu-id="937dc-357">Containers do not provide complete isolation from a security standpoint, so it's better to run a container process as a non-privileged user.</span></span> 

<span data-ttu-id="937dc-358">將映像儲存在受信任的私人容器登錄，例如 Azure Container Registry 或 Docker Trusted Registry。</span><span class="sxs-lookup"><span data-stu-id="937dc-358">Store images in a trusted private registry, such as Azure Container Registry or Docker Trusted Registry.</span></span> <span data-ttu-id="937dc-359">在 Kubernetes 中使用驗證許可 Webhook，以確保 Pod 只可從受信任的登錄提取映像。</span><span class="sxs-lookup"><span data-stu-id="937dc-359">Use a validating admission webhook in Kubernetes to ensure that pods can only pull images from the trusted registry.</span></span>

<span data-ttu-id="937dc-360">使用可透過 Azure Marketplace 取得的掃描解決方案 (例如 Twistlock 和 Aqua) 掃描映像，以檢查是否有已知弱點。</span><span class="sxs-lookup"><span data-stu-id="937dc-360">Scan images for known vulnerabilities, using a scanning solution such as Twistlock and Aqua, which are available through the Azure Marketplace.</span></span>

<span data-ttu-id="937dc-361">使用 ACR 工作 (Azure Container Registry 的一項功能) 自動修補映像。</span><span class="sxs-lookup"><span data-stu-id="937dc-361">Automate image patching using ACR Tasks, a feature of Azure Container Registry.</span></span> <span data-ttu-id="937dc-362">容器映像的建置會以階層為基礎。</span><span class="sxs-lookup"><span data-stu-id="937dc-362">A container image is built up from layers.</span></span> <span data-ttu-id="937dc-363">基底層包含 OS 映像和應用程式架構映像，例如 ASP.NET Core 或 Node.js。</span><span class="sxs-lookup"><span data-stu-id="937dc-363">The base layers include the OS image and application framework images, such as ASP.NET Core or Node.js.</span></span> <span data-ttu-id="937dc-364">通常，應用程式開發人員會在上游建立基底映像，並由其他專案維護人員來維護。</span><span class="sxs-lookup"><span data-stu-id="937dc-364">The base images are typically created upstream from the application developers, and are maintained by other project maintainers.</span></span> <span data-ttu-id="937dc-365">從上游修補這些映像時，務必更新、測試及重新部署您自己的映像，以免留下任何已知的安全性弱點。</span><span class="sxs-lookup"><span data-stu-id="937dc-365">When these images are patched upstream, it's important to update, test, and redeploy your own images, so that you don't leave any known security vulnerabilities.</span></span> <span data-ttu-id="937dc-366">ACR 工作可協助自動化此程序。</span><span class="sxs-lookup"><span data-stu-id="937dc-366">ACR Tasks can help to automate this process.</span></span>

## <a name="deployment-cicd-considerations"></a><span data-ttu-id="937dc-367">部署 (CI/CD) 考量︰</span><span class="sxs-lookup"><span data-stu-id="937dc-367">Deployment (CI/CD) considerations</span></span>

<span data-ttu-id="937dc-368">針對微服務架構，以下是強固 CI/CD 程序的一些目標：</span><span class="sxs-lookup"><span data-stu-id="937dc-368">Here are some goals of a robust CI/CD process for a microservices architecture:</span></span>

- <span data-ttu-id="937dc-369">每個小組都可建置並部署獨立擁有的服務，而不會影響或干擾其他小組。</span><span class="sxs-lookup"><span data-stu-id="937dc-369">Each team can build and deploy the services that it owns independently, without affecting or disrupting other teams.</span></span>

- <span data-ttu-id="937dc-370">將新版服務部署到生產環境之前，可先部署到開發/測試/QA 環境來進行驗證。</span><span class="sxs-lookup"><span data-stu-id="937dc-370">Before a new version of a service is deployed to production, it gets deployed to dev/test/QA environments for validation.</span></span> <span data-ttu-id="937dc-371">在每個階段上強制執行品質閘門 (Quality Gate)。</span><span class="sxs-lookup"><span data-stu-id="937dc-371">Quality gates are enforced at each stage.</span></span>

- <span data-ttu-id="937dc-372">部署新版服務時，前一版服務可並存。</span><span class="sxs-lookup"><span data-stu-id="937dc-372">A new version of a service can be deployed side-by-side with the previous version.</span></span>

- <span data-ttu-id="937dc-373">有足夠的存取控制原則。</span><span class="sxs-lookup"><span data-stu-id="937dc-373">Sufficient access control policies are in place.</span></span>

- <span data-ttu-id="937dc-374">您可以信任部署到生產環境的容器映像。</span><span class="sxs-lookup"><span data-stu-id="937dc-374">You can trust the container images that are deployed to production.</span></span>

### <a name="isolation-of-environments"></a><span data-ttu-id="937dc-375">環境隔離</span><span class="sxs-lookup"><span data-stu-id="937dc-375">Isolation of environments</span></span>

<span data-ttu-id="937dc-376">您部署服務時會用到多個環境，這些環境分別用於開發、煙霧測試 (Smoke Test)、整合測試、負載測試和最後的生產環境。</span><span class="sxs-lookup"><span data-stu-id="937dc-376">You will have multiple environments where you deploy services, including environments for development, smoke testing, integration testing, load testing, and finally production.</span></span> <span data-ttu-id="937dc-377">這些環境需要某種程度的隔離。</span><span class="sxs-lookup"><span data-stu-id="937dc-377">These environments need some level of isolation.</span></span> <span data-ttu-id="937dc-378">在 Kubernetes 中，您可以選擇實體隔離和邏輯隔離。</span><span class="sxs-lookup"><span data-stu-id="937dc-378">In Kubernetes, you have a choice between physical isolation and logical isolation.</span></span> <span data-ttu-id="937dc-379">實體隔離表示部署到不同叢集。</span><span class="sxs-lookup"><span data-stu-id="937dc-379">Physical isolation means deploying to separate clusters.</span></span> <span data-ttu-id="937dc-380">邏輯隔離會使用命名空間和原則，如先前所述。</span><span class="sxs-lookup"><span data-stu-id="937dc-380">Logical isolation makes use of namespaces and policies, as described earlier.</span></span>

<span data-ttu-id="937dc-381">我們建議您建立專用的生產環境叢集，以及用於開發/測試環境的個別叢集。</span><span class="sxs-lookup"><span data-stu-id="937dc-381">Our recommendation is to create a dedicated production cluster along with a separate cluster for your dev/test environments.</span></span> <span data-ttu-id="937dc-382">使用邏輯隔離來區隔開發/測試叢集內的環境。</span><span class="sxs-lookup"><span data-stu-id="937dc-382">Use logical isolation to separate environments within the dev/test cluster.</span></span> <span data-ttu-id="937dc-383">部署到開發/測試叢集的服務應一律不能存取保存商務資料的資料存放區。</span><span class="sxs-lookup"><span data-stu-id="937dc-383">Services deployed to the dev/test cluster should never have access to data stores that hold business data.</span></span> 

### <a name="helm"></a><span data-ttu-id="937dc-384">Helm</span><span class="sxs-lookup"><span data-stu-id="937dc-384">Helm</span></span>

<span data-ttu-id="937dc-385">請考慮使用 Helm 來管理服務的建置和部署。</span><span class="sxs-lookup"><span data-stu-id="937dc-385">Consider using Helm to manage building and deploying services.</span></span> <span data-ttu-id="937dc-386">Helm 的部分功能有助於實現 CI/CD，包括：</span><span class="sxs-lookup"><span data-stu-id="937dc-386">Some of the features of Helm that help with CI/CD include:</span></span>

- <span data-ttu-id="937dc-387">將特定微服務的所有 Kubernetes 物件組織到單一 Helm 圖表。</span><span class="sxs-lookup"><span data-stu-id="937dc-387">Organizing all of the Kubernetes objects for a particular microservice into a single Helm chart.</span></span>
- <span data-ttu-id="937dc-388">將圖表部署為單一 helm 命令，而不是一系列的 kubectl 命令。</span><span class="sxs-lookup"><span data-stu-id="937dc-388">Deploying the chart as a single helm command, rather than a series of kubectl commands.</span></span>
- <span data-ttu-id="937dc-389">使用語意化版本控制系統來追蹤更新和修訂，並且具有能夠復原到先前版本的功能。</span><span class="sxs-lookup"><span data-stu-id="937dc-389">Tracking updates and revisions, using semantic versioning, along with the ability to roll back to a previous version.</span></span>
- <span data-ttu-id="937dc-390">使用範本來避免許多檔案中的資訊重複，例如標籤和選取器。</span><span class="sxs-lookup"><span data-stu-id="937dc-390">The use of templates to avoid duplicating information, such as labels and selectors, across many files.</span></span>
- <span data-ttu-id="937dc-391">管理圖表之間的相依性。</span><span class="sxs-lookup"><span data-stu-id="937dc-391">Managing dependencies between charts.</span></span>
- <span data-ttu-id="937dc-392">將圖表發佈至 Helm 存放庫，例如 Azure Container Registry，並將圖表與組建管線整合。</span><span class="sxs-lookup"><span data-stu-id="937dc-392">Publishing charts to a Helm repository, such as Azure Container Registry, and integrating them with the build pipeline.</span></span>

<span data-ttu-id="937dc-393">如需有關使用 Container Registry 作為 Helm 存放庫的詳細資訊，請參閱[使用 Azure Container Registry 作為您應用程式圖表的 Helm 存放庫](/azure/container-registry/container-registry-helm-repos)。</span><span class="sxs-lookup"><span data-stu-id="937dc-393">For more information about using Container Registry as a Helm repository, see [Use Azure Container Registry as a Helm repository for your application charts](/azure/container-registry/container-registry-helm-repos).</span></span>

### <a name="cicd-workflow"></a><span data-ttu-id="937dc-394">CI/CD 工作流程</span><span class="sxs-lookup"><span data-stu-id="937dc-394">CI/CD workflow</span></span>

<span data-ttu-id="937dc-395">建立 CI/CD 工作流程之前，您必須知道如何結構化和管理程式碼基底。</span><span class="sxs-lookup"><span data-stu-id="937dc-395">Before creating a CI/CD workflow, you must know how the code base will be structured and managed.</span></span>

- <span data-ttu-id="937dc-396">小組是使用不同的存放庫或使用 monorepo (單一存放庫)？</span><span class="sxs-lookup"><span data-stu-id="937dc-396">Do teams work in separate respositories or in a monorepo (single respository)?</span></span>
- <span data-ttu-id="937dc-397">您的分支策略是什麼？</span><span class="sxs-lookup"><span data-stu-id="937dc-397">What is your branching strategy?</span></span>
- <span data-ttu-id="937dc-398">誰可以將程式碼推送至生產環境？</span><span class="sxs-lookup"><span data-stu-id="937dc-398">Who can push code to production?</span></span> <span data-ttu-id="937dc-399">有版本管理員角色嗎？</span><span class="sxs-lookup"><span data-stu-id="937dc-399">Is there a release manager role?</span></span>

<span data-ttu-id="937dc-400">雖然 monorepo 方法較受青睞，但這兩者都有優點和缺點。</span><span class="sxs-lookup"><span data-stu-id="937dc-400">The monorepo approach has been gaining favor but there are advantages and disadvantages to both.</span></span>

| &nbsp; | <span data-ttu-id="937dc-401">Monorepo</span><span class="sxs-lookup"><span data-stu-id="937dc-401">Monorepo</span></span> | <span data-ttu-id="937dc-402">多個存放庫</span><span class="sxs-lookup"><span data-stu-id="937dc-402">Multiple repos</span></span> |
|--------|----------|----------------|
| <span data-ttu-id="937dc-403">**優點**</span><span class="sxs-lookup"><span data-stu-id="937dc-403">**Advantages**</span></span> | <span data-ttu-id="937dc-404">程式碼共用</span><span class="sxs-lookup"><span data-stu-id="937dc-404">Code sharing</span></span><br/><span data-ttu-id="937dc-405">可更輕鬆地將程式碼及工具標準化</span><span class="sxs-lookup"><span data-stu-id="937dc-405">Easier to standardize code and tooling</span></span><br/><span data-ttu-id="937dc-406">可更輕鬆地重構程式碼</span><span class="sxs-lookup"><span data-stu-id="937dc-406">Easier to refactor code</span></span><br/><span data-ttu-id="937dc-407">可搜尋性 - 程式碼的單一檢視</span><span class="sxs-lookup"><span data-stu-id="937dc-407">Discoverability - single view of the code</span></span><br/> | <span data-ttu-id="937dc-408">每個小組有明確擁有權</span><span class="sxs-lookup"><span data-stu-id="937dc-408">Clear ownership per team</span></span><br/><span data-ttu-id="937dc-409">可能可減少合併衝突</span><span class="sxs-lookup"><span data-stu-id="937dc-409">Potentially fewer merge conflicts</span></span><br/><span data-ttu-id="937dc-410">有助於強制分離微服務</span><span class="sxs-lookup"><span data-stu-id="937dc-410">Helps to enforce decoupling of microservices</span></span> |
| <span data-ttu-id="937dc-411">**挑戰**</span><span class="sxs-lookup"><span data-stu-id="937dc-411">**Challenges**</span></span> | <span data-ttu-id="937dc-412">共用程式碼的變更可能會影響多個微服務</span><span class="sxs-lookup"><span data-stu-id="937dc-412">Changes to shared code can affect multiple microservices</span></span><br/><span data-ttu-id="937dc-413">很可能會有合併衝突</span><span class="sxs-lookup"><span data-stu-id="937dc-413">Greater potential for merge conflicts</span></span><br/><span data-ttu-id="937dc-414">工具必須擴充為大型程式碼基底</span><span class="sxs-lookup"><span data-stu-id="937dc-414">Tooling must scale to a large code base</span></span><br/><span data-ttu-id="937dc-415">存取控制</span><span class="sxs-lookup"><span data-stu-id="937dc-415">Access control</span></span><br/><span data-ttu-id="937dc-416">更複雜的部署程序</span><span class="sxs-lookup"><span data-stu-id="937dc-416">More complex deployment process</span></span> | <span data-ttu-id="937dc-417">難以共用程式碼</span><span class="sxs-lookup"><span data-stu-id="937dc-417">Harder to share code</span></span><br/><span data-ttu-id="937dc-418">難以強制執行編碼標準</span><span class="sxs-lookup"><span data-stu-id="937dc-418">Harder to enforce coding standards</span></span><br/><span data-ttu-id="937dc-419">相依性管理</span><span class="sxs-lookup"><span data-stu-id="937dc-419">Dependency management</span></span><br/><span data-ttu-id="937dc-420">擴散的程式碼基底、不佳的探索能力</span><span class="sxs-lookup"><span data-stu-id="937dc-420">Diffuse code base, poor discoverability</span></span><br/><span data-ttu-id="937dc-421">缺少共用的基礎結構</span><span class="sxs-lookup"><span data-stu-id="937dc-421">Lack of shared infrastructure</span></span>

<span data-ttu-id="937dc-422">在本節中，我們會以下列假設提供可能的 CI/CD 工作流程：</span><span class="sxs-lookup"><span data-stu-id="937dc-422">In this section, we present a possible CI/CD workflow, based on the following assumptions:</span></span>

- <span data-ttu-id="937dc-423">程式碼存放庫是 monorepo，包含根據微服務統整的資料夾。</span><span class="sxs-lookup"><span data-stu-id="937dc-423">The code repository is monorepo, with folders organized by microservice.</span></span>
- <span data-ttu-id="937dc-424">小組的分支策略是以[主幹型開發](https://trunkbaseddevelopment.com/)為基礎。</span><span class="sxs-lookup"><span data-stu-id="937dc-424">The team's branching strategy is based on [trunk-based development](https://trunkbaseddevelopment.com/).</span></span>
- <span data-ttu-id="937dc-425">小組會使用 [Azure Pipelines](/azure/devops/pipelines) 執行 CI/CD 程序。</span><span class="sxs-lookup"><span data-stu-id="937dc-425">The team uses [Azure Pipelines](/azure/devops/pipelines) to run the CI/CD process.</span></span>
- <span data-ttu-id="937dc-426">小組會在 Azure Container Registry 中使用[命名空間](/azure/container-registry/container-registry-best-practices#repository-namespaces)，以區隔核准用於生產環境的映像和仍在測試中的映像。</span><span class="sxs-lookup"><span data-stu-id="937dc-426">The team uses [namespaces](/azure/container-registry/container-registry-best-practices#repository-namespaces) in Azure Container Registry to isolate images that are approved for production from images that are still being tested.</span></span>

<span data-ttu-id="937dc-427">在此範例中，開發人員正在研究稱為「遞送服務」的微服務。</span><span class="sxs-lookup"><span data-stu-id="937dc-427">In this example, a developer is working on a microservice called Delivery Service.</span></span> <span data-ttu-id="937dc-428">(此名稱來自[此處](../../microservices/design/index.md#scenario)所述的參考實作。)在開發新功能的同時，開發人員會將程式碼簽入功能分支。</span><span class="sxs-lookup"><span data-stu-id="937dc-428">(The name comes from the reference implementation described [here](../../microservices/design/index.md#scenario).) While developing a new feature, the developer checks code into a feature branch.</span></span>

![CI/CD 工作流程](./_images/aks-cicd-1.png)

<span data-ttu-id="937dc-430">將認可推送至這個分支時會觸發微服務的 CI 組建。</span><span class="sxs-lookup"><span data-stu-id="937dc-430">Pushing commits to this branch tiggers a CI build for the microservice.</span></span> <span data-ttu-id="937dc-431">依照慣例，功能分支會命名為 `feature/*`。</span><span class="sxs-lookup"><span data-stu-id="937dc-431">By convention, feature branches are named `feature/*`.</span></span> <span data-ttu-id="937dc-432">[組建定義檔](/azure/devops/pipelines/yaml-schema)包含依分支名稱和來源路徑篩選的觸發程序。</span><span class="sxs-lookup"><span data-stu-id="937dc-432">The [build definition file](/azure/devops/pipelines/yaml-schema) includes a trigger that filters by the branch name and the source path.</span></span> <span data-ttu-id="937dc-433">使用此方法，每個小組都可以有自己的組建管線。</span><span class="sxs-lookup"><span data-stu-id="937dc-433">Using this approach, each team can have its own build pipeline.</span></span>

```yaml
trigger:
  batch: true
  branches:
    include:
    - master
    - feature/*

    exclude:
    - feature/experimental/*

  paths:
     include:
     - /src/shipping/delivery/
```

<span data-ttu-id="937dc-434">此時在流程中，CI 組建會執行一些最基本的程式碼驗證：</span><span class="sxs-lookup"><span data-stu-id="937dc-434">At this point in the workflow, the CI build runs some minimal code verification:</span></span>

1. <span data-ttu-id="937dc-435">建置程式碼</span><span class="sxs-lookup"><span data-stu-id="937dc-435">Build code</span></span>
1. <span data-ttu-id="937dc-436">執行單元測試</span><span class="sxs-lookup"><span data-stu-id="937dc-436">Run unit tests</span></span>

<span data-ttu-id="937dc-437">這邊的意思是要讓建置時間保持簡短，讓開發人員可以快速取得意見反應。</span><span class="sxs-lookup"><span data-stu-id="937dc-437">The idea here is to keep the build times short so the developer can get quick feedback.</span></span> <span data-ttu-id="937dc-438">開發人員會在功能可合併到主體時開啟 PR。</span><span class="sxs-lookup"><span data-stu-id="937dc-438">When the feature is ready to merge into master, the developer opens a PR.</span></span> <span data-ttu-id="937dc-439">這會觸發另一個 CI 組建，以執行一些額外的檢查：</span><span class="sxs-lookup"><span data-stu-id="937dc-439">This triggers another CI build that performs some additional checks:</span></span>

1. <span data-ttu-id="937dc-440">建置程式碼</span><span class="sxs-lookup"><span data-stu-id="937dc-440">Build code</span></span>
1. <span data-ttu-id="937dc-441">執行單元測試</span><span class="sxs-lookup"><span data-stu-id="937dc-441">Run unit tests</span></span>
1. <span data-ttu-id="937dc-442">建置執行階段容器映像</span><span class="sxs-lookup"><span data-stu-id="937dc-442">Build the runtime container image</span></span>
1. <span data-ttu-id="937dc-443">在映像上執行弱點掃描</span><span class="sxs-lookup"><span data-stu-id="937dc-443">Run vulnerability scans on the image</span></span>

![CI/CD 工作流程](./_images/aks-cicd-2.png)

> [!NOTE]
> <span data-ttu-id="937dc-445">在 Azure Repos 中，您可以定義[原則](/azure/devops/repos/git/branch-policies)來保護分支。</span><span class="sxs-lookup"><span data-stu-id="937dc-445">In Azure Repos, you can define [policies](/azure/devops/repos/git/branch-policies) to protect branches.</span></span> <span data-ttu-id="937dc-446">例如，原則可能需要成功的 CI 組建再加上核准者的簽核，才能合併至主體。</span><span class="sxs-lookup"><span data-stu-id="937dc-446">For example, the policy could require a successful CI build plus a sign-off from an approver in order to merge into master.</span></span>

<span data-ttu-id="937dc-447">在某個時間點，小組已準備好部署新版的「遞送」服務。</span><span class="sxs-lookup"><span data-stu-id="937dc-447">At some point, the team is ready to deploy a new version of the Delivery service.</span></span> <span data-ttu-id="937dc-448">若要這樣做，版本管理員會使用以下命名模式，從主體中建立分支：`release/<microservice name>/<semver>`。</span><span class="sxs-lookup"><span data-stu-id="937dc-448">To do so, the release manager creates a branch from master with this naming pattern: `release/<microservice name>/<semver>`.</span></span> <span data-ttu-id="937dc-449">例如： `release/delivery/v1.0.2`。</span><span class="sxs-lookup"><span data-stu-id="937dc-449">For example, `release/delivery/v1.0.2`.</span></span>
<span data-ttu-id="937dc-450">這會觸發執行上述所有步驟的完整 CI 組建，以及：</span><span class="sxs-lookup"><span data-stu-id="937dc-450">This triggers a full CI build that runs all the previous steps plus:</span></span>

1. <span data-ttu-id="937dc-451">將 Docker 映像推送至 Azure Container Registry。</span><span class="sxs-lookup"><span data-stu-id="937dc-451">Push the Docker image to Azure Container Registry.</span></span> <span data-ttu-id="937dc-452">映像會以取自分支名稱的版本號碼來標記。</span><span class="sxs-lookup"><span data-stu-id="937dc-452">The image is tagged with the version number taken from the branch name.</span></span>
2. <span data-ttu-id="937dc-453">執行 `helm package` 即可封裝 Helm 圖表</span><span class="sxs-lookup"><span data-stu-id="937dc-453">Run `helm package` to package the Helm chart</span></span>
3. <span data-ttu-id="937dc-454">執行 `az acr helm push` 可將 Helm 套件推送至 Container Registry。</span><span class="sxs-lookup"><span data-stu-id="937dc-454">Push the Helm package to Container Registry by running `az acr helm push`.</span></span>

<span data-ttu-id="937dc-455">假如此組建成功完成，即會觸發使用 Azure Pipelines [發行管線](/azure/devops/pipelines/release/what-is-release-management)的部署程序。</span><span class="sxs-lookup"><span data-stu-id="937dc-455">Assuming this build succeeds, it triggers a deployment process using an Azure Pipelines [release pipeline](/azure/devops/pipelines/release/what-is-release-management).</span></span> <span data-ttu-id="937dc-456">此管線會有下列動作</span><span class="sxs-lookup"><span data-stu-id="937dc-456">This pipeline</span></span>

1. <span data-ttu-id="937dc-457">執行 `helm upgrade`，將 Helm 圖表部署至 QA 環境。</span><span class="sxs-lookup"><span data-stu-id="937dc-457">Run `helm upgrade` to deploy the Helm chart to a QA environment.</span></span>
1. <span data-ttu-id="937dc-458">將套件移到生產環境之前，核准者會先進行簽核。</span><span class="sxs-lookup"><span data-stu-id="937dc-458">An approver signs off before the package moves to production.</span></span> <span data-ttu-id="937dc-459">請參閱[使用核准功能的發行部署控制](/azure/devops/pipelines/release/approvals/approvals)。</span><span class="sxs-lookup"><span data-stu-id="937dc-459">See [Release deployment control using approvals](/azure/devops/pipelines/release/approvals/approvals).</span></span>
1. <span data-ttu-id="937dc-460">為 Azure Container Registry 中的生產命名空間重新標記 Docker 映像。</span><span class="sxs-lookup"><span data-stu-id="937dc-460">Re-tag the Docker image for the production namespace in Azure Container Registry.</span></span> <span data-ttu-id="937dc-461">例如，如果目前的標記是 `myrepo.azurecr.io/delivery:v1.0.2`，則生產標記就會是 `myrepo.azurecr.io/prod/delivery:v1.0.2`。</span><span class="sxs-lookup"><span data-stu-id="937dc-461">For example, if the current tag is `myrepo.azurecr.io/delivery:v1.0.2`, the production tag is `myrepo.azurecr.io/prod/delivery:v1.0.2`.</span></span>
1. <span data-ttu-id="937dc-462">執行 `helm upgrade`，將 Helm 圖表部署至生產環境。</span><span class="sxs-lookup"><span data-stu-id="937dc-462">Run `helm upgrade` to deploy the Helm chart to the production environment.</span></span>

![CI/CD 工作流程](./_images/aks-cicd-3.png)

<span data-ttu-id="937dc-464">請務必記住這些工作可以涵蓋在個別的微服務中 (即使是 monorepo 也一樣)，以便小組快速進行部署。</span><span class="sxs-lookup"><span data-stu-id="937dc-464">It's important to remember that even in a monorepo, these tasks can be scoped to individual microservices, so that teams can deploy with high velocity.</span></span> <span data-ttu-id="937dc-465">處理程序中有一些手動步驟：核准 PR、建立發行分支，以及將部署核准到生產叢集中。</span><span class="sxs-lookup"><span data-stu-id="937dc-465">There are some manual steps in the process: Approving PRs, creating release branches, and approving deployments into the production cluster.</span></span> <span data-ttu-id="937dc-466">這些步驟會透過原則來手動執行 &mdash; 如果組織想要的話，也可以將其完全自動化。</span><span class="sxs-lookup"><span data-stu-id="937dc-466">These steps are manual by policy &mdash; they could be completely automated if the organization prefers.</span></span>
