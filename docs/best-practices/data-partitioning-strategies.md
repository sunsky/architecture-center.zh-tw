---
title: 資料分割策略
titleSuffix: Best practices for cloud applications
description: 分割要個別管理和存取的資料分割指引。
author: dragon119
ms.date: 11/04/2018
ms.topic: best-practice
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: bb810f549c78d16eabd4a96cd811cdc120cc8b6f
ms.sourcegitcommit: 579c39ff4b776704ead17a006bf24cd4cdc65edd
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/17/2019
ms.locfileid: "59640935"
---
# <a name="data-partitioning-strategies"></a><span data-ttu-id="c38bc-103">資料分割策略</span><span class="sxs-lookup"><span data-stu-id="c38bc-103">Data partitioning strategies</span></span>

<span data-ttu-id="c38bc-104">本文說明一些在各種 Azure 資料存放區中分割資料的策略。</span><span class="sxs-lookup"><span data-stu-id="c38bc-104">This article describes some strategies for partitioning data in various Azure data stores.</span></span> <span data-ttu-id="c38bc-105">如需有關何時分割資料和最佳做法的一般指引，請參閱[資料分割](./data-partitioning.md)</span><span class="sxs-lookup"><span data-stu-id="c38bc-105">For general guidance about when to partition data and best practices, see [Data partitioning](./data-partitioning.md)</span></span>

## <a name="partitioning-azure-sql-database"></a><span data-ttu-id="c38bc-106">分割 Azure SQL Database</span><span class="sxs-lookup"><span data-stu-id="c38bc-106">Partitioning Azure SQL Database</span></span>

<span data-ttu-id="c38bc-107">單一 SQL 資料庫會對其可包含的資料量有所限制。</span><span class="sxs-lookup"><span data-stu-id="c38bc-107">A single SQL database has a limit to the volume of data that it can contain.</span></span> <span data-ttu-id="c38bc-108">輸送量會受到結構性因素和其支援之並行連接數目的限制。</span><span class="sxs-lookup"><span data-stu-id="c38bc-108">Throughput is constrained by architectural factors and the number of concurrent connections that it supports.</span></span>

<span data-ttu-id="c38bc-109">[彈性集區](/azure/sql-database/sql-database-elastic-pool)支援 SQL 資料庫的水平調整。</span><span class="sxs-lookup"><span data-stu-id="c38bc-109">[Elastic pools](/azure/sql-database/sql-database-elastic-pool) support horizontal scaling for a SQL database.</span></span> <span data-ttu-id="c38bc-110">使用彈性集區，您可以將資料分割成分區，以分佈到多個 SQL 資料庫。</span><span class="sxs-lookup"><span data-stu-id="c38bc-110">Using elastic pools, you can partition your data into shards that are spread across multiple SQL databases.</span></span> <span data-ttu-id="c38bc-111">您也可以因為需要處理的資料量成長和縮減而新增或移除分區。</span><span class="sxs-lookup"><span data-stu-id="c38bc-111">You can also add or remove shards as the volume of data that you need to handle grows and shrinks.</span></span> <span data-ttu-id="c38bc-112">彈性集區也可以藉由將負載分散到多個資料庫，協助減少爭用。</span><span class="sxs-lookup"><span data-stu-id="c38bc-112">Elastic pools can also help reduce contention by distributing the load across databases.</span></span>

<span data-ttu-id="c38bc-113">每個分區都被實作成 SQL 資料庫。</span><span class="sxs-lookup"><span data-stu-id="c38bc-113">Each shard is implemented as a SQL database.</span></span> <span data-ttu-id="c38bc-114">一個分區可以保留多個資料集 (稱為 Shardlet)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-114">A shard can hold more than one dataset (called a *shardlet*).</span></span> <span data-ttu-id="c38bc-115">每個資料庫會維護描述其所包含之 shardlet 的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-115">Each database maintains metadata that describes the shardlets that it contains.</span></span> <span data-ttu-id="c38bc-116">Shardlet 可以是單一資料項目，或一組共用相同 Shardlet 索引鍵的項目。</span><span class="sxs-lookup"><span data-stu-id="c38bc-116">A shardlet can be a single data item, or a group of items that share the same shardlet key.</span></span> <span data-ttu-id="c38bc-117">例如，在多租用戶應用程式中，Shardlet 索引鍵可以是租用戶識別碼，而租用戶的所有資料都可保留在相同 Shardlet 中。</span><span class="sxs-lookup"><span data-stu-id="c38bc-117">For example, in a multitenant application, the shardlet key can be the tenant ID, and all data for a tenant can be held in the same shardlet.</span></span>

<span data-ttu-id="c38bc-118">用戶端應用程式會負責將資料集與 Shardlet 索引鍵產生關聯。</span><span class="sxs-lookup"><span data-stu-id="c38bc-118">Client applications are responsible for associating a dataset with a shardlet key.</span></span> <span data-ttu-id="c38bc-119">個別的 SQL 資料庫可做為全域分區對應管理員。</span><span class="sxs-lookup"><span data-stu-id="c38bc-119">A separate SQL database acts as a global shard map manager.</span></span> <span data-ttu-id="c38bc-120">此資料庫具有一份系統中所有分區和 Shardlet 的清單。</span><span class="sxs-lookup"><span data-stu-id="c38bc-120">This database has a list of all the shards and shardlets in the system.</span></span> <span data-ttu-id="c38bc-121">應用程式會連線到分區對應管理員資料庫，以取得分區對應的複本。</span><span class="sxs-lookup"><span data-stu-id="c38bc-121">The application connects to the shard map manager database to obtain a copy of the shard map.</span></span> <span data-ttu-id="c38bc-122">它會在本機快取分區對應，並使用對應來將資料要求路由傳送至適當的分區。</span><span class="sxs-lookup"><span data-stu-id="c38bc-122">It caches the shard map locally, and uses the map to route data requests to the appropriate shard.</span></span> <span data-ttu-id="c38bc-123">此功能隱藏在一系列 API (包含在[彈性資料庫用戶端程式庫](/azure/sql-database/sql-database-elastic-database-client-library)中) 之後，適用於 Java 和 .NET。</span><span class="sxs-lookup"><span data-stu-id="c38bc-123">This functionality is hidden behind a series of APIs that are contained in the [Elastic Database client library](/azure/sql-database/sql-database-elastic-database-client-library), which is available for Java and .NET.</span></span>

<span data-ttu-id="c38bc-124">如需彈性集區的詳細資訊，請參閱[使用Azure SQL Database 相應放大](/azure/sql-database/sql-database-elastic-scale-introduction)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-124">For more information about elastic pools, see [Scaling out with Azure SQL Database](/azure/sql-database/sql-database-elastic-scale-introduction).</span></span>

<span data-ttu-id="c38bc-125">若要減少延遲並改善可用性，您可以複寫全域分區對應管理員資料庫。</span><span class="sxs-lookup"><span data-stu-id="c38bc-125">To reduce latency and improve availability, you can replicate the global shard map manager database.</span></span> <span data-ttu-id="c38bc-126">您可以使用進階定價層，設定作用中的異地複寫，持續將資料複製到不同區域中的資料庫。</span><span class="sxs-lookup"><span data-stu-id="c38bc-126">With the Premium pricing tiers, you can configure active geo-replication to continuously copy data to databases in different regions.</span></span>

<span data-ttu-id="c38bc-127">另外，使用 [Azure SQL 資料同步](/azure/sql-database/sql-database-sync-data)或 [Azure Data Factory](/azure/data-factory/)，跨區域複寫分區對應管理員資料庫。</span><span class="sxs-lookup"><span data-stu-id="c38bc-127">Alternatively, use [Azure SQL Data Sync](/azure/sql-database/sql-database-sync-data) or [Azure Data Factory](/azure/data-factory/) to replicate the shard map manager database across regions.</span></span> <span data-ttu-id="c38bc-128">這種形式的複寫會定期執行，如果分區對應不常變更就更適合，而且不需要進階層。</span><span class="sxs-lookup"><span data-stu-id="c38bc-128">This form of replication runs periodically and is more suitable if the shard map changes infrequently, and does not require Premium tier.</span></span>

<span data-ttu-id="c38bc-129">彈性資料庫提供將資料對應到 shardlet 並將它們儲存在分區中的兩個配置：</span><span class="sxs-lookup"><span data-stu-id="c38bc-129">Elastic Database provides two schemes for mapping data to shardlets and storing them in shards:</span></span>

- <span data-ttu-id="c38bc-130">**清單分區對應**會將單一索引鍵關聯至 Shardlet。</span><span class="sxs-lookup"><span data-stu-id="c38bc-130">A **list shard map** associates a single key to a shardlet.</span></span> <span data-ttu-id="c38bc-131">例如，在多租用戶系統中，每個租用戶的資料可以和唯一的索引鍵相關聯，並儲存在自己的 shardlet 中。</span><span class="sxs-lookup"><span data-stu-id="c38bc-131">For example, in a multitenant system, the data for each tenant can be associated with a unique key and stored in its own shardlet.</span></span> <span data-ttu-id="c38bc-132">為了保證隔離，每個 Shardlet 都可以保留在自己的分區內。</span><span class="sxs-lookup"><span data-stu-id="c38bc-132">To guarantee isolation, each shardlet can be held within its own shard.</span></span>

    ![使用清單分區對應來將租用戶資料儲存在個別分區中](./images/data-partitioning/PointShardlet.png)

- <span data-ttu-id="c38bc-134">**範圍分區對應**會將一組連續索引鍵值關聯至 Shardlet。</span><span class="sxs-lookup"><span data-stu-id="c38bc-134">A **range shard map** associates a set of contiguous key values to a shardlet.</span></span> <span data-ttu-id="c38bc-135">例如，您可以在相同 Shardlet 內將一組租用戶 (有各自的索引鍵) 資料群組在一起。</span><span class="sxs-lookup"><span data-stu-id="c38bc-135">For example, you can group the data for a set of tenants (each with their own key) within the same shardlet.</span></span> <span data-ttu-id="c38bc-136">此配置比第一個配置成本低，因為租用戶共用資料儲存空間，但是隔離程度較低。</span><span class="sxs-lookup"><span data-stu-id="c38bc-136">This scheme is less expensive than the first, because tenants share data storage, but has less isolation.</span></span>

    ![使用範圍分區對應來儲存分區中租用戶範圍的資料](./images/data-partitioning/RangeShardlet.png)

<span data-ttu-id="c38bc-138">單一分區可以包含數個 Shardlet 的資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-138">A single shard can contain the data for several shardlets.</span></span> <span data-ttu-id="c38bc-139">例如，您可以使用清單 shardlet，將不同非連續租用戶的資料儲存在相同的分區中。</span><span class="sxs-lookup"><span data-stu-id="c38bc-139">For example, you can use list shardlets to store data for different non-contiguous tenants in the same shard.</span></span> <span data-ttu-id="c38bc-140">您也可以混合相同分區中的範圍 Shardlet 和清單 Shardlet，雖然它們會透過不同對應來處理。</span><span class="sxs-lookup"><span data-stu-id="c38bc-140">You can also mix range shardlets and list shardlets in the same shard, although they will be addressed through different maps.</span></span> <span data-ttu-id="c38bc-141">下圖顯示這個方法：</span><span class="sxs-lookup"><span data-stu-id="c38bc-141">The following diagram shows this approach:</span></span>

![實作多個分區對應](./images/data-partitioning/MultipleShardMaps.png)

<span data-ttu-id="c38bc-143">彈性集區能夠在資料數量縮小和成長時，新增及移除分區。</span><span class="sxs-lookup"><span data-stu-id="c38bc-143">Elastic pools makes it possible to add and remove shards as the volume of data shrinks and grows.</span></span> <span data-ttu-id="c38bc-144">用戶端應用程式可以動態建立和刪除分區，並且明確地更新分區對應管理員。</span><span class="sxs-lookup"><span data-stu-id="c38bc-144">Client applications can create and delete shards dynamically, and transparently update the shard map manager.</span></span> <span data-ttu-id="c38bc-145">但是，移除分區是破壞性作業，也需要刪除該分區中的所有資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-145">However, removing a shard is a destructive operation that also requires deleting all the data in that shard.</span></span>

<span data-ttu-id="c38bc-146">如果應用程式必須將一個分區劃分成兩個個別的分區，或將分區結合在一起，請使用[劃分-合併工具](/azure/sql-database/sql-database-elastic-scale-overview-split-and-merge)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-146">If an application needs to split a shard into two separate shards or combine shards, use the [split-merge tool](/azure/sql-database/sql-database-elastic-scale-overview-split-and-merge).</span></span> <span data-ttu-id="c38bc-147">此工具會執行為 Azure Web 服務，並且在分區之間安全地遷移資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-147">This tool runs as an Azure web service, and migrates data safely between shards.</span></span>

<span data-ttu-id="c38bc-148">資料分割配置會大幅影響系統效能。</span><span class="sxs-lookup"><span data-stu-id="c38bc-148">The partitioning scheme can significantly affect the performance of your system.</span></span> <span data-ttu-id="c38bc-149">它也會影響必須新增或移除分區的速率，或者必須跨分區重新分割的資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-149">It can also affect the rate at which shards have to be added or removed, or that data must be repartitioned across shards.</span></span> <span data-ttu-id="c38bc-150">請考慮下列幾點：</span><span class="sxs-lookup"><span data-stu-id="c38bc-150">Consider the following points:</span></span>

- <span data-ttu-id="c38bc-151">將一起使用的資料群組到同一個分區，並避免從多個分區存取資料的作業。</span><span class="sxs-lookup"><span data-stu-id="c38bc-151">Group data that is used together in the same shard, and avoid operations that access data from multiple shards.</span></span> <span data-ttu-id="c38bc-152">分區是自有權限的 SQL 資料庫，必須在用戶端上執行跨資料庫聯結。</span><span class="sxs-lookup"><span data-stu-id="c38bc-152">A shard is a SQL database in its own right, and cross-database joins must be performed on the client side.</span></span>

    <span data-ttu-id="c38bc-153">雖然 SQL Database 不支援跨資料庫聯結，您可以使用彈性資料庫工具來執行[多分區查詢](/azure/sql-database/sql-database-elastic-scale-multishard-querying)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-153">Although SQL Database does not support cross-database joins, you can use the Elastic Database tools to perform [multi-shard queries](/azure/sql-database/sql-database-elastic-scale-multishard-querying).</span></span> <span data-ttu-id="c38bc-154">多分區查詢會將個別查詢傳送至每個資料庫，並合併結果。</span><span class="sxs-lookup"><span data-stu-id="c38bc-154">A multi-shard query sends individual queries to each database and merges the results.</span></span>

- <span data-ttu-id="c38bc-155">請不要設計在分區之間具有相依性的系統。</span><span class="sxs-lookup"><span data-stu-id="c38bc-155">Don't design a system that has dependencies between shards.</span></span> <span data-ttu-id="c38bc-156">某一個資料庫中的參考完整性條件約束、觸發程序及預存程序都無法參考另一個資料庫中的物件。</span><span class="sxs-lookup"><span data-stu-id="c38bc-156">Referential integrity constraints, triggers, and stored procedures in one database cannot reference objects in another.</span></span>

- <span data-ttu-id="c38bc-157">如果您有查詢經常使用的參考資料，請考慮跨分區複寫此資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-157">If you have reference data that is frequently used by queries, consider replicating this data across shards.</span></span> <span data-ttu-id="c38bc-158">這種方法可以移除跨資料庫聯結資料的需求。</span><span class="sxs-lookup"><span data-stu-id="c38bc-158">This approach can remove the need to join data across databases.</span></span> <span data-ttu-id="c38bc-159">在理想的情況下，這類資料應該是靜態或緩慢移動的，才能最小化複寫工作量並降低它陳舊的機會。</span><span class="sxs-lookup"><span data-stu-id="c38bc-159">Ideally, such data should be static or slow-moving, to minimize the replication effort and reduce the chances of it becoming stale.</span></span>

- <span data-ttu-id="c38bc-160">屬於相同分區對應的 Shardlet 應該具有相同的結構描述。</span><span class="sxs-lookup"><span data-stu-id="c38bc-160">Shardlets that belong to the same shard map should have the same schema.</span></span> <span data-ttu-id="c38bc-161">此規則不會由 SQL Database 強制執行，但如果每個 Shardlet 都具有不同的結構描述，資料管理和查詢會變得非常複雜。</span><span class="sxs-lookup"><span data-stu-id="c38bc-161">This rule is not enforced by SQL Database, but data management and querying becomes very complex if each shardlet has a different schema.</span></span> <span data-ttu-id="c38bc-162">相反地，為每個結構描述建立個別的分區對應。</span><span class="sxs-lookup"><span data-stu-id="c38bc-162">Instead, create separate shard maps for each schema.</span></span> <span data-ttu-id="c38bc-163">請記住，屬於不同 Shardlet 的資料可以儲存在相同的分區中。</span><span class="sxs-lookup"><span data-stu-id="c38bc-163">Remember that data belonging to different shardlets can be stored in the same shard.</span></span>

- <span data-ttu-id="c38bc-164">只有分區內的資料支援交易式作業，跨分區並不支援。</span><span class="sxs-lookup"><span data-stu-id="c38bc-164">Transactional operations are only supported for data within a shard, and not across shards.</span></span> <span data-ttu-id="c38bc-165">交易可以跨越 shardlet，只要它們是相同分區的一部分。</span><span class="sxs-lookup"><span data-stu-id="c38bc-165">Transactions can span shardlets as long as they are part of the same shard.</span></span> <span data-ttu-id="c38bc-166">因此，如果您的商務邏輯需要執行交易，請將資料儲存在相同的分區，或實作最終一致性。</span><span class="sxs-lookup"><span data-stu-id="c38bc-166">Therefore, if your business logic needs to perform transactions, either store the data in the same shard or implement eventual consistency.</span></span>

- <span data-ttu-id="c38bc-167">將分區放在要存取這些分區中之資料的使用者附近。</span><span class="sxs-lookup"><span data-stu-id="c38bc-167">Place shards close to the users that access the data in those shards.</span></span> <span data-ttu-id="c38bc-168">此策略有助於減少延遲。</span><span class="sxs-lookup"><span data-stu-id="c38bc-168">This strategy helps reduce latency.</span></span>

- <span data-ttu-id="c38bc-169">避免混合高度作用中和相對非使用中的分區。</span><span class="sxs-lookup"><span data-stu-id="c38bc-169">Avoid having a mixture of highly active and relatively inactive shards.</span></span> <span data-ttu-id="c38bc-170">請嘗試跨分區平均分散負載。</span><span class="sxs-lookup"><span data-stu-id="c38bc-170">Try to spread the load evenly across shards.</span></span> <span data-ttu-id="c38bc-171">這可能需要為分區金鑰設定雜湊。</span><span class="sxs-lookup"><span data-stu-id="c38bc-171">This might require hashing the sharding keys.</span></span> <span data-ttu-id="c38bc-172">如果您是地理尋找分區，請確定雜湊索引鍵對應的 shardlet 保留在分區中 (這些分區儲存在存取該資料的使用者附近)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-172">If you are geo-locating shards, make sure that the hashed keys map to shardlets held in shards stored close to the users that access that data.</span></span>

### <a name="partitioning-azure-table-storage"></a><span data-ttu-id="c38bc-173">分割 Azure 表格儲存體</span><span class="sxs-lookup"><span data-stu-id="c38bc-173">Partitioning Azure table storage</span></span>

<span data-ttu-id="c38bc-174">Azure 表格儲存體是一個索引鍵-值存放區，專為資料分割而設計。</span><span class="sxs-lookup"><span data-stu-id="c38bc-174">Azure table storage is a key-value store that's designed around partitioning.</span></span> <span data-ttu-id="c38bc-175">所有實體都會儲存在分割區中，而且分割區會在內部由 Azure 表格儲存體管理。</span><span class="sxs-lookup"><span data-stu-id="c38bc-175">All entities are stored in a partition, and partitions are managed internally by Azure table storage.</span></span> <span data-ttu-id="c38bc-176">儲存在資料表中的每個實體都必須提供兩個部分的索引鍵，其中包括：</span><span class="sxs-lookup"><span data-stu-id="c38bc-176">Each entity stored in a table must provide a two-part key that includes:</span></span>

- <span data-ttu-id="c38bc-177">**分割區索引鍵**。</span><span class="sxs-lookup"><span data-stu-id="c38bc-177">**The partition key**.</span></span> <span data-ttu-id="c38bc-178">此為字串值，可決定 Azure 資料表儲存體將在哪個分割區中放置實體。</span><span class="sxs-lookup"><span data-stu-id="c38bc-178">This is a string value that determines the partition where Azure table storage will place the entity.</span></span> <span data-ttu-id="c38bc-179">具有相同資料分割索引鍵的所有實體將會儲存在相同分割區上。</span><span class="sxs-lookup"><span data-stu-id="c38bc-179">All entities with the same partition key are stored in the same partition.</span></span>

- <span data-ttu-id="c38bc-180">**資料列索引鍵**。</span><span class="sxs-lookup"><span data-stu-id="c38bc-180">**The row key**.</span></span> <span data-ttu-id="c38bc-181">這是字串值，會識別分割區內的實體。</span><span class="sxs-lookup"><span data-stu-id="c38bc-181">This is a string value that identifies the entity within the partition.</span></span> <span data-ttu-id="c38bc-182">在一個分割區內的所有實體都會由此索引鍵依照語彙以遞增順序排列。</span><span class="sxs-lookup"><span data-stu-id="c38bc-182">All entities within a partition are sorted lexically, in ascending order, by this key.</span></span> <span data-ttu-id="c38bc-183">分割區索引鍵/資料列索引鍵組合對每個實體必須是唯一的，且長度不能超過 1 KB。</span><span class="sxs-lookup"><span data-stu-id="c38bc-183">The partition key/row key combination must be unique for each entity and cannot exceed 1 KB in length.</span></span>

<span data-ttu-id="c38bc-184">如果實體已利用先前未使用的分割區索引鍵新增至表格，Azure 表格儲存體就會為此實體建立新的分割區。</span><span class="sxs-lookup"><span data-stu-id="c38bc-184">If an entity is added to a table with a previously unused partition key, Azure table storage creates a new partition for this entity.</span></span> <span data-ttu-id="c38bc-185">具有相同資料分割索引鍵的其他實體將會儲存在相同分割區中。</span><span class="sxs-lookup"><span data-stu-id="c38bc-185">Other entities with the same partition key will be stored in the same partition.</span></span>

<span data-ttu-id="c38bc-186">這項機制會有效地實作自動化的向外延展策略。</span><span class="sxs-lookup"><span data-stu-id="c38bc-186">This mechanism effectively implements an automatic scale-out strategy.</span></span> <span data-ttu-id="c38bc-187">每個分割區都會儲存在 Azure 資料中心的相同伺服器上，以協助確保從單一分割區擷取資料的查詢可以快速執行。</span><span class="sxs-lookup"><span data-stu-id="c38bc-187">Each partition is stored on the same server in an Azure datacenter to help ensure that queries that retrieve data from a single partition run quickly.</span></span>

<span data-ttu-id="c38bc-188">Microsoft 已發佈 Azure 儲存體帳戶的[延展性目標]。</span><span class="sxs-lookup"><span data-stu-id="c38bc-188">Microsoft has published [scalability targets] for Azure Storage.</span></span> <span data-ttu-id="c38bc-189">如果您的系統可能會超出這些限制，請考慮將實體劃分成多個資料表。</span><span class="sxs-lookup"><span data-stu-id="c38bc-189">If your system is likely to exceed these limits, consider splitting entities into multiple tables.</span></span> <span data-ttu-id="c38bc-190">使用垂直資料分割，將欄位區分成最有可能一起存取的群組。</span><span class="sxs-lookup"><span data-stu-id="c38bc-190">Use vertical partitioning to divide the fields into the groups that are most likely to be accessed together.</span></span>

<span data-ttu-id="c38bc-191">下圖顯示範例儲存體帳戶的邏輯結構。</span><span class="sxs-lookup"><span data-stu-id="c38bc-191">The following diagram shows the logical structure of an example storage account.</span></span> <span data-ttu-id="c38bc-192">儲存體帳戶包含三個資料表：Customer Info、Product Info 和 Order Info。</span><span class="sxs-lookup"><span data-stu-id="c38bc-192">The storage account contains three tables: Customer Info, Product Info, and Order Info.</span></span>

![範例儲存體帳戶中的表格和分割區](./images/data-partitioning/TableStorage.png)

<span data-ttu-id="c38bc-194">每個資料表有多個分割區。</span><span class="sxs-lookup"><span data-stu-id="c38bc-194">Each table has multiple partitions.</span></span>

- <span data-ttu-id="c38bc-195">在 Customer Info 資料表中，資料是依據客戶所在的城市進行分割。</span><span class="sxs-lookup"><span data-stu-id="c38bc-195">In the Customer Info table, the data is partitioned according to the city where the customer is located.</span></span> <span data-ttu-id="c38bc-196">資料列索引鍵包含客戶識別碼。</span><span class="sxs-lookup"><span data-stu-id="c38bc-196">The row key contains the customer ID.</span></span>
- <span data-ttu-id="c38bc-197">在 Product Info 資料表中，產品是依據產品類別進行分割，而資料列索引鍵包含產品號碼。</span><span class="sxs-lookup"><span data-stu-id="c38bc-197">In the Product Info table, products are partitioned by product category, and the row key contains the product number.</span></span>
- <span data-ttu-id="c38bc-198">在 Order Info 資料表中，訂單是依據訂單日期進行分割，而資料列索引鍵會指定收到訂單的時間。</span><span class="sxs-lookup"><span data-stu-id="c38bc-198">In the Order Info table, the orders are partitioned by order date, and the row key specifies the time the order was received.</span></span> <span data-ttu-id="c38bc-199">請注意，所有資料都會依據資料列索引鍵在每個分割區中排序。</span><span class="sxs-lookup"><span data-stu-id="c38bc-199">Note that all data is ordered by the row key in each partition.</span></span>

<span data-ttu-id="c38bc-200">當您設計 Azure 表格儲存體的實體時，請考慮下列幾點：</span><span class="sxs-lookup"><span data-stu-id="c38bc-200">Consider the following points when you design your entities for Azure table storage:</span></span>

- <span data-ttu-id="c38bc-201">依據資料的存取方式來選取資料分割索引鍵和資料列索引鍵。</span><span class="sxs-lookup"><span data-stu-id="c38bc-201">Select a partition key and row key by how the data is accessed.</span></span> <span data-ttu-id="c38bc-202">請選擇分割區索引鍵/資料列索引鍵組合，以支援大多數的查詢。</span><span class="sxs-lookup"><span data-stu-id="c38bc-202">Choose a partition key/row key combination that supports the majority of your queries.</span></span> <span data-ttu-id="c38bc-203">最有效率的查詢會藉由指定分割區索引鍵和資料列索引鍵來擷取資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-203">The most efficient queries retrieve data by specifying the partition key and the row key.</span></span> <span data-ttu-id="c38bc-204">掃描單一分割區，即可完成指定分割區索引鍵和資料列索引鍵範圍的查詢。</span><span class="sxs-lookup"><span data-stu-id="c38bc-204">Queries that specify a partition key and a range of row keys can be completed by scanning a single partition.</span></span> <span data-ttu-id="c38bc-205">這是相對快速的方法，因為資料會以資料列索引鍵的順序保留。</span><span class="sxs-lookup"><span data-stu-id="c38bc-205">This is relatively fast because the data is held in row key order.</span></span> <span data-ttu-id="c38bc-206">如果查詢未指定要掃描哪個分割區，就必須掃描每個分割區。</span><span class="sxs-lookup"><span data-stu-id="c38bc-206">If queries don't specify which partition to scan, every partition must be scanned.</span></span>

- <span data-ttu-id="c38bc-207">如果實體有一個自然索引鍵，則使用它做為資料分割索引鍵，並指定空白字串做為資料列索引鍵。</span><span class="sxs-lookup"><span data-stu-id="c38bc-207">If an entity has one natural key, then use it as the partition key and specify an empty string as the row key.</span></span> <span data-ttu-id="c38bc-208">如果實體具有包含兩個屬性的複合索引鍵，選取最慢的變更中屬性作為資料分割索引鍵，另一個則作為資料列索引鍵。</span><span class="sxs-lookup"><span data-stu-id="c38bc-208">If an entity has a composite key consisting of two properties, select the slowest changing property as the partition key and the other as the row key.</span></span> <span data-ttu-id="c38bc-209">如果實體有兩個以上的索引鍵屬性，使用屬性的串連來提供資料分割和資料列索引鍵。</span><span class="sxs-lookup"><span data-stu-id="c38bc-209">If an entity has more than two key properties, use a concatenation of properties to provide the partition and row keys.</span></span>

- <span data-ttu-id="c38bc-210">如果您使用分割區和資料列索引鍵以外的欄位定期執行查閱資料的查詢，請考慮實作[索引資料表模式](../patterns/index-table.md)，或考慮使用支援索引的不同資料存放區，例如 Cosmos DB。</span><span class="sxs-lookup"><span data-stu-id="c38bc-210">If you regularly perform queries that look up data by using fields other than the partition and row keys, consider implementing the [Index Table pattern](../patterns/index-table.md), or consider using a different data store that supports indexing, such as Cosmos DB.</span></span>

- <span data-ttu-id="c38bc-211">如果您使用單純數列 (例如 "0001"、"0002"、"0003") 來產生分割區索引鍵，而每個分割區只包含有限的資料數量，那麼 Azure 資料表儲存體會在同一部伺服器上將這些分割區實際群組在一起。</span><span class="sxs-lookup"><span data-stu-id="c38bc-211">If you generate partition keys by using a monotonic sequence (such as "0001", "0002", "0003") and each partition only contains a limited amount of data, Azure table storage can physically group these partitions together on the same server.</span></span> <span data-ttu-id="c38bc-212">Azure 儲存體假設應用程式很有可能在連續範圍的分割區中執行查詢 (範圍查詢)，並已針對此情況進行最佳化。</span><span class="sxs-lookup"><span data-stu-id="c38bc-212">Azure Storage assumes that the application is most likely to perform queries across a contiguous range of partitions (range queries) and is optimized for this case.</span></span> <span data-ttu-id="c38bc-213">不過，這種方法會導致作用點，因為新實體的所有插入可能都會集中在連續範圍的其中一端。</span><span class="sxs-lookup"><span data-stu-id="c38bc-213">However, this approach can lead to hotspots, because all insertions of new entities are likely to be concentrated at one end the contiguous range.</span></span> <span data-ttu-id="c38bc-214">它也會降低延展性。</span><span class="sxs-lookup"><span data-stu-id="c38bc-214">It can also reduce scalability.</span></span> <span data-ttu-id="c38bc-215">若要更平均地分散負載，請考慮針對資料分割索引鍵進行雜湊。</span><span class="sxs-lookup"><span data-stu-id="c38bc-215">To spread the load more evenly, consider hashing the partition key.</span></span>

- <span data-ttu-id="c38bc-216">Azure 資料表儲存體支援屬於相同分割區之實體的交易式作業。</span><span class="sxs-lookup"><span data-stu-id="c38bc-216">Azure table storage supports transactional operations for entities that belong to the same partition.</span></span> <span data-ttu-id="c38bc-217">應用程式可以執行多個插入、更新、刪除、取代或合併作業作為不可部分完成的單位，前提是交易未包含 100 個以上的實體，且要求的承載大小未超過 4 MB。</span><span class="sxs-lookup"><span data-stu-id="c38bc-217">An application can perform multiple insert, update, delete, replace, or merge operations as an atomic unit, as long as the transaction doesn't include more than 100 entities and the payload of the request doesn't exceed 4 MB.</span></span> <span data-ttu-id="c38bc-218">跨越多個分割區的作業不是交易式，而且可能需要您實作最終一致性。</span><span class="sxs-lookup"><span data-stu-id="c38bc-218">Operations that span multiple partitions are not transactional, and might require you to implement eventual consistency.</span></span> <span data-ttu-id="c38bc-219">如需有關資料表儲存空間和交易的詳細資訊，請參閱[執行實體群組交易]。</span><span class="sxs-lookup"><span data-stu-id="c38bc-219">For more information about table storage and transactions, see [Performing entity group transactions].</span></span>

- <span data-ttu-id="c38bc-220">請考慮資料分割索引鍵的細微性：</span><span class="sxs-lookup"><span data-stu-id="c38bc-220">Consider the granularity of the partition key:</span></span>

  - <span data-ttu-id="c38bc-221">針對保留在一個伺服器上之單一分割區中的每個實體結果，使用相同的分割區索引鍵。</span><span class="sxs-lookup"><span data-stu-id="c38bc-221">Using the same partition key for every entity results in a single partition that's held on one server.</span></span> <span data-ttu-id="c38bc-222">這可防止分割區相應放大，並且將焦點放在單一伺服器上的負載。</span><span class="sxs-lookup"><span data-stu-id="c38bc-222">This prevents the partition from scaling out and focuses the load on a single server.</span></span> <span data-ttu-id="c38bc-223">如此一來，這個方法只適用於儲存少數實體。</span><span class="sxs-lookup"><span data-stu-id="c38bc-223">As a result, this approach is only suitable for storing a small number of entities.</span></span> <span data-ttu-id="c38bc-224">不過，這個方法確實能確保所有實體都可以參與實體群組交易。</span><span class="sxs-lookup"><span data-stu-id="c38bc-224">However, it does ensure that all entities can participate in entity group transactions.</span></span>

  - <span data-ttu-id="c38bc-225">對每個實體使用唯一的分割區索引鍵，會導致表格儲存體服務為每個實體建立個別的分割區，可能會產生大量的小型分割區。</span><span class="sxs-lookup"><span data-stu-id="c38bc-225">Using a unique partition key for every entity causes the table storage service to create a separate partition for each entity, possibly resulting in a large number of small partitions.</span></span> <span data-ttu-id="c38bc-226">比起使用單一分割區索引鍵，這種方法具更大的可調整性，但無法進行實體群組交易，</span><span class="sxs-lookup"><span data-stu-id="c38bc-226">This approach is more scalable than using a single partition key, but entity group transactions are not possible.</span></span> <span data-ttu-id="c38bc-227">此外，擷取多個實體的查詢可能牽涉到讀取多部伺服器。</span><span class="sxs-lookup"><span data-stu-id="c38bc-227">Also, queries that fetch more than one entity might involve reading from more than one server.</span></span> <span data-ttu-id="c38bc-228">不過，如果應用程式執行範圍查詢，針對分割區索引鍵使用單純的數列可能有助於最佳化這些查詢。</span><span class="sxs-lookup"><span data-stu-id="c38bc-228">However, if the application performs range queries, then using a monotonic sequence for the partition keys might help to optimize these queries.</span></span>

  - <span data-ttu-id="c38bc-229">跨實體的子集共用資料分割區索引鍵，能夠將相同分割區中的相關實體分組。</span><span class="sxs-lookup"><span data-stu-id="c38bc-229">Sharing the partition key across a subset of entities makes it possible to group related entities in the same partition.</span></span> <span data-ttu-id="c38bc-230">涉及可使用實體群組交易執行之相關實體的作業，以及擷取一組相關實體的查詢，可藉由存取單一伺服器來滿足。</span><span class="sxs-lookup"><span data-stu-id="c38bc-230">Operations that involve related entities can be performed by using entity group transactions, and queries that fetch a set of related entities can be satisfied by accessing a single server.</span></span>

<span data-ttu-id="c38bc-231">如需詳細資料，請參閱 [Azure 儲存體資料表設計指南]。</span><span class="sxs-lookup"><span data-stu-id="c38bc-231">For more information, see [Azure storage table design guide].</span></span>

## <a name="partitioning-azure-blob-storage"></a><span data-ttu-id="c38bc-232">分割 Azure blob 儲存體</span><span class="sxs-lookup"><span data-stu-id="c38bc-232">Partitioning Azure blob storage</span></span>

<span data-ttu-id="c38bc-233">Azure Blob 儲存體可以保留大型二進位物件。</span><span class="sxs-lookup"><span data-stu-id="c38bc-233">Azure blob storage makes it possible to hold large binary objects.</span></span> <span data-ttu-id="c38bc-234">在您必須快速上傳或下載大量資料的案例中使用區塊 Blob。</span><span class="sxs-lookup"><span data-stu-id="c38bc-234">Use block blobs in scenarios when you need to upload or download large volumes of data quickly.</span></span> <span data-ttu-id="c38bc-235">對需要隨機而不是序列存取部分資料的應用程式使用分頁 blob。</span><span class="sxs-lookup"><span data-stu-id="c38bc-235">Use page blobs for applications that require random rather than serial access to parts of the data.</span></span>

<span data-ttu-id="c38bc-236">每個 blob (區塊或分頁) 會保留在 Azure 儲存體帳戶中的容器中。</span><span class="sxs-lookup"><span data-stu-id="c38bc-236">Each blob (either block or page) is held in a container in an Azure storage account.</span></span> <span data-ttu-id="c38bc-237">您可以使用容器來將具有相同安全性需求的相關 blob 群組在一起。</span><span class="sxs-lookup"><span data-stu-id="c38bc-237">You can use containers to group related blobs that have the same security requirements.</span></span> <span data-ttu-id="c38bc-238">這是邏輯性的群組，而非實體的。</span><span class="sxs-lookup"><span data-stu-id="c38bc-238">This grouping is logical rather than physical.</span></span> <span data-ttu-id="c38bc-239">在容器內，每個 Blob 都有唯一的名稱。</span><span class="sxs-lookup"><span data-stu-id="c38bc-239">Inside a container, each blob has a unique name.</span></span>

<span data-ttu-id="c38bc-240">blob 的分割索引鍵為帳戶名稱 + 容器名稱 + blob 名稱。</span><span class="sxs-lookup"><span data-stu-id="c38bc-240">The partition key for a blob is account name + container name + blob name.</span></span> <span data-ttu-id="c38bc-241">分割區索引鍵是用來將資料分割成數個範圍，這些範圍在整個系統都是負載平衡的。</span><span class="sxs-lookup"><span data-stu-id="c38bc-241">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="c38bc-242">Blob 可以分散到多部伺服器，以相應放大對它們的存取，但是單一伺服器只能服務單一 Blob。</span><span class="sxs-lookup"><span data-stu-id="c38bc-242">Blobs can be distributed across many servers in order to scale out access to them, but a single blob can only be served by a single server.</span></span>

<span data-ttu-id="c38bc-243">如果您的命名配置使用時間戳記或數字識別碼，可能會導致過多流量前往單一分割區，限制系統無法有效進行負載平衡。</span><span class="sxs-lookup"><span data-stu-id="c38bc-243">If your naming scheme uses timestamps or numerical identifiers, it can lead to excessive traffic going to one partition, limiting the system from effectively load balancing.</span></span> <span data-ttu-id="c38bc-244">例如，如果日常作業使用有時間戳記的 Blob 物件，如 yyyy-mm-dd，則該作業的所有流量都會前往單一分割區伺服器。</span><span class="sxs-lookup"><span data-stu-id="c38bc-244">For instance, if you have daily operations that use a blob object with a timestamp such as *yyyy-mm-dd*, all the traffic for that operation would go to a single partition server.</span></span> <span data-ttu-id="c38bc-245">相反地，請考慮在名稱前面加上 3 位數雜湊。</span><span class="sxs-lookup"><span data-stu-id="c38bc-245">Instead, consider prefixing the name with a 3-digit hash.</span></span> <span data-ttu-id="c38bc-246">如需詳細資訊，請參閱[資料分割命名慣例](/azure/storage/common/storage-performance-checklist#subheading47)</span><span class="sxs-lookup"><span data-stu-id="c38bc-246">For more information, see [Partition Naming Convention](/azure/storage/common/storage-performance-checklist#subheading47)</span></span>

<span data-ttu-id="c38bc-247">寫入單一區塊或分頁的動作是不可部分完成的，但跨越區塊、分頁或 Blob 的作業卻不是。</span><span class="sxs-lookup"><span data-stu-id="c38bc-247">The actions of writing a single block or page are atomic, but operations that span blocks, pages, or blobs are not.</span></span> <span data-ttu-id="c38bc-248">如果您必須在跨區塊、分頁和 Blob 執行寫入作業時確保一致性，請使用 Blob 租用來執行寫入鎖定。</span><span class="sxs-lookup"><span data-stu-id="c38bc-248">If you need to ensure consistency when performing write operations across blocks, pages, and blobs, take out a write lock by using a blob lease.</span></span>

## <a name="partitioning-azure-storage-queues"></a><span data-ttu-id="c38bc-249">分割 Azure 儲存體佇列</span><span class="sxs-lookup"><span data-stu-id="c38bc-249">Partitioning Azure storage queues</span></span>

<span data-ttu-id="c38bc-250">Azure 儲存體佇列可讓您實作程序之間的非同步傳訊。</span><span class="sxs-lookup"><span data-stu-id="c38bc-250">Azure storage queues enable you to implement asynchronous messaging between processes.</span></span> <span data-ttu-id="c38bc-251">Azure 儲存體帳戶可以包含任意數目的佇列，而每個佇列可以包含任意數目的訊息。</span><span class="sxs-lookup"><span data-stu-id="c38bc-251">An Azure storage account can contain any number of queues, and each queue can contain any number of messages.</span></span> <span data-ttu-id="c38bc-252">唯一的限制是儲存體帳戶中的可用空間。</span><span class="sxs-lookup"><span data-stu-id="c38bc-252">The only limitation is the space that's available in the storage account.</span></span> <span data-ttu-id="c38bc-253">個別訊息的大小上限是 64 KB。</span><span class="sxs-lookup"><span data-stu-id="c38bc-253">The maximum size of an individual message is 64 KB.</span></span> <span data-ttu-id="c38bc-254">如果您需要比這個限制更大的訊息，請考慮改用 Azure 服務匯流排佇列。</span><span class="sxs-lookup"><span data-stu-id="c38bc-254">If you require messages bigger than this, then consider using Azure Service Bus queues instead.</span></span>

<span data-ttu-id="c38bc-255">每個儲存體佇列在其所屬的儲存體帳戶內都有唯一的名稱。</span><span class="sxs-lookup"><span data-stu-id="c38bc-255">Each storage queue has a unique name within the storage account that contains it.</span></span> <span data-ttu-id="c38bc-256">Azure 會根據名稱分割佇列。</span><span class="sxs-lookup"><span data-stu-id="c38bc-256">Azure partitions queues based on the name.</span></span> <span data-ttu-id="c38bc-257">同一個佇列的所有訊息都會儲存在相同的分割區中，由單一伺服器所控制。</span><span class="sxs-lookup"><span data-stu-id="c38bc-257">All messages for the same queue are stored in the same partition, which is controlled by a single server.</span></span> <span data-ttu-id="c38bc-258">不同的佇列可以由不同的伺服器管理，以協助平衡負載。</span><span class="sxs-lookup"><span data-stu-id="c38bc-258">Different queues can be managed by different servers to help balance the load.</span></span> <span data-ttu-id="c38bc-259">伺服器的佇列配置對應用程式和使用者而言是透明的。</span><span class="sxs-lookup"><span data-stu-id="c38bc-259">The allocation of queues to servers is transparent to applications and users.</span></span>

<span data-ttu-id="c38bc-260">在大型應用程式中，請勿將相同的儲存體佇列用於應用程式的所有執行個體，因為這種方法可能會使裝載佇列的伺服器變成作用點。</span><span class="sxs-lookup"><span data-stu-id="c38bc-260">In a large-scale application, don't use the same storage queue for all instances of the application because this approach might cause the server that's hosting the queue to become a hotspot.</span></span> <span data-ttu-id="c38bc-261">請改為針對應用程式的不同功能區域使用不同的佇列。</span><span class="sxs-lookup"><span data-stu-id="c38bc-261">Instead, use different queues for different functional areas of the application.</span></span> <span data-ttu-id="c38bc-262">Azure 儲存體佇列不支援交易，因此將訊息導向到不同的佇列，則應該有太大的影響，對傳訊一致性。</span><span class="sxs-lookup"><span data-stu-id="c38bc-262">Azure storage queues do not support transactions, so directing messages to different queues should have little effect on messaging consistency.</span></span>

<span data-ttu-id="c38bc-263">Azure 儲存體佇列每秒可處理高達 2,000 個訊息。</span><span class="sxs-lookup"><span data-stu-id="c38bc-263">An Azure storage queue can handle up to 2,000 messages per second.</span></span> <span data-ttu-id="c38bc-264">如果您必須以更高的速率處理訊息，請考慮建立多個佇列。</span><span class="sxs-lookup"><span data-stu-id="c38bc-264">If you need to process messages at a greater rate than this, consider creating multiple queues.</span></span> <span data-ttu-id="c38bc-265">例如，在全域應用程式的個別儲存體帳戶中建立個別儲存體佇列，以處理在每個區域中執行的應用程式執行個體。</span><span class="sxs-lookup"><span data-stu-id="c38bc-265">For example, in a global application, create separate storage queues in separate storage accounts to handle application instances that are running in each region.</span></span>

## <a name="partitioning-azure-service-bus"></a><span data-ttu-id="c38bc-266">資料分割 Azure 服務匯流排</span><span class="sxs-lookup"><span data-stu-id="c38bc-266">Partitioning Azure Service Bus</span></span>

<span data-ttu-id="c38bc-267">Azure 服務匯流排使用訊息代理程式，來處理傳送至服務匯流排佇列或主題的訊息。</span><span class="sxs-lookup"><span data-stu-id="c38bc-267">Azure Service Bus uses a message broker to handle messages that are sent to a Service Bus queue or topic.</span></span> <span data-ttu-id="c38bc-268">根據預設，所有傳送至佇列或主題的訊息都是由相同的訊息代理程式程序來處理。</span><span class="sxs-lookup"><span data-stu-id="c38bc-268">By default, all messages that are sent to a queue or topic are handled by the same message broker process.</span></span> <span data-ttu-id="c38bc-269">此架構可限制訊息佇列的整體輸送量。</span><span class="sxs-lookup"><span data-stu-id="c38bc-269">This architecture can place a limitation on the overall throughput of the message queue.</span></span> <span data-ttu-id="c38bc-270">不過，您也可以在建立佇列或主題時進行分割。</span><span class="sxs-lookup"><span data-stu-id="c38bc-270">However, you can also partition a queue or topic when it is created.</span></span> <span data-ttu-id="c38bc-271">您可以將佇列或主題描述的 EnablePartitioning 屬性設定為 true，藉以進行分割。</span><span class="sxs-lookup"><span data-stu-id="c38bc-271">You do this by setting the *EnablePartitioning* property of the queue or topic description to *true*.</span></span>

<span data-ttu-id="c38bc-272">分割的佇列或主題會區分成多個片段，每個片段都會受到個別訊息存放區和訊息代理程式所支援。</span><span class="sxs-lookup"><span data-stu-id="c38bc-272">A partitioned queue or topic is divided into multiple fragments, each of which is backed by a separate message store and message broker.</span></span> <span data-ttu-id="c38bc-273">服務匯流排會負責建立和管理這些片段。</span><span class="sxs-lookup"><span data-stu-id="c38bc-273">Service Bus takes responsibility for creating and managing these fragments.</span></span> <span data-ttu-id="c38bc-274">當應用程式張貼訊息至分割的佇列或主題時，服務匯流排會將訊息指派給該佇列或主題的片段。</span><span class="sxs-lookup"><span data-stu-id="c38bc-274">When an application posts a message to a partitioned queue or topic, Service Bus assigns the message to a fragment for that queue or topic.</span></span> <span data-ttu-id="c38bc-275">當應用程式從佇列或訂用帳戶接收到訊息時，服務匯流排會檢查每個片段是否有下一個可用的訊息，然後將它傳遞給應用程式進行處理。</span><span class="sxs-lookup"><span data-stu-id="c38bc-275">When an application receives a message from a queue or subscription, Service Bus checks each fragment for the next available message and then passes it to the application for processing.</span></span>

<span data-ttu-id="c38bc-276">這種結構有助於跨訊息代理程式和訊息存放區分佈負載，提高延展性並改善可用性。</span><span class="sxs-lookup"><span data-stu-id="c38bc-276">This structure helps distribute the load across message brokers and message stores, increasing scalability and improving availability.</span></span> <span data-ttu-id="c38bc-277">如果有一個片段的訊息代理程式或訊息存放區暫時無法使用，服務匯流排可以從其中一個剩餘的可用片段擷取訊息。</span><span class="sxs-lookup"><span data-stu-id="c38bc-277">If the message broker or message store for one fragment is temporarily unavailable, Service Bus can retrieve messages from one of the remaining available fragments.</span></span>

<span data-ttu-id="c38bc-278">服務匯流排會指派訊息給片段，如下所示：</span><span class="sxs-lookup"><span data-stu-id="c38bc-278">Service Bus assigns a message to a fragment as follows:</span></span>

- <span data-ttu-id="c38bc-279">如果訊息屬於工作階段，所有具有 *SessionId* 屬性之相同值的訊息都會傳送至相同片段。</span><span class="sxs-lookup"><span data-stu-id="c38bc-279">If the message belongs to a session, all messages with the same value for the *SessionId*  property are sent to the same fragment.</span></span>

- <span data-ttu-id="c38bc-280">如果訊息不屬於工作階段，但寄件者已指定 PartitionKey 屬性的值，則具有相同 PartitionKey 值的所有訊息都會傳送至相同的片段。</span><span class="sxs-lookup"><span data-stu-id="c38bc-280">If the message does not belong to a session, but the sender has specified a value for the *PartitionKey* property, then all messages with the same *PartitionKey* value are sent to the same fragment.</span></span>

  > [!NOTE]
  > <span data-ttu-id="c38bc-281">如果同時指定 SessionId 和 PartitionKey 屬性，則必須將它們設為相同的值，否則訊息將會遭到拒絕。</span><span class="sxs-lookup"><span data-stu-id="c38bc-281">If the *SessionId* and *PartitionKey* properties are both specified, then they must be set to the same value or the message will be rejected.</span></span>

- <span data-ttu-id="c38bc-282">如果未指定訊息的 SessionId 和 PartitionKey 屬性，但已啟用重複偵測，就會使用 MessageId 屬性。</span><span class="sxs-lookup"><span data-stu-id="c38bc-282">If the *SessionId* and *PartitionKey* properties for a message are not specified, but duplicate detection is enabled, the *MessageId* property will be used.</span></span> <span data-ttu-id="c38bc-283">具有相同 MessageId 的所有訊息會導向至相同的片段。</span><span class="sxs-lookup"><span data-stu-id="c38bc-283">All messages with the same *MessageId* will be directed to the same fragment.</span></span>

- <span data-ttu-id="c38bc-284">如果訊息不包含 SessionId、PartitionKey 或 MessageId 屬性，則服務匯流排會循序將訊息指派給片段。</span><span class="sxs-lookup"><span data-stu-id="c38bc-284">If messages do not include a *SessionId, PartitionKey,* or *MessageId* property, then Service Bus assigns messages to fragments sequentially.</span></span> <span data-ttu-id="c38bc-285">如果片段無法使用，服務匯流排會移至下一個片段。</span><span class="sxs-lookup"><span data-stu-id="c38bc-285">If a fragment is unavailable, Service Bus will move on to the next.</span></span> <span data-ttu-id="c38bc-286">這表示，傳訊基礎結構中的暫時性錯誤不會造成訊息傳送作業失敗。</span><span class="sxs-lookup"><span data-stu-id="c38bc-286">This means that a temporary fault in the messaging infrastructure does not cause the message-send operation to fail.</span></span>

<span data-ttu-id="c38bc-287">在決定是否或如何分割服務匯流排訊息佇列或主題時，請考慮下列幾點：</span><span class="sxs-lookup"><span data-stu-id="c38bc-287">Consider the following points when deciding if or how to partition a Service Bus message queue or topic:</span></span>

- <span data-ttu-id="c38bc-288">服務匯流排佇列和主題都會在服務匯流排命名空間的範圍內建立。</span><span class="sxs-lookup"><span data-stu-id="c38bc-288">Service Bus queues and topics are created within the scope of a Service Bus namespace.</span></span> <span data-ttu-id="c38bc-289">服务总线当前允许为每个命名空间最多创建 100 个分区的队列或主题。</span><span class="sxs-lookup"><span data-stu-id="c38bc-289">Service Bus currently allows up to 100 partitioned queues or topics per namespace.</span></span>

- <span data-ttu-id="c38bc-290">每個服務匯流排命名空間都會制定可用資源的配額，例如，每個主題的訂用帳戶數目、每秒同時傳送和接收要求的數目，以及可建立之並行連接的最大數目。</span><span class="sxs-lookup"><span data-stu-id="c38bc-290">Each Service Bus namespace imposes quotas on the available resources, such as the number of subscriptions per topic, the number of concurrent send and receive requests per second, and the maximum number of concurrent connections that can be established.</span></span> <span data-ttu-id="c38bc-291">這些配額如[服務匯流排配額]中所述。</span><span class="sxs-lookup"><span data-stu-id="c38bc-291">These quotas are documented in [Service Bus quotas].</span></span> <span data-ttu-id="c38bc-292">如果您預期超過這些值，請建立其他具有佇列和主題的命名空間，並跨這些命名空間分佈工作。</span><span class="sxs-lookup"><span data-stu-id="c38bc-292">If you expect to exceed these values, then create additional namespaces with their own queues and topics, and spread the work across these namespaces.</span></span> <span data-ttu-id="c38bc-293">例如，在全域應用程式中的每個區域建立不同的命名空間，並設定應用程式執行個體使用最接近命名空間中的佇列和主題。</span><span class="sxs-lookup"><span data-stu-id="c38bc-293">For example, in a global application, create separate namespaces in each region and configure application instances to use the queues and topics in the nearest namespace.</span></span>

- <span data-ttu-id="c38bc-294">傳送做為交易一部分的訊息必須指定資料分割索引鍵。</span><span class="sxs-lookup"><span data-stu-id="c38bc-294">Messages that are sent as part of a transaction must specify a partition key.</span></span> <span data-ttu-id="c38bc-295">這可以是 SessionId、PartitionKey 或 MessageId 屬性。</span><span class="sxs-lookup"><span data-stu-id="c38bc-295">This can be a *SessionId*, *PartitionKey*, or *MessageId* property.</span></span> <span data-ttu-id="c38bc-296">傳送做為相同交易一部分的所有訊息必須指定相同的資料分割索引鍵，因為它們必須由相同的訊息代理程式程序加以處理。</span><span class="sxs-lookup"><span data-stu-id="c38bc-296">All messages that are sent as part of the same transaction must specify the same partition key because they must be handled by the same message broker process.</span></span> <span data-ttu-id="c38bc-297">您無法在相同的交易內傳送訊息至不同的佇列或主題。</span><span class="sxs-lookup"><span data-stu-id="c38bc-297">You cannot send messages to different queues or topics within the same transaction.</span></span>

- <span data-ttu-id="c38bc-298">無法將分割的佇列或主題設定為在其變成閒置狀態時自動刪除。</span><span class="sxs-lookup"><span data-stu-id="c38bc-298">Partitioned queues and topics can't be configured to be automatically deleted when they become idle.</span></span>

- <span data-ttu-id="c38bc-299">如果您正在建置跨平台或混合式解決方案，目前無法將分割的佇列和主題與進階訊息佇列通訊協定 (AMQP) 搭配使用。</span><span class="sxs-lookup"><span data-stu-id="c38bc-299">Partitioned queues and topics can't currently be used with the Advanced Message Queuing Protocol (AMQP) if you are building cross-platform or hybrid solutions.</span></span>

## <a name="partitioning-cosmos-db"></a><span data-ttu-id="c38bc-300">資料分割 Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="c38bc-300">Partitioning Cosmos DB</span></span>

<span data-ttu-id="c38bc-301">Azure Cosmos DB 是一種可以使用 [Azure Cosmos DB SQL API][cosmosdb-sql-api] 儲存 JSON 文件的 NoSQL 資料庫。</span><span class="sxs-lookup"><span data-stu-id="c38bc-301">Azure Cosmos DB is a NoSQL database that can store JSON documents using the [Azure Cosmos DB SQL API][cosmosdb-sql-api].</span></span> <span data-ttu-id="c38bc-302">Cosmos DB 資料庫中的文件是物件或其他資料片段的 JSON 序列化表示。</span><span class="sxs-lookup"><span data-stu-id="c38bc-302">A document in a Cosmos DB database is a JSON-serialized representation of an object or other piece of data.</span></span> <span data-ttu-id="c38bc-303">沒有固定的結構描述會強制執行，但是每個文件都必須包含唯一識別碼。</span><span class="sxs-lookup"><span data-stu-id="c38bc-303">No fixed schemas are enforced except that every document must contain a unique ID.</span></span>

<span data-ttu-id="c38bc-304">文件會組織成集合。</span><span class="sxs-lookup"><span data-stu-id="c38bc-304">Documents are organized into collections.</span></span> <span data-ttu-id="c38bc-305">您可以將相關文件一起群組於一個集合中。</span><span class="sxs-lookup"><span data-stu-id="c38bc-305">You can group related documents together in a collection.</span></span> <span data-ttu-id="c38bc-306">例如，在維護部落格文章的系統中，您可以將每篇部落格文章的內容儲存為集合中的文件。</span><span class="sxs-lookup"><span data-stu-id="c38bc-306">For example, in a system that maintains blog postings, you can store the contents of each blog post as a document in a collection.</span></span> <span data-ttu-id="c38bc-307">您也可以為每個主體類型建立集合。</span><span class="sxs-lookup"><span data-stu-id="c38bc-307">You can also create collections for each subject type.</span></span> <span data-ttu-id="c38bc-308">或者，在多租用戶應用程式中 (例如，不同的作者可以控制和管理自己部落格文章的系統)，您可以根據作者分割部落格，並為每位作者建立個別的集合。</span><span class="sxs-lookup"><span data-stu-id="c38bc-308">Alternatively, in a multitenant application, such as a system where different authors control and manage their own blog posts, you can partition blogs by author and create separate collections for each author.</span></span> <span data-ttu-id="c38bc-309">配置給集合的儲存體空間非常有彈性，而且可以依需要縮小或成長。</span><span class="sxs-lookup"><span data-stu-id="c38bc-309">The storage space that's allocated to collections is elastic and can shrink or grow as needed.</span></span>

<span data-ttu-id="c38bc-310">根據由應用程式定義的分割索引鍵，Cosmos DB 支援自動資料分割。</span><span class="sxs-lookup"><span data-stu-id="c38bc-310">Cosmos DB supports automatic partitioning of data based on an application-defined partition key.</span></span> <span data-ttu-id="c38bc-311">邏輯分割是一種資料分割，會儲存單一資料分割索引鍵值的所有資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-311">A *logical partition* is a partition that stores all the data for a single partition key value.</span></span> <span data-ttu-id="c38bc-312">共用相同分割索引鍵值的所有文件都位於相同的邏輯分割中。</span><span class="sxs-lookup"><span data-stu-id="c38bc-312">All documents that share the same value for the partition key are placed within the same logical partition.</span></span> <span data-ttu-id="c38bc-313">Cosmos DB 會根據分割索引鍵的雜湊碼來散發值。</span><span class="sxs-lookup"><span data-stu-id="c38bc-313">Cosmos DB distributes values according to hash of the partition key.</span></span> <span data-ttu-id="c38bc-314">邏輯分割的大小上限為 10 GB。</span><span class="sxs-lookup"><span data-stu-id="c38bc-314">A logical partition has a maximum size of 10 GB.</span></span> <span data-ttu-id="c38bc-315">因此，選擇分割索引鍵是在設計階段的一項重要決策。</span><span class="sxs-lookup"><span data-stu-id="c38bc-315">Therefore, the choice of the partition key is an important decision at design time.</span></span> <span data-ttu-id="c38bc-316">選擇具有各種不同的值並且有平均存取模式的屬性。</span><span class="sxs-lookup"><span data-stu-id="c38bc-316">Choose a property with a wide range of values and even access patterns.</span></span> <span data-ttu-id="c38bc-317">如需詳細資訊，請參閱 [Azure Cosmos DB 中的分割和調整](/azure/cosmos-db/partition-data)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-317">For more information, see [Partition and scale in Azure Cosmos DB](/azure/cosmos-db/partition-data).</span></span>

> [!NOTE]
> <span data-ttu-id="c38bc-318">每個 Cosmos DB 資料庫都有「效能層級」來決定它取得的資源數量。</span><span class="sxs-lookup"><span data-stu-id="c38bc-318">Each Cosmos DB database has a *performance level* that determines the amount of resources it gets.</span></span> <span data-ttu-id="c38bc-319">每個效能層級都會與「要求單位」(RU) 速率限制相關聯。</span><span class="sxs-lookup"><span data-stu-id="c38bc-319">A performance level is associated with a *request unit* (RU) rate limit.</span></span> <span data-ttu-id="c38bc-320">RU 速率限制會指定要保留且可供該集合獨佔使用的資源量。</span><span class="sxs-lookup"><span data-stu-id="c38bc-320">The RU rate limit specifies the volume of resources that's reserved and available for exclusive use by that collection.</span></span> <span data-ttu-id="c38bc-321">集合的成本取決於為該集合選取的效能層級。</span><span class="sxs-lookup"><span data-stu-id="c38bc-321">The cost of a collection depends on the performance level that's selected for that collection.</span></span> <span data-ttu-id="c38bc-322">效能層級 (和 RU 速率限制) 愈高，費用也愈高。</span><span class="sxs-lookup"><span data-stu-id="c38bc-322">The higher the performance level (and RU rate limit) the higher the charge.</span></span> <span data-ttu-id="c38bc-323">您可以使用 Azure 入口網站來調整集合的效能層級。</span><span class="sxs-lookup"><span data-stu-id="c38bc-323">You can adjust the performance level of a collection by using the Azure portal.</span></span> <span data-ttu-id="c38bc-324">如需詳細資訊，請參閱 [Azure Cosmos DB 中的要求單位][cosmos-db-ru]。</span><span class="sxs-lookup"><span data-stu-id="c38bc-324">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span>

<span data-ttu-id="c38bc-325">如果 Cosmos DB 提供的分割機制不足夠，您可能需要在應用程式層級分區資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-325">If the partitioning mechanism that Cosmos DB provides is not sufficient, you may need to shard the data at the application level.</span></span> <span data-ttu-id="c38bc-326">文件集合會提供自然的機制，可在單一資料庫內分割資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-326">Document collections provide a natural mechanism for partitioning data within a single database.</span></span> <span data-ttu-id="c38bc-327">實作分區化最簡單的方法是建立每個分區的集合。</span><span class="sxs-lookup"><span data-stu-id="c38bc-327">The simplest way to implement sharding is to create a collection for each shard.</span></span> <span data-ttu-id="c38bc-328">容器是邏輯資源，可以跨一或多個伺服器。</span><span class="sxs-lookup"><span data-stu-id="c38bc-328">Containers are logical resources and can span one or more servers.</span></span> <span data-ttu-id="c38bc-329">固定大小的容器具有上限為 10 GB 和 10,000 RU/秒的輸送量。</span><span class="sxs-lookup"><span data-stu-id="c38bc-329">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="c38bc-330">無限制的容器不會有儲存大小上限，但是必須指定分割區索引鍵。</span><span class="sxs-lookup"><span data-stu-id="c38bc-330">Unlimited containers do not have a maximum storage size, but must specify a partition key.</span></span> <span data-ttu-id="c38bc-331">透過應用程式分區，用戶端應用程式必須將要求導向到適當的分區，通常是以定義分區索引鍵的某些資料屬性為基礎，來實作其本身的對應機制。</span><span class="sxs-lookup"><span data-stu-id="c38bc-331">With application sharding, the client application must direct requests to the appropriate shard, usually by implementing its own mapping mechanism based on some attributes of the data that define the shard key.</span></span>

<span data-ttu-id="c38bc-332">所有資料庫都要建立在 Cosmos DB 帳戶的內容中。</span><span class="sxs-lookup"><span data-stu-id="c38bc-332">All databases are created in the context of a Cosmos DB database account.</span></span> <span data-ttu-id="c38bc-333">單一帳戶可以包含數個資料庫，而且它會指定要在哪些區域中建立資料庫。</span><span class="sxs-lookup"><span data-stu-id="c38bc-333">A single account can contain several databases, and it specifies in which regions the databases are created.</span></span> <span data-ttu-id="c38bc-334">每個帳戶也會強制執行它自己的存取控制。</span><span class="sxs-lookup"><span data-stu-id="c38bc-334">Each account also enforces its own access control.</span></span> <span data-ttu-id="c38bc-335">您可以使用 Cosmos DB 帳戶異地尋找靠近需要存取帳戶之使用者的地區 (資料庫內的集合)，並強制執行限制，以便只讓使用者和它們連接。</span><span class="sxs-lookup"><span data-stu-id="c38bc-335">You can use Cosmos DB accounts to geo-locate shards (collections within databases) close to the users who need to access them, and enforce restrictions so that only those users can connect to them.</span></span>

<span data-ttu-id="c38bc-336">決定如何利用 Cosmos DB SQL API 分割資料時，請考慮下列幾點：</span><span class="sxs-lookup"><span data-stu-id="c38bc-336">Consider the following points when deciding how to partition data with the Cosmos DB SQL API:</span></span>

- <span data-ttu-id="c38bc-337">**Cosmos DB 資料庫的可用資源受限於帳戶的配額限制**。</span><span class="sxs-lookup"><span data-stu-id="c38bc-337">**The resources available to a Cosmos DB database are subject to the quota limitations of the account**.</span></span> <span data-ttu-id="c38bc-338">每個資料庫可以保留許多集合，每個集合都和控管該集合 RU 速率限制 (保留的輸送量) 的效能層級相關聯。</span><span class="sxs-lookup"><span data-stu-id="c38bc-338">Each database can hold a number of collections, and each collection is associated with a performance level that governs the RU rate limit (reserved throughput) for that collection.</span></span> <span data-ttu-id="c38bc-339">如需詳細資訊，請參閱 [Azure 訂用帳戶和服務限制、配額與條件約束][azure-limits]。</span><span class="sxs-lookup"><span data-stu-id="c38bc-339">For more information, see [Azure subscription and service limits, quotas, and constraints][azure-limits].</span></span>

- <span data-ttu-id="c38bc-340">**每份文件都必須有一個屬性，可用來在保留該文件之集合內唯一識別該文件**。</span><span class="sxs-lookup"><span data-stu-id="c38bc-340">**Each document must have an attribute that can be used to uniquely identify that document within the collection in which it is held**.</span></span> <span data-ttu-id="c38bc-341">這個屬性和定義哪個集合要保留該文件的分區索引鍵不同。</span><span class="sxs-lookup"><span data-stu-id="c38bc-341">This attribute is different from the shard key, which defines which collection holds the document.</span></span> <span data-ttu-id="c38bc-342">集合可以包含大量文件。</span><span class="sxs-lookup"><span data-stu-id="c38bc-342">A collection can contain a large number of documents.</span></span> <span data-ttu-id="c38bc-343">理論上，它只受限於文件識別碼的最大長度。</span><span class="sxs-lookup"><span data-stu-id="c38bc-343">In theory, it's limited only by the maximum length of the document ID.</span></span> <span data-ttu-id="c38bc-344">文档 ID 最多可包含 255 个字符。</span><span class="sxs-lookup"><span data-stu-id="c38bc-344">The document ID can be up to 255 characters.</span></span>

- <span data-ttu-id="c38bc-345">**針對文件的所有作業都會在交易的內容中執行。交易範圍則是包含該文件的集合。**</span><span class="sxs-lookup"><span data-stu-id="c38bc-345">**All operations against a document are performed within the context of a transaction. Transactions are scoped to the collection in which the document is contained.**</span></span> <span data-ttu-id="c38bc-346">如果作業失敗，會復原已執行的工作。</span><span class="sxs-lookup"><span data-stu-id="c38bc-346">If an operation fails, the work that it has performed is rolled back.</span></span> <span data-ttu-id="c38bc-347">當文件受限於某個作業時，所做的任何變更都會受限於快照集層級隔離。</span><span class="sxs-lookup"><span data-stu-id="c38bc-347">While a document is subject to an operation, any changes that are made are subject to snapshot-level isolation.</span></span> <span data-ttu-id="c38bc-348">例如，如果建立新文件的要求失敗，此機制可確保另一個同時查詢資料庫的使用者不會看到當時移除的部分文件。</span><span class="sxs-lookup"><span data-stu-id="c38bc-348">This mechanism guarantees that if, for example, a request to create a new document fails, another user who's querying the database simultaneously will not see a partial document that is then removed.</span></span>

- <span data-ttu-id="c38bc-349">**資料庫查詢的範圍也只限於集合層級**。</span><span class="sxs-lookup"><span data-stu-id="c38bc-349">**Database queries are also scoped to the collection level**.</span></span> <span data-ttu-id="c38bc-350">單一查詢只能從一個集合擷取資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-350">A single query can retrieve data from only one collection.</span></span> <span data-ttu-id="c38bc-351">如果您需要從多個集合中擷取資料，您必須個別查詢每個集合，並利用應用程式程式碼來合併結果。</span><span class="sxs-lookup"><span data-stu-id="c38bc-351">If you need to retrieve data from multiple collections, you must query each collection individually and merge the results in your application code.</span></span>

- <span data-ttu-id="c38bc-352">**Cosmos DB 支援所有可和文件一起儲存在集合中的可程式化項目**。</span><span class="sxs-lookup"><span data-stu-id="c38bc-352">**Cosmos DB supports programmable items that can all be stored in a collection alongside documents**.</span></span> <span data-ttu-id="c38bc-353">這些包括預存程序、使用者定義函式和觸發程序 (以 JavaScript 撰寫)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-353">These include stored procedures, user-defined functions, and triggers (written in JavaScript).</span></span> <span data-ttu-id="c38bc-354">這些項目可以在相同的集合內存取任何文件。</span><span class="sxs-lookup"><span data-stu-id="c38bc-354">These items can access any document within the same collection.</span></span> <span data-ttu-id="c38bc-355">此外，這些項目會在環境交易的範圍內執行 (如果是針對文件執行之建立、刪除或取代作業的結果引發了觸發程序)，或啟動新的交易 (如果是明確的用戶端要求結果做為執行的預存程序)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-355">Furthermore, these items run either inside the scope of the ambient transaction (in the case of a trigger that fires as the result of a create, delete, or replace operation performed against a document), or by starting a new transaction (in the case of a stored procedure that is run as the result of an explicit client request).</span></span> <span data-ttu-id="c38bc-356">如果可程式化項目中的程式碼擲回例外狀況，交易就會復原。</span><span class="sxs-lookup"><span data-stu-id="c38bc-356">If the code in a programmable item throws an exception, the transaction is rolled back.</span></span> <span data-ttu-id="c38bc-357">您可以使用預存程序和觸發程序來維護文件之間的完整性和一致性，但這些文件都必須屬於相同的集合。</span><span class="sxs-lookup"><span data-stu-id="c38bc-357">You can use stored procedures and triggers to maintain integrity and consistency between documents, but these documents must all be part of the same collection.</span></span>

- <span data-ttu-id="c38bc-358">**您想要在資料庫中保留的集合應該不太可能會超過集合的效能層級所定義的輸送量限制**。</span><span class="sxs-lookup"><span data-stu-id="c38bc-358">**The collections that you intend to hold in the databases should be unlikely to exceed the throughput limits defined by the performance levels of the collections**.</span></span> <span data-ttu-id="c38bc-359">如需詳細資訊，請參閱 [Azure Cosmos DB 中的要求單位][cosmos-db-ru]。</span><span class="sxs-lookup"><span data-stu-id="c38bc-359">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span> <span data-ttu-id="c38bc-360">如果您預期會達到這些限制，請考慮在不同帳戶中跨資料庫劃分集合，以減少每個集合的負載。</span><span class="sxs-lookup"><span data-stu-id="c38bc-360">If you anticipate reaching these limits, consider splitting collections across databases in different accounts to reduce the load per collection.</span></span>

## <a name="partitioning-azure-search"></a><span data-ttu-id="c38bc-361">資料分割 Azure 搜尋服務</span><span class="sxs-lookup"><span data-stu-id="c38bc-361">Partitioning Azure Search</span></span>

<span data-ttu-id="c38bc-362">搜尋資料的功能通常是許多 Web 應用程式所提供的主要導覽及探索方法。</span><span class="sxs-lookup"><span data-stu-id="c38bc-362">The ability to search for data is often the primary method of navigation and exploration that's provided by many web applications.</span></span> <span data-ttu-id="c38bc-363">它可協助使用者根據搜尋準則的組合快速尋找資源 (例如，電子商務應用程式中的產品)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-363">It helps users find resources quickly (for example, products in an e-commerce application) based on combinations of search criteria.</span></span> <span data-ttu-id="c38bc-364">Azure 搜尋服務提供 web 內容上的全文檢索搜尋功能，並包括預先輸入、根據鄰近符合項目建議查詢，以及多面向導覽等功能。</span><span class="sxs-lookup"><span data-stu-id="c38bc-364">The Azure Search service provides full-text search capabilities over web content, and includes features such as type-ahead, suggested queries based on near matches, and faceted navigation.</span></span> <span data-ttu-id="c38bc-365">如需詳細資訊，請參閱[何謂 Azure 搜尋服務？]。</span><span class="sxs-lookup"><span data-stu-id="c38bc-365">For more information, see [What is Azure Search?].</span></span>

<span data-ttu-id="c38bc-366">Azure 搜尋服務會將可搜尋的內容儲存為資料庫中的 JSON 文件。</span><span class="sxs-lookup"><span data-stu-id="c38bc-366">Azure Search stores searchable content as JSON documents in a database.</span></span> <span data-ttu-id="c38bc-367">您定義的索引可以在這些文件中指定可搜尋的欄位，並將這些定義提供給 Azure 搜尋服務。</span><span class="sxs-lookup"><span data-stu-id="c38bc-367">You define indexes that specify the searchable fields in these documents and provide these definitions to Azure Search.</span></span> <span data-ttu-id="c38bc-368">當使用者提交搜尋要求時，Azure 搜尋服務會使用適當的索引來尋找符合的項目。</span><span class="sxs-lookup"><span data-stu-id="c38bc-368">When a user submits a search request, Azure Search uses the appropriate indexes to find matching items.</span></span>

<span data-ttu-id="c38bc-369">為了減少爭用，Azure 搜尋服務所使用的儲存體可以區分成 1、2、3、4、6 或 12 個分割區，且每個分割區可以複寫高達 6 次。</span><span class="sxs-lookup"><span data-stu-id="c38bc-369">To reduce contention, the storage that's used by Azure Search can be divided into 1, 2, 3, 4, 6, or 12 partitions, and each partition can be replicated up to 6 times.</span></span> <span data-ttu-id="c38bc-370">分割區數目乘以複本數目的乘積稱「搜尋單位」(SU)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-370">The product of the number of partitions multiplied by the number of replicas is called the *search unit* (SU).</span></span> <span data-ttu-id="c38bc-371">Azure 搜尋服務的單一執行個體可以包含最多 36 個 SU (具有 12 個分割區的資料庫只支援最多 3 個複本)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-371">A single instance of Azure Search can contain a maximum of 36 SUs (a database with 12 partitions only supports a maximum of 3 replicas).</span></span>

<span data-ttu-id="c38bc-372">您需要支付配置給服務的每個 SU。</span><span class="sxs-lookup"><span data-stu-id="c38bc-372">You are billed for each SU that is allocated to your service.</span></span> <span data-ttu-id="c38bc-373">當可搜尋的內容數量增加或搜尋要求的速率成長時，您可以將 SU 新增到 Azure 搜尋服務的現有執行個體來處理額外的負載。</span><span class="sxs-lookup"><span data-stu-id="c38bc-373">As the volume of searchable content increases or the rate of search requests grows, you can add SUs to an existing instance of Azure Search to handle the extra load.</span></span> <span data-ttu-id="c38bc-374">Azure 搜尋服務本身會跨分割區平均分佈文件。</span><span class="sxs-lookup"><span data-stu-id="c38bc-374">Azure Search itself distributes the documents evenly across the partitions.</span></span> <span data-ttu-id="c38bc-375">目前不支援任何手動資料分割策略。</span><span class="sxs-lookup"><span data-stu-id="c38bc-375">No manual partitioning strategies are currently supported.</span></span>

<span data-ttu-id="c38bc-376">每個分割區可以包含最多 1500 萬份文件或佔用 300 GB 的儲存空間 (取兩者中較低者)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-376">Each partition can contain a maximum of 15 million documents or occupy 300 GB of storage space (whichever is smaller).</span></span> <span data-ttu-id="c38bc-377">您最多可以建立 50 個索引。</span><span class="sxs-lookup"><span data-stu-id="c38bc-377">You can create up to 50 indexes.</span></span> <span data-ttu-id="c38bc-378">服務的效能會因文件的複雜性、可用的索引，以及網路延遲的影響而有所不同。</span><span class="sxs-lookup"><span data-stu-id="c38bc-378">The performance of the service varies and depends on the complexity of the documents, the available indexes, and the effects of network latency.</span></span> <span data-ttu-id="c38bc-379">雖然我們建議利用您自己的資料來執行效能評比，以取得更精確的輸送量量值，但平均而言，單一複本 (1 SU) 的處理速度應該是每秒 15 個查詢 (QPS)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-379">On average, a single replica (1 SU) should be able to handle 15 queries per second (QPS), although we recommend performing benchmarking with your own data to obtain a more precise measure of throughput.</span></span> <span data-ttu-id="c38bc-380">如需詳細資訊，請參閱 [Azure 搜尋服務中的服務限制]。</span><span class="sxs-lookup"><span data-stu-id="c38bc-380">For more information, see [Service limits in Azure Search].</span></span>

> [!NOTE]
> <span data-ttu-id="c38bc-381">您可以將一組有限的資料類型儲存在可搜尋的文件中，包括字串、布林值、數字資料、日期時間資料，以及一些地理資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-381">You can store a limited set of data types in searchable documents, including strings, Booleans, numeric data, datetime data, and some geographical data.</span></span> <span data-ttu-id="c38bc-382">如需詳細資料，請參閱 Microsoft 網站上的 [支援的資料類型 (Azure 搜尋服務)] 頁面。</span><span class="sxs-lookup"><span data-stu-id="c38bc-382">For more details, see the page [Supported data types (Azure Search)] on the Microsoft website.</span></span>

<span data-ttu-id="c38bc-383">針對 Azure 搜尋服務如何分割每個服務執行個體的資料，您的控制權有限。</span><span class="sxs-lookup"><span data-stu-id="c38bc-383">You have limited control over how Azure Search partitions data for each instance of the service.</span></span> <span data-ttu-id="c38bc-384">不過，在全域環境中，您能夠藉由使用下列任一策略來分割服務本身，進一步改善效能並減少延遲和爭用：</span><span class="sxs-lookup"><span data-stu-id="c38bc-384">However, in a global environment you might be able to improve performance and reduce latency and contention further by partitioning the service itself using either of the following strategies:</span></span>

- <span data-ttu-id="c38bc-385">在每個地理區域中，建立 Azure 搜尋服務的執行個體，並確定會將用戶端應用程式導向至最接近的可用執行個體。</span><span class="sxs-lookup"><span data-stu-id="c38bc-385">Create an instance of Azure Search in each geographic region, and ensure that client applications are directed towards the nearest available instance.</span></span> <span data-ttu-id="c38bc-386">此策略需要可搜尋內容的任何更新，可跨服務的所有執行個體即時複寫。</span><span class="sxs-lookup"><span data-stu-id="c38bc-386">This strategy requires that any updates to searchable content are replicated in a timely manner across all instances of the service.</span></span>

- <span data-ttu-id="c38bc-387">建立兩層的 Azure 搜尋服務︰</span><span class="sxs-lookup"><span data-stu-id="c38bc-387">Create two tiers of Azure Search:</span></span>

  - <span data-ttu-id="c38bc-388">每個區域中的本機服務，包含該區域中的使用者最常存取的資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-388">A local service in each region that contains the data that's most frequently accessed by users in that region.</span></span> <span data-ttu-id="c38bc-389">使用者可以在此處導向要求 (適用於快速而有限的結果)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-389">Users can direct requests here for fast but limited results.</span></span>
  - <span data-ttu-id="c38bc-390">包含所有資料的全域服務。</span><span class="sxs-lookup"><span data-stu-id="c38bc-390">A global service that encompasses all the data.</span></span> <span data-ttu-id="c38bc-391">使用者可以在此處導向要求 (適用於較慢但更完整的結果)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-391">Users can direct requests here for slower but more complete results.</span></span>

<span data-ttu-id="c38bc-392">當搜尋的資料中有重大的區域性變化時，最適用這個方法。</span><span class="sxs-lookup"><span data-stu-id="c38bc-392">This approach is most suitable when there is a significant regional variation in the data that's being searched.</span></span>

## <a name="partitioning-azure-redis-cache"></a><span data-ttu-id="c38bc-393">資料分割 Azure Redis 快取</span><span class="sxs-lookup"><span data-stu-id="c38bc-393">Partitioning Azure Redis Cache</span></span>

<span data-ttu-id="c38bc-394">Azure Redis 快取在雲端中提供以 Redis 索引鍵-值資料存放區為基礎的共用快取服務。</span><span class="sxs-lookup"><span data-stu-id="c38bc-394">Azure Redis Cache provides a shared caching service in the cloud that's based on the Redis key-value data store.</span></span> <span data-ttu-id="c38bc-395">正如其名，Azure Redis 快取的目的是做為快取解決方案。</span><span class="sxs-lookup"><span data-stu-id="c38bc-395">As its name implies, Azure Redis Cache is intended as a caching solution.</span></span> <span data-ttu-id="c38bc-396">只能用它來保留暫時性資料，而不是做為永久的資料存放區。</span><span class="sxs-lookup"><span data-stu-id="c38bc-396">Use it only for holding transient data and not as a permanent data store.</span></span> <span data-ttu-id="c38bc-397">如果快取無法使用，則使用 Azure Redis 快取的應用程式應該能夠繼續運作。</span><span class="sxs-lookup"><span data-stu-id="c38bc-397">Applications that use Azure Redis Cache should be able to continue functioning if the cache is unavailable.</span></span> <span data-ttu-id="c38bc-398">Azure Redis 快取支援主要/次要複寫以提供高可用性，但目前的快取大小上限為 53 GB。</span><span class="sxs-lookup"><span data-stu-id="c38bc-398">Azure Redis Cache supports primary/secondary replication to provide high availability, but currently limits the maximum cache size to 53 GB.</span></span> <span data-ttu-id="c38bc-399">如果您需要更多的空間，您必須建立其他快取。</span><span class="sxs-lookup"><span data-stu-id="c38bc-399">If you need more space than this, you must create additional caches.</span></span> <span data-ttu-id="c38bc-400">如需詳細資訊，請參閱 [Azure Redis 快取]。</span><span class="sxs-lookup"><span data-stu-id="c38bc-400">For more information, see [Azure Redis Cache].</span></span>

<span data-ttu-id="c38bc-401">分割 Redis 資料存放區包含跨 Redis 服務的執行個體劃分資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-401">Partitioning a Redis data store involves splitting the data across instances of the Redis service.</span></span> <span data-ttu-id="c38bc-402">每個執行個體都會構成單一分割區。</span><span class="sxs-lookup"><span data-stu-id="c38bc-402">Each instance constitutes a single partition.</span></span> <span data-ttu-id="c38bc-403">Azure Redis Cache 會抽象化外觀背後的 Redis 服務，而不會直接公開它們。</span><span class="sxs-lookup"><span data-stu-id="c38bc-403">Azure Redis Cache abstracts the Redis services behind a façade and does not expose them directly.</span></span> <span data-ttu-id="c38bc-404">實作資料分割的最簡單方式是建立多個 Azure Redis 快取執行個體，並將資料分佈於它們之間。</span><span class="sxs-lookup"><span data-stu-id="c38bc-404">The simplest way to implement partitioning is to create multiple Azure Redis Cache instances and spread the data across them.</span></span>

<span data-ttu-id="c38bc-405">您可以將每個資料項目關聯至指定哪個快取要儲存資料項目的識別碼 (分割區索引鍵)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-405">You can associate each data item with an identifier (a partition key) that specifies which cache stores the data item.</span></span> <span data-ttu-id="c38bc-406">用戶端應用程式邏輯接著可以使用這個識別碼，將要求路由傳送至適當的分割區。</span><span class="sxs-lookup"><span data-stu-id="c38bc-406">The client application logic can then use this identifier to route requests to the appropriate partition.</span></span> <span data-ttu-id="c38bc-407">此配置非常簡單，但是如果資料分割配置有所變更 (例如，如果建立了其他 Azure Redis 快取執行個體)，則用戶端應用程式可能需要重新設定。</span><span class="sxs-lookup"><span data-stu-id="c38bc-407">This scheme is very simple, but if the partitioning scheme changes (for example, if additional Azure Redis Cache instances are created), client applications might need to be reconfigured.</span></span>

<span data-ttu-id="c38bc-408">根據 Redis 叢集，原生 Redis (非 Azure Redis Cache) 支援伺服器端資料分割。</span><span class="sxs-lookup"><span data-stu-id="c38bc-408">Native Redis (not Azure Redis Cache) supports server-side partitioning based on Redis clustering.</span></span> <span data-ttu-id="c38bc-409">在這種方法中，您可以使用雜湊機制，跨伺服器平均區分資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-409">In this approach, you can divide the data evenly across servers by using a hashing mechanism.</span></span> <span data-ttu-id="c38bc-410">每個 Redis 伺服器會儲存中繼資料 (描述分割區保留的雜湊索引鍵範圍)，也包含哪些雜湊索引鍵位於其他伺服器上的分割區中的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="c38bc-410">Each Redis server stores metadata that describes the range of hash keys that the partition holds, and also contains information about which hash keys are located in the partitions on other servers.</span></span>

<span data-ttu-id="c38bc-411">用戶端應用程式只會將要求傳送至任何參與的 Redis 伺服器 (可能是最接近的伺服器)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-411">Client applications simply send requests to any of the participating Redis servers (probably the closest one).</span></span> <span data-ttu-id="c38bc-412">Redis 伺服器會檢查用戶端要求。</span><span class="sxs-lookup"><span data-stu-id="c38bc-412">The Redis server examines the client request.</span></span> <span data-ttu-id="c38bc-413">如果可以在本機解決，就會執行要求的作業，</span><span class="sxs-lookup"><span data-stu-id="c38bc-413">If it can be resolved locally, it performs the requested operation.</span></span> <span data-ttu-id="c38bc-414">否則會將要求轉送到適當的伺服器。</span><span class="sxs-lookup"><span data-stu-id="c38bc-414">Otherwise it forwards the request on to the appropriate server.</span></span>

<span data-ttu-id="c38bc-415">此模型會使用 Redis 叢集實作，而且會在 Redis 網站上的 [Redis 叢集教學課程] 頁面上提供更詳細的描述。</span><span class="sxs-lookup"><span data-stu-id="c38bc-415">This model is implemented by using Redis clustering, and is described in more detail on the [Redis cluster tutorial] page on the Redis website.</span></span> <span data-ttu-id="c38bc-416">Redis 叢集對用戶端應用程式而言是透明的。</span><span class="sxs-lookup"><span data-stu-id="c38bc-416">Redis clustering is transparent to client applications.</span></span> <span data-ttu-id="c38bc-417">其他的 Redis 伺服器可以加入至叢集 (資料可重新分割)，而不需重新設定用戶端。</span><span class="sxs-lookup"><span data-stu-id="c38bc-417">Additional Redis servers can be added to the cluster (and the data can be re-partitioned) without requiring that you reconfigure the clients.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c38bc-418">Azure Redis Cache 目前僅在[進階](/azure/azure-cache-for-redis/cache-how-to-premium-clustering)層支援 Redis 群集。</span><span class="sxs-lookup"><span data-stu-id="c38bc-418">Azure Redis Cache currently supports Redis clustering in [premium](/azure/azure-cache-for-redis/cache-how-to-premium-clustering) tier only.</span></span>

<span data-ttu-id="c38bc-419">Redis 網站上的 [Partitioning: how to split data among multiple Redis instances (資料分割：如何在多個 Redis 執行個體上分割資料)] 頁面會提供更多關於使用 Redis 實作資料分割的資訊。</span><span class="sxs-lookup"><span data-stu-id="c38bc-419">The page [Partitioning: how to split data among multiple Redis instances] on the Redis website provides more information about implementing partitioning with Redis.</span></span> <span data-ttu-id="c38bc-420">本節的其餘部分假設您正在實作用戶端或 proxy 輔助資料分割。</span><span class="sxs-lookup"><span data-stu-id="c38bc-420">The remainder of this section assumes that you are implementing client-side or proxy-assisted partitioning.</span></span>

<span data-ttu-id="c38bc-421">決定如何利用 Azure Redis 快取來分割資料時，請考慮下列幾點：</span><span class="sxs-lookup"><span data-stu-id="c38bc-421">Consider the following points when deciding how to partition data with Azure Redis Cache:</span></span>

- <span data-ttu-id="c38bc-422">Azure Redis 快取的目的不是做為永久的資料存放區，因此無論您實作任何資料分割配置，您應用程式的程式碼都必須夠從不是快取的位置上擷取資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-422">Azure Redis Cache is not intended to act as a permanent data store, so whatever partitioning scheme you implement, your application code must be able to retrieve data from a location that's not the cache.</span></span>

- <span data-ttu-id="c38bc-423">經常一起存取的資料應保留於相同的分割區中。</span><span class="sxs-lookup"><span data-stu-id="c38bc-423">Data that is frequently accessed together should be kept in the same partition.</span></span> <span data-ttu-id="c38bc-424">Redis 是一個功能強大的索引鍵-值存放區，提供數種高度最佳化的機制以建構資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-424">Redis is a powerful key-value store that provides several highly optimized mechanisms for structuring data.</span></span> <span data-ttu-id="c38bc-425">這些機制可以是下列其中一項：</span><span class="sxs-lookup"><span data-stu-id="c38bc-425">These mechanisms can be one of the following:</span></span>
  - <span data-ttu-id="c38bc-426">簡單字串 (長度高達 512 MB 的二進位資料) </span><span class="sxs-lookup"><span data-stu-id="c38bc-426">Simple strings (binary data up to 512 MB in length)</span></span>
  - <span data-ttu-id="c38bc-427">彙總類型，例如清單 (其可做為佇列和堆疊)</span><span class="sxs-lookup"><span data-stu-id="c38bc-427">Aggregate types such as lists (which can act as queues and stacks)</span></span>
  - <span data-ttu-id="c38bc-428">集合 (排序和未排序)</span><span class="sxs-lookup"><span data-stu-id="c38bc-428">Sets (ordered and unordered)</span></span>
  - <span data-ttu-id="c38bc-429">雜湊 (可將相關的欄位群組在一起，例如在一個物件中代表欄位的項目)</span><span class="sxs-lookup"><span data-stu-id="c38bc-429">Hashes (which can group related fields together, such as the items that represent the fields in an object)</span></span>

- <span data-ttu-id="c38bc-430">彙總類型可讓您將許多相關的值與同一個索引鍵建立關聯。</span><span class="sxs-lookup"><span data-stu-id="c38bc-430">The aggregate types enable you to associate many related values with the same key.</span></span> <span data-ttu-id="c38bc-431">Redis 索引鍵可識別清單、集合或雜湊，而非它所包含的資料項目。</span><span class="sxs-lookup"><span data-stu-id="c38bc-431">A Redis key identifies a list, set, or hash rather than the data items that it contains.</span></span> <span data-ttu-id="c38bc-432">這些類型全都可供 Azure Redis 快取使用，並描述於 Redis 網站上的 [Data types (資料類型)] 頁面。</span><span class="sxs-lookup"><span data-stu-id="c38bc-432">These types are all available with Azure Redis Cache and are described by the [Data types] page on the Redis website.</span></span> <span data-ttu-id="c38bc-433">例如，在追蹤客戶所下訂單的部分電子商務系統中，每一位客戶的詳細資料都可儲存於 Redis 雜湊中，使用客戶識別碼做為索引鍵。</span><span class="sxs-lookup"><span data-stu-id="c38bc-433">For example, in part of an e-commerce system that tracks the orders that are placed by customers, the details of each customer can be stored in a Redis hash that is keyed by using the customer ID.</span></span> <span data-ttu-id="c38bc-434">每個雜湊都可以保留客戶的訂單識別碼集合。</span><span class="sxs-lookup"><span data-stu-id="c38bc-434">Each hash can hold a collection of order IDs for the customer.</span></span> <span data-ttu-id="c38bc-435">個別的 Redis 集合可以保留訂單、重新建構為雜湊，並使用訂單識別碼做為索引鍵。</span><span class="sxs-lookup"><span data-stu-id="c38bc-435">A separate Redis set can hold the orders, again structured as hashes, and keyed by using the order ID.</span></span> <span data-ttu-id="c38bc-436">圖 8 顯示此結構。</span><span class="sxs-lookup"><span data-stu-id="c38bc-436">Figure 8 shows this structure.</span></span> <span data-ttu-id="c38bc-437">請注意，Redis 不會實作任何形式的參考完整性，所以開發人員必須負責維護客戶和訂單之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="c38bc-437">Note that Redis does not implement any form of referential integrity, so it is the developer's responsibility to maintain the relationships between customers and orders.</span></span>

![Redis 儲存體中記錄客戶訂單及其詳細資料的建議結構](./images/data-partitioning/RedisCustomersandOrders.png)

<span data-ttu-id="c38bc-439">*圖 8.Redis 儲存體中記錄客戶訂單及其詳細資料的建議結構。*</span><span class="sxs-lookup"><span data-stu-id="c38bc-439">*Figure 8. Suggested structure in Redis storage for recording customer orders and their details.*</span></span>

> [!NOTE]
> <span data-ttu-id="c38bc-440">在 Redis 中，所有索引鍵都是二進位資料值 (例如 Redis 字串)，且最多可包含 512 MB 的資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-440">In Redis, all keys are binary data values (like Redis strings) and can contain up to 512 MB of data.</span></span> <span data-ttu-id="c38bc-441">理論上，索引鍵幾乎可以包含所有資訊。</span><span class="sxs-lookup"><span data-stu-id="c38bc-441">In theory, a key can contain almost any information.</span></span> <span data-ttu-id="c38bc-442">不過，建議採用一致的索引鍵命名慣例，可描述資料類型並識別實體，但該慣例不可過長。</span><span class="sxs-lookup"><span data-stu-id="c38bc-442">However, we recommend adopting a consistent naming convention for keys that is descriptive of the type of data and that identifies the entity, but is not excessively long.</span></span> <span data-ttu-id="c38bc-443">常見的方法是使用 "entity_type:ID" 形式的索引鍵。</span><span class="sxs-lookup"><span data-stu-id="c38bc-443">A common approach is to use keys of the form "entity_type:ID".</span></span> <span data-ttu-id="c38bc-444">例如，可以使用“customer:99”来表示客户 ID 99 的键。</span><span class="sxs-lookup"><span data-stu-id="c38bc-444">For example, you can use "customer:99" to indicate the key for a customer with the ID 99.</span></span>

- <span data-ttu-id="c38bc-445">您可以將相關的資訊儲存在相同資料庫中的不同彙總以實作垂直資料分割。</span><span class="sxs-lookup"><span data-stu-id="c38bc-445">You can implement vertical partitioning by storing related information in different aggregations in the same database.</span></span> <span data-ttu-id="c38bc-446">例如，在電子商務應用程式中，您可以將經常存取的產品相關資訊儲存在某一個 Redis 雜湊中，並將較少使用的詳細資訊儲存在另一個。</span><span class="sxs-lookup"><span data-stu-id="c38bc-446">For example, in an e-commerce application, you can store commonly accessed information about products in one Redis hash and less frequently used detailed information in another.</span></span> <span data-ttu-id="c38bc-447">這兩個雜湊可以使用相同的產品識別碼做為索引鍵的一部分。</span><span class="sxs-lookup"><span data-stu-id="c38bc-447">Both hashes can use the same product ID as part of the key.</span></span> <span data-ttu-id="c38bc-448">例如，您可以針對產品資訊使用 "product:nn" (其中 nn 是產品識別碼)，而 "product_details: nn" 則適用於詳細資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-448">For example, you can use "product: *nn*" (where *nn* is the product ID) for the product information and "product_details: *nn*" for the detailed data.</span></span> <span data-ttu-id="c38bc-449">此策略有助於減少大多數查詢可能會擷取的資料量。</span><span class="sxs-lookup"><span data-stu-id="c38bc-449">This strategy can help reduce the volume of data that most queries are likely to retrieve.</span></span>

- <span data-ttu-id="c38bc-450">您可以重新分割 Redis 資料存放區，但請記住它是複雜且耗時的工作。</span><span class="sxs-lookup"><span data-stu-id="c38bc-450">You can repartition a Redis data store, but keep in mind that it's a complex and time-consuming task.</span></span> <span data-ttu-id="c38bc-451">Redis 叢集可以自動重新分割資料，但Azure Redis 快取無法使用此功能。</span><span class="sxs-lookup"><span data-stu-id="c38bc-451">Redis clustering can repartition data automatically, but this capability is not available with Azure Redis Cache.</span></span> <span data-ttu-id="c38bc-452">因此，當您設計資料分割配置時，請嘗試在每個分割區中保留足夠的可用空間，以允許一段時間後預期的資料成長。</span><span class="sxs-lookup"><span data-stu-id="c38bc-452">Therefore, when you design your partitioning scheme, try to leave sufficient free space in each partition to allow for expected data growth over time.</span></span> <span data-ttu-id="c38bc-453">不過，請記住 Azure Redis Cache 的目的是暫時快取資料，而且保留在快取中的資料具有有限的存留期，指定為存留時間 (TTL) 值。</span><span class="sxs-lookup"><span data-stu-id="c38bc-453">However, remember that Azure Redis Cache is intended to cache data temporarily, and that data held in the cache can have a limited lifetime specified as a time-to-live (TTL) value.</span></span> <span data-ttu-id="c38bc-454">對於相對易變的資料而言，TTL 可以短一點，但對於靜態資料而言，TTL 可以更長。</span><span class="sxs-lookup"><span data-stu-id="c38bc-454">For relatively volatile data, the TTL can be short, but for static data the TTL can be a lot longer.</span></span> <span data-ttu-id="c38bc-455">如果此資料量可能會填滿快取，請避免在快取中儲存大量長時間留存的資料。</span><span class="sxs-lookup"><span data-stu-id="c38bc-455">Avoid storing large amounts of long-lived data in the cache if the volume of this data is likely to fill the cache.</span></span> <span data-ttu-id="c38bc-456">如果空間價格不斐，您可以指定會讓 Azure Redis Cache 移除資料的收回原則。</span><span class="sxs-lookup"><span data-stu-id="c38bc-456">You can specify an eviction policy that causes Azure Redis Cache to remove data if space is at a premium.</span></span>

  > [!NOTE]
  > <span data-ttu-id="c38bc-457">當您使用 Azure Redis 快取時，可以藉由選取適當的定價層，來指定快取的大小上限 (從 250 MB 到 53 GB)。</span><span class="sxs-lookup"><span data-stu-id="c38bc-457">When you use Azure Redis cache, you specify the maximum size of the cache (from 250 MB to 53 GB) by selecting the appropriate pricing tier.</span></span> <span data-ttu-id="c38bc-458">不過，建立 Azure Redis 快取之後，您就無法增加 (或減少) 其大小。</span><span class="sxs-lookup"><span data-stu-id="c38bc-458">However, after an Azure Redis Cache has been created, you cannot increase (or decrease) its size.</span></span>

- <span data-ttu-id="c38bc-459">Redis 批处理与事务不能跨多个连接，因此受批处理或事务影响的所有数据应保存在同一数据库（分片）中。</span><span class="sxs-lookup"><span data-stu-id="c38bc-459">Redis batches and transactions cannot span multiple connections, so all data that is affected by a batch or transaction should be held in the same database (shard).</span></span>

  > [!NOTE]
  > <span data-ttu-id="c38bc-460">Redis 交易中的作業序列不一定是不可部分完成的。</span><span class="sxs-lookup"><span data-stu-id="c38bc-460">A sequence of operations in a Redis transaction is not necessarily atomic.</span></span> <span data-ttu-id="c38bc-461">構成交易的命令已經過驗證，並在執行之前已排入佇列，</span><span class="sxs-lookup"><span data-stu-id="c38bc-461">The commands that compose a transaction are verified and queued before they run.</span></span> <span data-ttu-id="c38bc-462">如果在這個階段期間發生錯誤，即會捨棄整個佇列。</span><span class="sxs-lookup"><span data-stu-id="c38bc-462">If an error occurs during this phase, the entire queue is discarded.</span></span> <span data-ttu-id="c38bc-463">不過，在交易成功提交之後，排入佇列的命令就會依序執行。</span><span class="sxs-lookup"><span data-stu-id="c38bc-463">However, after the transaction has been successfully submitted, the queued commands run in sequence.</span></span> <span data-ttu-id="c38bc-464">如果有任何命令失敗，則只有該命令會停止執行。</span><span class="sxs-lookup"><span data-stu-id="c38bc-464">If any command fails, only that command stops running.</span></span> <span data-ttu-id="c38bc-465">佇列中的所有先前與後續命令都會執行。</span><span class="sxs-lookup"><span data-stu-id="c38bc-465">All previous and subsequent commands in the queue are performed.</span></span> <span data-ttu-id="c38bc-466">如需詳細資訊，請瀏覽 Redis 網站上的[交易]頁面。</span><span class="sxs-lookup"><span data-stu-id="c38bc-466">For more information, go to the [Transactions] page on the Redis website.</span></span>

- <span data-ttu-id="c38bc-467">Redis 支援有限數量的不可部分完成作業。</span><span class="sxs-lookup"><span data-stu-id="c38bc-467">Redis supports a limited number of atomic operations.</span></span> <span data-ttu-id="c38bc-468">支援多個索引鍵和值的此類型作業只有 MGET 和 MSET 作業。</span><span class="sxs-lookup"><span data-stu-id="c38bc-468">The only operations of this type that support multiple keys and values are MGET and MSET operations.</span></span> <span data-ttu-id="c38bc-469">MGET 作業會傳回指定索引鍵清單值的集合，而 MSET 作業會儲存指定索引鍵清單值的集合。</span><span class="sxs-lookup"><span data-stu-id="c38bc-469">MGET operations return a collection of values for a specified list of keys, and MSET operations store a collection of values for a specified list of keys.</span></span> <span data-ttu-id="c38bc-470">如果您必須使用這些作業，MSET 和 MGET 命令所參考的索引鍵-值組必須儲存在同一個資料庫內。</span><span class="sxs-lookup"><span data-stu-id="c38bc-470">If you need to use these operations, the key-value pairs that are referenced by the MSET and MGET commands must be stored within the same database.</span></span>

## <a name="partitioning-azure-service-fabric"></a><span data-ttu-id="c38bc-471">資料分割 Azure Service Fabric</span><span class="sxs-lookup"><span data-stu-id="c38bc-471">Partitioning Azure Service Fabric</span></span>

<span data-ttu-id="c38bc-472">Azure Service Fabric 是微服務平台，在雲端中提供分散式應用程式的執行階段。</span><span class="sxs-lookup"><span data-stu-id="c38bc-472">Azure Service Fabric is a microservices platform that provides a runtime for distributed applications in the cloud.</span></span> <span data-ttu-id="c38bc-473">Service Fabric 支援 .Net 來賓可執行檔、具狀態和無狀態的服務、容器。</span><span class="sxs-lookup"><span data-stu-id="c38bc-473">Service Fabric supports .Net guest executables, stateful and stateless services, and containers.</span></span> <span data-ttu-id="c38bc-474">具狀態服務提供[可靠集合][service-fabric-reliable-collections]，可持續將資料儲存在 Service Fabric 叢集內的索引鍵/值集合中。</span><span class="sxs-lookup"><span data-stu-id="c38bc-474">Stateful services provide a [reliable collection][service-fabric-reliable-collections] to persistently store data in a key-value collection within the Service Fabric cluster.</span></span> <span data-ttu-id="c38bc-475">如需可靠集合中的分割區索引鍵的策略詳細資訊，請參閱 [Azure Service Fabric 中可靠集合的指導方針和建議]。</span><span class="sxs-lookup"><span data-stu-id="c38bc-475">For more information about strategies for partitioning keys in a reliable collection, see [guidelines and recommendations for reliable collections in Azure Service Fabric].</span></span>

### <a name="more-information"></a><span data-ttu-id="c38bc-476">詳細資訊</span><span class="sxs-lookup"><span data-stu-id="c38bc-476">More information</span></span>

- <span data-ttu-id="c38bc-477">[Azure Service Fabric 概觀]是 Azure Service Fabric 的簡介。</span><span class="sxs-lookup"><span data-stu-id="c38bc-477">[Overview of Azure Service Fabric] is an introduction to Azure Service Fabric.</span></span>

- <span data-ttu-id="c38bc-478">[分割 Service Fabric 可靠服務]提供 Azure Service Fabric 中可靠服務的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="c38bc-478">[Partition Service Fabric reliable services] provides more information about reliable services in Azure Service Fabric.</span></span>

## <a name="partitioning-azure-event-hubs"></a><span data-ttu-id="c38bc-479">資料分割 Azure 事件中樞</span><span class="sxs-lookup"><span data-stu-id="c38bc-479">Partitioning Azure Event Hubs</span></span>

<span data-ttu-id="c38bc-480">[Azure 事件中樞][event-hubs]是針對大規模資料流而設計，而在服務中建置資料分割則是為了啟用水平調整。</span><span class="sxs-lookup"><span data-stu-id="c38bc-480">[Azure Event Hubs][event-hubs] is designed for data streaming at massive scale, and partitioning is built into the service to enable horizontal scaling.</span></span> <span data-ttu-id="c38bc-481">每一個取用者只會讀取訊息資料流的特定分割區。</span><span class="sxs-lookup"><span data-stu-id="c38bc-481">Each consumer only reads a specific partition of the message stream.</span></span>

<span data-ttu-id="c38bc-482">事件發佈行者只會知道資料分割索引鍵，不會知道事件發佈的目的地資料分割。</span><span class="sxs-lookup"><span data-stu-id="c38bc-482">The event publisher is only aware of its partition key, not the partition to which the events are published.</span></span> <span data-ttu-id="c38bc-483">索引鍵和資料分割脫鉤的這種機制，讓傳送者不需要知道太多有關下游處理的細節。</span><span class="sxs-lookup"><span data-stu-id="c38bc-483">This decoupling of key and partition insulates the sender from needing to know too much about the downstream processing.</span></span> <span data-ttu-id="c38bc-484">(也可以直接將事件傳送至給定的資料分割，但一般而言，不建議這麼做。)</span><span class="sxs-lookup"><span data-stu-id="c38bc-484">(It's also possible send events directly to a given partition, but generally that's not recommended.)</span></span>  

<span data-ttu-id="c38bc-485">當您選取資料分割計數時，請考慮長期規模。</span><span class="sxs-lookup"><span data-stu-id="c38bc-485">Consider long-term scale when you select the partition count.</span></span> <span data-ttu-id="c38bc-486">建立事件中樞之後，便無法變更資料分割數目。</span><span class="sxs-lookup"><span data-stu-id="c38bc-486">After an event hub is created, you can't change the number of partitions.</span></span>

<span data-ttu-id="c38bc-487">如需在事件中樞中使用分割的詳細資訊，請參閱[什麼是事件中樞？]。</span><span class="sxs-lookup"><span data-stu-id="c38bc-487">For more information about using partitions in Event Hubs, see [What is Event Hubs?].</span></span>

<span data-ttu-id="c38bc-488">如需可用性和一致性之間的取捨考量，請參閱[事件中樞的可用性和一致性]。</span><span class="sxs-lookup"><span data-stu-id="c38bc-488">For considerations about trade-offs between availability and consistency, see [Availability and consistency in Event Hubs].</span></span>

[事件中樞的可用性和一致性]: /azure/event-hubs/event-hubs-availability-and-consistency
[Availability and consistency in Event Hubs]: /azure/event-hubs/event-hubs-availability-and-consistency
[azure-limits]: /azure/azure-subscription-service-limits
[Azure Content Delivery Network]: /azure/cdn/cdn-overview
[Azure Redis 快取]: https://azure.microsoft.com/services/cache/
[Azure Redis Cache]: https://azure.microsoft.com/services/cache/
[Azure Storage Scalability and Performance Targets]: /azure/storage/storage-scalability-targets
[Azure 儲存體資料表設計指南]: /azure/storage/storage-table-design-guide
[Azure Storage Table Design Guide]: /azure/storage/storage-table-design-guide
[Building a Polyglot Solution]: https://msdn.microsoft.com/library/dn313279.aspx
[cosmos-db-ru]: /azure/cosmos-db/request-units
[Data Access for Highly-Scalable Solutions: Using SQL, NoSQL, and Polyglot Persistence]: https://msdn.microsoft.com/library/dn271399.aspx
[Data consistency primer]: https://aka.ms/Data-Consistency-Primer
[Data Partitioning Guidance]: https://msdn.microsoft.com/library/dn589795.aspx
[Data types (資料類型)]: https://redis.io/topics/data-types
[Data Types]: https://redis.io/topics/data-types
[cosmosdb-sql-api]: /azure/cosmos-db/sql-api-introduction
[Elastic Database features overview]: /azure/sql-database/sql-database-elastic-scale-introduction
[event-hubs]: /azure/event-hubs
[Federations Migration Utility]: https://code.msdn.microsoft.com/vstudio/Federations-Migration-ce61e9c1
[Azure Service Fabric 中可靠集合的指導方針和建議]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[guidelines and recommendations for reliable collections in Azure Service Fabric]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[Multi-shard querying]: /azure/sql-database/sql-database-elastic-scale-multishard-querying
[Azure Service Fabric 概觀]: /azure/service-fabric/service-fabric-overview
[Overview of Azure Service Fabric]: /azure/service-fabric/service-fabric-overview
[分割 Service Fabric 可靠服務]: /azure/service-fabric/service-fabric-concepts-partitioning
[Partition Service Fabric reliable services]: /azure/service-fabric/service-fabric-concepts-partitioning
[Partitioning: how to split data among multiple Redis instances (資料分割：如何在多個 Redis 執行個體上分割資料)]: https://redis.io/topics/partitioning
[Partitioning: how to split data among multiple Redis instances]: https://redis.io/topics/partitioning
[執行實體群組交易]: /rest/api/storageservices/Performing-Entity-Group-Transactions
[Performing Entity Group Transactions]: /rest/api/storageservices/Performing-Entity-Group-Transactions
[Redis 叢集教學課程]: https://redis.io/topics/cluster-tutorial
[Redis cluster tutorial]: https://redis.io/topics/cluster-tutorial
[Running Redis on a CentOS Linux VM in Azure]: https://blogs.msdn.microsoft.com/tconte/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure/
[Scaling using the Elastic Database split-merge tool]: /azure/sql-database/sql-database-elastic-scale-overview-split-and-merge
[Using Azure Content Delivery Network]: /azure/cdn/cdn-create-new-endpoint
[服務匯流排配額]: /azure/service-bus-messaging/service-bus-quotas
[Service Bus quotas]: /azure/service-bus-messaging/service-bus-quotas
[service-fabric-reliable-collections]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections
[Azure 搜尋服務中的服務限制]:  /azure/search/search-limits-quotas-capacity
[Service limits in Azure Search]:  /azure/search/search-limits-quotas-capacity
[Sharding pattern]: ../patterns/sharding.md
[支援的資料類型 (Azure 搜尋服務)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Supported Data Types (Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[交易]: https://redis.io/topics/transactions
[Transactions]: https://redis.io/topics/transactions
[什麼是事件中樞？]: /azure/event-hubs/event-hubs-what-is-event-hubs
[What is Event Hubs?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[何謂 Azure 搜尋服務？]: /azure/search/search-what-is-azure-search
[What is Azure Search?]: /azure/search/search-what-is-azure-search
[What is Azure SQL Database?]: /azure/sql-database/sql-database-technical-overview
[延展性目標]: /azure/storage/common/storage-scalability-targets
[scalability targets]: /azure/storage/common/storage-scalability-targets
