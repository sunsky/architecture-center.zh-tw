---
title: 最小化協調
titleSuffix: Azure Application Architecture Guide
description: 將來應用程式服務之間的協調最小化，以達成延展性。
author: MikeWasson
ms.date: 08/30/2018
ms.custom: seojan19
ms.openlocfilehash: ec1a7a3de2be4954b07a87b774f8ae7c2bd1f736
ms.sourcegitcommit: 1f4cdb08fe73b1956e164ad692f792f9f635b409
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2019
ms.locfileid: "54113088"
---
# <a name="minimize-coordination"></a><span data-ttu-id="5c35f-103">最小化協調</span><span class="sxs-lookup"><span data-stu-id="5c35f-103">Minimize coordination</span></span>

## <a name="minimize-coordination-between-application-services-to-achieve-scalability"></a><span data-ttu-id="5c35f-104">將來應用程式服務之間的協調最小化，以達成延展性</span><span class="sxs-lookup"><span data-stu-id="5c35f-104">Minimize coordination between application services to achieve scalability</span></span>

<span data-ttu-id="5c35f-105">大多數雲端應用程式包含多個應用程式服務 &mdash; Web 前端、資料庫、商務程序、報告和分析，依此類推。</span><span class="sxs-lookup"><span data-stu-id="5c35f-105">Most cloud applications consist of multiple application services &mdash; web front ends, databases, business processes, reporting and analysis, and so on.</span></span> <span data-ttu-id="5c35f-106">若要達到延展性和可靠性，這些服務的每個應該在多個執行個體上執行。</span><span class="sxs-lookup"><span data-stu-id="5c35f-106">To achieve scalability and reliability, each of those services should run on multiple instances.</span></span>

<span data-ttu-id="5c35f-107">當兩個執行個體嘗試執行會影響某些共用狀態的並行作業時，會發生什麼事？</span><span class="sxs-lookup"><span data-stu-id="5c35f-107">What happens when two instances try to perform concurrent operations that affect some shared state?</span></span> <span data-ttu-id="5c35f-108">在某些情況下，節點間必須有協調，例如，為了保留 ACID 保證。</span><span class="sxs-lookup"><span data-stu-id="5c35f-108">In some cases, there must be coordination across nodes, for example to preserve ACID guarantees.</span></span> <span data-ttu-id="5c35f-109">在此圖中，`Node2` 正在等候 `Node1` 釋放資料庫鎖定：</span><span class="sxs-lookup"><span data-stu-id="5c35f-109">In this diagram, `Node2` is waiting for `Node1` to release a database lock:</span></span>

![資料庫鎖定圖](./images/database-lock.svg)

<span data-ttu-id="5c35f-111">協調會限制水平調整的好處，並產生瓶頸。</span><span class="sxs-lookup"><span data-stu-id="5c35f-111">Coordination limits the benefits of horizontal scale and creates bottlenecks.</span></span> <span data-ttu-id="5c35f-112">在此範例中，隨著您將應用程式相應放大，並新增更多執行個體，您會看到鎖定爭用增加。</span><span class="sxs-lookup"><span data-stu-id="5c35f-112">In this example, as you scale out the application and add more instances, you'll see increased lock contention.</span></span> <span data-ttu-id="5c35f-113">在最差的情況下，前端執行個體將會花費最多時間等待鎖定。</span><span class="sxs-lookup"><span data-stu-id="5c35f-113">In the worst case, the front-end instances will spend most of their time waiting on locks.</span></span>

<span data-ttu-id="5c35f-114">「正好一次」語意是另一個常見的協調來源。</span><span class="sxs-lookup"><span data-stu-id="5c35f-114">"Exactly once" semantics are another frequent source of coordination.</span></span> <span data-ttu-id="5c35f-115">例如，訂單必須處理正好一次。</span><span class="sxs-lookup"><span data-stu-id="5c35f-115">For example, an order must be processed exactly once.</span></span> <span data-ttu-id="5c35f-116">兩個背景工作正在接聽新的訂單。</span><span class="sxs-lookup"><span data-stu-id="5c35f-116">Two workers are listening for new orders.</span></span> <span data-ttu-id="5c35f-117">`Worker1` 會揀取訂單進行處理。</span><span class="sxs-lookup"><span data-stu-id="5c35f-117">`Worker1` picks up an order for processing.</span></span> <span data-ttu-id="5c35f-118">應用程式必須確定 `Worker2` 不會重複工作，同時，如果 `Worker1` 損毀，不會捨棄訂單。</span><span class="sxs-lookup"><span data-stu-id="5c35f-118">The application must ensure that `Worker2` doesn't duplicate the work, but also if `Worker1` crashes, the order isn't dropped.</span></span>

![協調圖](./images/coordination.svg)

<span data-ttu-id="5c35f-120">您可以使用模式，例如[排程器代理程式監督員][sas-pattern]來在背景工作之間協調，但在此情況下，更好的方法可能是分割工作。</span><span class="sxs-lookup"><span data-stu-id="5c35f-120">You can use a pattern such as [Scheduler Agent Supervisor][sas-pattern] to coordinate between the workers, but in this case a better approach might be to partition the work.</span></span> <span data-ttu-id="5c35f-121">每個背景工作會獲指派特定範圍的訂單 (例如，依計費區域)。</span><span class="sxs-lookup"><span data-stu-id="5c35f-121">Each worker is assigned a certain range of orders (say, by billing region).</span></span> <span data-ttu-id="5c35f-122">如果某個背景工作損毀，新執行個體會揀取前一個執行個體離開的位置，但多個執行個體不會競爭。</span><span class="sxs-lookup"><span data-stu-id="5c35f-122">If a worker crashes, a new instance picks up where the previous instance left off, but multiple instances aren't contending.</span></span>

## <a name="recommendations"></a><span data-ttu-id="5c35f-123">建議</span><span class="sxs-lookup"><span data-stu-id="5c35f-123">Recommendations</span></span>

<span data-ttu-id="5c35f-124">**擁有最終一致性**。</span><span class="sxs-lookup"><span data-stu-id="5c35f-124">**Embrace eventual consistency**.</span></span> <span data-ttu-id="5c35f-125">當資料為分散式時，它會採用協調來強制強式一致性保證。</span><span class="sxs-lookup"><span data-stu-id="5c35f-125">When data is distributed, it takes coordination to enforce strong consistency guarantees.</span></span> <span data-ttu-id="5c35f-126">例如，假設某個作業會更新兩個資料庫。</span><span class="sxs-lookup"><span data-stu-id="5c35f-126">For example, suppose an operation updates two databases.</span></span> <span data-ttu-id="5c35f-127">不要將該作業放入單一交易範圍，最好系統可以提供最終一致性，也許是透過使用[補償交易][compensating-transaction]模式在失敗之後以邏輯方式復原。</span><span class="sxs-lookup"><span data-stu-id="5c35f-127">Instead of putting it into a single transaction scope, it's better if the system can accommodate eventual consistency, perhaps by using the [Compensating Transaction][compensating-transaction] pattern to logically roll back after a failure.</span></span>

<span data-ttu-id="5c35f-128">**使用網域事件來同步處理狀態**。</span><span class="sxs-lookup"><span data-stu-id="5c35f-128">**Use domain events to synchronize state**.</span></span> <span data-ttu-id="5c35f-129">[網域事件][domain-event]是一種事件，當網域中發生具有意義的事情發生時會加以記錄。</span><span class="sxs-lookup"><span data-stu-id="5c35f-129">A [domain event][domain-event] is an event that records when something happens that has significance within the domain.</span></span> <span data-ttu-id="5c35f-130">相關服務可以接聽該事件，而不是使用全域交易來跨多個服務進行協調。</span><span class="sxs-lookup"><span data-stu-id="5c35f-130">Interested services can listen for the event, rather than using a global transaction to coordinate across multiple services.</span></span> <span data-ttu-id="5c35f-131">如果使用此方法，系統必須可以容忍最終一致性 (請參閱上一個項目)。</span><span class="sxs-lookup"><span data-stu-id="5c35f-131">If this approach is used, the system must tolerate eventual consistency (see previous item).</span></span>

<span data-ttu-id="5c35f-132">**考慮 CQRS 和事件來源之類模式**。</span><span class="sxs-lookup"><span data-stu-id="5c35f-132">**Consider patterns such as CQRS and event sourcing**.</span></span> <span data-ttu-id="5c35f-133">這兩種模式可以協助減少讀取工作負載與寫入工作負載之間的競爭。</span><span class="sxs-lookup"><span data-stu-id="5c35f-133">These two patterns can help to reduce contention between read workloads and write workloads.</span></span>

- <span data-ttu-id="5c35f-134">[CQRS 模式][cqrs-pattern] 會將讀取作業從寫入作業中分隔。</span><span class="sxs-lookup"><span data-stu-id="5c35f-134">The [CQRS pattern][cqrs-pattern] separates read operations from write operations.</span></span> <span data-ttu-id="5c35f-135">在某些實作中，讀取資料實際上是與寫入資料分隔的。</span><span class="sxs-lookup"><span data-stu-id="5c35f-135">In some implementations, the read data is physically separated from the write data.</span></span>

- <span data-ttu-id="5c35f-136">在[事件來源模式][event-sourcing]中，會將狀態變更記錄為一系列的事件至僅附加的資料存放區。</span><span class="sxs-lookup"><span data-stu-id="5c35f-136">In the [Event Sourcing pattern][event-sourcing], state changes are recorded as a series of events to an append-only data store.</span></span> <span data-ttu-id="5c35f-137">將事件附加至資料流是不可部分完成的作業，需要最基本的鎖定。</span><span class="sxs-lookup"><span data-stu-id="5c35f-137">Appending an event to the stream is an atomic operation, requiring minimal locking.</span></span>

<span data-ttu-id="5c35f-138">這兩個模式彼此互補。</span><span class="sxs-lookup"><span data-stu-id="5c35f-138">These two patterns complement each other.</span></span> <span data-ttu-id="5c35f-139">如果 CQRS 中的唯寫存放區會使用事件來源，在唯讀存放區可以接聽相同事件，以建立目前狀態可讀取的快照集 (針對查詢最佳化)。</span><span class="sxs-lookup"><span data-stu-id="5c35f-139">If the write-only store in CQRS uses event sourcing, the read-only store can listen for the same events to create a readable snapshot of the current state, optimized for queries.</span></span> <span data-ttu-id="5c35f-140">不過，採用 CQRS 或事件來源之前，請注意此方法的挑戰。</span><span class="sxs-lookup"><span data-stu-id="5c35f-140">Before adopting CQRS or event sourcing, however, be aware of the challenges of this approach.</span></span> <span data-ttu-id="5c35f-141">如需詳細資訊，請參閱 [CQRS 架構樣式][cqrs-style]。</span><span class="sxs-lookup"><span data-stu-id="5c35f-141">For more information, see [CQRS architecture style][cqrs-style].</span></span>

<span data-ttu-id="5c35f-142">**分割資料**。</span><span class="sxs-lookup"><span data-stu-id="5c35f-142">**Partition data**.</span></span>  <span data-ttu-id="5c35f-143">避免將所有的資料放入一個跨許多應用程式服務共用的資料結構描述中。</span><span class="sxs-lookup"><span data-stu-id="5c35f-143">Avoid putting all of your data into one data schema that is shared across many application services.</span></span> <span data-ttu-id="5c35f-144">微服務架構會藉由讓每項服務負責自己的資料存放區來強制此原則。</span><span class="sxs-lookup"><span data-stu-id="5c35f-144">A microservices architecture enforces this principle by making each service responsible for its own data store.</span></span> <span data-ttu-id="5c35f-145">在單一資料庫內，將資料分割為分區可以改善並行存取，因為寫入一個分區的服務不會影響寫入至不同分區的服務。</span><span class="sxs-lookup"><span data-stu-id="5c35f-145">Within a single database, partitioning the data into shards can improve concurrency, because a service writing to one shard does not affect a service writing to a different shard.</span></span>

<span data-ttu-id="5c35f-146">**設計等冪性作業**。</span><span class="sxs-lookup"><span data-stu-id="5c35f-146">**Design idempotent operations**.</span></span> <span data-ttu-id="5c35f-147">如果可能的話，請將作業設計為等冪性。</span><span class="sxs-lookup"><span data-stu-id="5c35f-147">When possible, design operations to be idempotent.</span></span> <span data-ttu-id="5c35f-148">這樣一來，可以使用在至少一次語意處理作業。</span><span class="sxs-lookup"><span data-stu-id="5c35f-148">That way, they can be handled using at-least-once semantics.</span></span> <span data-ttu-id="5c35f-149">例如，您可以將工作項目放在佇列上。</span><span class="sxs-lookup"><span data-stu-id="5c35f-149">For example, you can put work items on a queue.</span></span> <span data-ttu-id="5c35f-150">如果某個背景工作在作業中途損毀，另一個背景工作只需撿取工作項目。</span><span class="sxs-lookup"><span data-stu-id="5c35f-150">If a worker crashes in the middle of an operation, another worker simply picks up the work item.</span></span>

<span data-ttu-id="5c35f-151">**使用非同步平行處理**。</span><span class="sxs-lookup"><span data-stu-id="5c35f-151">**Use asynchronous parallel processing**.</span></span> <span data-ttu-id="5c35f-152">如果作業需要執行以非同步方式 (例如遠端服務呼叫中) 的多個步驟，您可以以平行方式呼叫它們，然後彙總結果。</span><span class="sxs-lookup"><span data-stu-id="5c35f-152">If an operation requires multiple steps that are performed asynchronously (such as remote service calls), you might be able to call them in parallel, and then aggregate the results.</span></span> <span data-ttu-id="5c35f-153">此方法會假設每個步驟不會仰賴於上一個步驟的結果。</span><span class="sxs-lookup"><span data-stu-id="5c35f-153">This approach assumes that each step does not depend on the results of the previous step.</span></span>

<span data-ttu-id="5c35f-154">**可能時使用開放式並行存取**。</span><span class="sxs-lookup"><span data-stu-id="5c35f-154">**Use optimistic concurrency when possible**.</span></span> <span data-ttu-id="5c35f-155">悲觀並行控制會使用資料庫鎖定來防止衝突。</span><span class="sxs-lookup"><span data-stu-id="5c35f-155">Pessimistic concurrency control uses database locks to prevent conflicts.</span></span> <span data-ttu-id="5c35f-156">這會造成效能不佳，並且降低可用性。</span><span class="sxs-lookup"><span data-stu-id="5c35f-156">This can cause poor performance and reduce availability.</span></span> <span data-ttu-id="5c35f-157">利用開放式並行存取控制，每個交易會修改資料的副本或快照集。</span><span class="sxs-lookup"><span data-stu-id="5c35f-157">With optimistic concurrency control, each transaction modifies a copy or snapshot of the data.</span></span> <span data-ttu-id="5c35f-158">認可交易時，資料庫引擎會驗證交易，並拒絕會影響資料庫一致性的任何交易。</span><span class="sxs-lookup"><span data-stu-id="5c35f-158">When the transaction is committed, the database engine validates the transaction and rejects any transactions that would affect database consistency.</span></span>

<span data-ttu-id="5c35f-159">Azure SQL Database 和 SQL Server 透過[快照集隔離][sql-snapshot-isolation]支援開放式並行存取。</span><span class="sxs-lookup"><span data-stu-id="5c35f-159">Azure SQL Database and SQL Server support optimistic concurrency through [snapshot isolation][sql-snapshot-isolation].</span></span> <span data-ttu-id="5c35f-160">某些 Azure 儲存體服務透過使用 Etag (包含 [Azure Cosmos DB][cosmosdb-faq] 和 [Azure 儲存體][storage-concurrency]) 支援開放式並行存取。</span><span class="sxs-lookup"><span data-stu-id="5c35f-160">Some Azure storage services support optimistic concurrency through the use of Etags, including [Azure Cosmos DB][cosmosdb-faq] and [Azure Storage][storage-concurrency].</span></span>

<span data-ttu-id="5c35f-161">**考慮 MapReduce 或其他平行、分散式演算法**。</span><span class="sxs-lookup"><span data-stu-id="5c35f-161">**Consider MapReduce or other parallel, distributed algorithms**.</span></span> <span data-ttu-id="5c35f-162">根據資料和要執行的工作類型，您可以將工作分割成可以由多個平行運作的節點執行的獨立工作。</span><span class="sxs-lookup"><span data-stu-id="5c35f-162">Depending on the data and type of work to be performed, you may be able to split the work into independent tasks that can be performed by multiple nodes working in parallel.</span></span> <span data-ttu-id="5c35f-163">請參閱 [Big Compute 架構樣式][big-compute]。</span><span class="sxs-lookup"><span data-stu-id="5c35f-163">See [Big compute architecture style][big-compute].</span></span>

<span data-ttu-id="5c35f-164">**使用選出領導者進行協調**。</span><span class="sxs-lookup"><span data-stu-id="5c35f-164">**Use leader election for coordination**.</span></span> <span data-ttu-id="5c35f-165">在您要協調作業的情況下，請確定協調器不會成為應用程式中的單一失敗點。</span><span class="sxs-lookup"><span data-stu-id="5c35f-165">In cases where you need to coordinate operations, make sure the coordinator does not become a single point of failure in the application.</span></span> <span data-ttu-id="5c35f-166">使用[選出領導者模式][leader-election]，某個執行個體是任何時間的領導者，並且做為協調器。</span><span class="sxs-lookup"><span data-stu-id="5c35f-166">Using the [Leader Election pattern][leader-election], one instance is the leader at any time, and acts as the coordinator.</span></span> <span data-ttu-id="5c35f-167">如果領導者失敗，會選取新執行個體做為領導者。</span><span class="sxs-lookup"><span data-stu-id="5c35f-167">If the leader fails, a new instance is elected to be the leader.</span></span>

<!-- links -->

[big-compute]: ../architecture-styles/big-compute.md
[compensating-transaction]: ../../patterns/compensating-transaction.md
[cqrs-style]: ../architecture-styles/cqrs.md
[cqrs-pattern]: ../../patterns/cqrs.md
[cosmosdb-faq]: /azure/cosmos-db/faq
[domain-event]: https://martinfowler.com/eaaDev/DomainEvent.html
[event-sourcing]: ../../patterns/event-sourcing.md
[leader-election]: ../../patterns/leader-election.md
[sas-pattern]: ../../patterns/scheduler-agent-supervisor.md
[sql-snapshot-isolation]: /sql/t-sql/statements/set-transaction-isolation-level-transact-sql
[storage-concurrency]: https://azure.microsoft.com/blog/managing-concurrency-in-microsoft-azure-storage-2/