---
title: 微服務的 CI/CD
description: 微服務的持續整合與持續傳遞。
author: MikeWasson
ms.date: 10/23/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: 026d22bb9cfdcb69b1a12294410af748e7af5c39
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/23/2019
ms.locfileid: "54480788"
---
# <a name="designing-microservices-continuous-integration"></a><span data-ttu-id="2cc9b-103">設計微服務：持續整合</span><span class="sxs-lookup"><span data-stu-id="2cc9b-103">Designing microservices: Continuous integration</span></span>

<span data-ttu-id="2cc9b-104">持續整合與持續傳遞 (CI/CD) 是透過微服務獲得成功的關鍵需求。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-104">Continuous integration and continuous delivery (CI/CD) are a key requirement for achieving success with microservices.</span></span> <span data-ttu-id="2cc9b-105">若沒有完善的 CI/CD 程序，您就無法達到微服務所承諾的靈活度。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-105">Without a good CI/CD process, you will not achieve the agility that microservices promise.</span></span> <span data-ttu-id="2cc9b-106">微服務的某些 CI/CD 挑戰是來自於各種服務的多個程式碼基底及各式各樣的建置環境。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-106">Some of the CI/CD challenges for microservices arise from having multiple code bases and heterogenous build environments for the various services.</span></span> <span data-ttu-id="2cc9b-107">本章描述一些挑戰，並建議可解決問題的一些方法。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-107">This chapter describes the challenges and recommends some approaches to the problem.</span></span>

![微服務的 CI/CD 圖](./images/ci-cd.png)

<span data-ttu-id="2cc9b-109">更快速的發行週期是採用微服務架構的最大原因之一。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-109">Faster release cycles are one of the biggest reasons to adopt a microservices architecture.</span></span>

<span data-ttu-id="2cc9b-110">純粹單體式應用程式中有一個建置管線，其輸出是應用程式可執行檔。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-110">In a purely monolithic application, there is a single build pipeline whose output is the application executable.</span></span> <span data-ttu-id="2cc9b-111">所有開發工作都會饋送到此管線中。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-111">All development work feeds into this pipeline.</span></span> <span data-ttu-id="2cc9b-112">如果發現高優先順序的錯誤 (bug)，則必須整合、測試及發行修正程式，這可能會延遲新功能的發行。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-112">If a high-priority bug is found, a fix must be integrated, tested, and published, which can delay the release of new features.</span></span> <span data-ttu-id="2cc9b-113">您的確可藉由擁有構造良好的模組以及使用功能分支來緩和這些問題，進而將程式碼變更的影響降到最低。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-113">It's true that you can mitigate these problems by having well-factored modules and using feature branches to minimize the impact of code changes.</span></span> <span data-ttu-id="2cc9b-114">但隨著應用程式日益複雜，並新增了更多功能，單體的發行程序就變得更加脆弱並可能中斷。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-114">But as the application grows more complex, and more features are added, the release process for a monolith tends to become more brittle and likely to break.</span></span>

<span data-ttu-id="2cc9b-115">根據微服務的原理，絕不會有每個小組都必須排隊的冗長發行序列。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-115">Following the microservices philosophy, there should never be a long release train where every team has to get in line.</span></span> <span data-ttu-id="2cc9b-116">建立服務 "A" 的小組可以隨時發行更新，而不需等待服務 "B" 的變更來進行合併、測試和部署。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-116">The team that builds service "A" can release an update at any time, without waiting for changes in service "B" to be merged, tested, and deployed.</span></span> <span data-ttu-id="2cc9b-117">CI/CD 程序是達成此目的的關鍵。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-117">The CI/CD process is critical to making this possible.</span></span> <span data-ttu-id="2cc9b-118">發行管線必須自動化且高度可靠，才能將部署更新的風險降到最低。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-118">Your release pipeline must be automated and highly reliable, so that the risks of deploying updates are minimized.</span></span> <span data-ttu-id="2cc9b-119">如果您是每天或一天多次地對生產環境進行發行，則退回或服務中斷的狀況必定要非常罕見。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-119">If you are releasing to production daily or multiple times a day, regressions or service disruptions must be very rare.</span></span> <span data-ttu-id="2cc9b-120">同時，如果部署了錯誤的更新，您必須有可靠的方法能快速復原或向前復原至舊版的服務。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-120">At the same time, if a bad update does get deployed, you must have a reliable way to quickly roll back or roll forward to a previous version of a service.</span></span>

![CI/CD 整合型的圖表](./images/cicd-monolith.png)

<span data-ttu-id="2cc9b-122">當我們談論 CI/CD 時，我們實際會談論數個相關程序：持續整合、持續傳遞和持續部署。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-122">When we talk about CI/CD, we are really talking about several related processes: Continuous integration, continuous delivery, and continuous deployment.</span></span>

- <span data-ttu-id="2cc9b-123">持續整合意味著程式碼變更經常會併入主要分支中，使用自動化建置和測試程序來確保主要分支中的程式碼一律具有良好的生產品質。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-123">Continuous integration means that code changes are frequently merged into the main branch, using automated build and test processes to ensure that code in the main branch is always production-quality.</span></span>

- <span data-ttu-id="2cc9b-124">持續傳遞意味著傳遞 CI 程序的程式碼變更會自動發佈到類似生產的環境。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-124">Continuous delivery means that code changes that pass the CI process are automatically published to a production-like environment.</span></span> <span data-ttu-id="2cc9b-125">部署至即時生產環境可能需要手動核准，除此之外皆是自動化作業。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-125">Deployment into the live production environment may require manual approval, but is otherwise automated.</span></span> <span data-ttu-id="2cc9b-126">這麼做的目的是，您的程式碼應該總是「準備好」部署到生產環境。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-126">The goal is that your code should always be *ready* to deploy into production.</span></span>

- <span data-ttu-id="2cc9b-127">持續部署意味著傳遞 CI/CD 程序的程式碼變更會自動發佈到生產環境中。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-127">Continuous deployment means that code changes that pass the CI/CD process are automatically deployed into production.</span></span>

<span data-ttu-id="2cc9b-128">在 Kubernetes 和微服務的內容中，CI 階段涉及建立和測試容器映像，並將這些映像推送到容器登錄。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-128">In the context of Kubernetes and microservices, the CI stage is concerned with building and testing container images, and pushing those images to a container registry.</span></span> <span data-ttu-id="2cc9b-129">在部署階段中，pod 規格會進行更新，以取得最新的生產映像。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-129">In the deployment stage, pod specs are updated to pick up the latest production image.</span></span>

## <a name="challenges"></a><span data-ttu-id="2cc9b-130">挑戰</span><span class="sxs-lookup"><span data-stu-id="2cc9b-130">Challenges</span></span>

- <span data-ttu-id="2cc9b-131">**許多小型獨立的程式碼基底**。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-131">**Many small independent code bases**.</span></span> <span data-ttu-id="2cc9b-132">每個小組需利用自己的建置管線，負責建立自己的服務。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-132">Each team is responsible for building its own service, with its own build pipeline.</span></span> <span data-ttu-id="2cc9b-133">在某些組織中，小組可以使用不同的程式碼存放庫。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-133">In some organizations, teams may use separate code repositories.</span></span> <span data-ttu-id="2cc9b-134">這可能會導致一個情況，就是如何建置系統的知識已散佈到各小組，但組織中沒有人知道如何部署整個應用程式。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-134">This could lead to a situation where the knowledge of how to build the system is spread across teams, and nobody in the organization knows how to deploy the entire application.</span></span> <span data-ttu-id="2cc9b-135">例如，如果您需要快速部署到新的叢集，災害復原案例會發生什麼情況？</span><span class="sxs-lookup"><span data-stu-id="2cc9b-135">For example, what happens in a disaster recovery scenario, if you need to quickly deploy to a new cluster?</span></span>

- <span data-ttu-id="2cc9b-136">**多個語言和架構**。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-136">**Multiple languages and frameworks**.</span></span> <span data-ttu-id="2cc9b-137">如果每個小組都使用自己的各項技術，則可能很難建立適用於整個組織的單一建置程序。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-137">With each team using its own mix of technologies, it can be difficult to create a single build process that works across the organization.</span></span> <span data-ttu-id="2cc9b-138">建置程序必須有足夠的彈性，每個小組才能針對其選擇的語言或架構進行調整。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-138">The build process must be flexible enough that every team can adapt it for their choice of language or framework.</span></span>

- <span data-ttu-id="2cc9b-139">**整合及負載測試**。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-139">**Integration and load testing**.</span></span> <span data-ttu-id="2cc9b-140">如果小組依照自己的步調發行更新，則要設計強固的端對端測試可能具有挑戰性，特別是在服務相依於其他服務時。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-140">With teams releasing updates at their own pace, it can be challenging to design robust end-to-end testing, especially when services have dependencies on other services.</span></span> <span data-ttu-id="2cc9b-141">此外，執行完整生產叢集可能很耗費資源，因此，如果只作為測試用，不太可能每個小組都能夠以生產規模執行自己的完整叢集。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-141">Moreover, running a full production cluster can be expensive, so it's unlikely that every team will be able to run its own full cluster at production scales, just for testing.</span></span>

- <span data-ttu-id="2cc9b-142">**發行管理**。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-142">**Release management**.</span></span> <span data-ttu-id="2cc9b-143">每個小組應該都要能夠將更新部署到生產環境。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-143">Every team should have the ability to deploy an update to production.</span></span> <span data-ttu-id="2cc9b-144">但這不表示每個小組成員都有權限這麼做。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-144">That doesn't mean that every team member has permissions to do so.</span></span> <span data-ttu-id="2cc9b-145">不過，擁有集中的發行管理員角色可能會降低部署的速度。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-145">But having a centralized Release Manager role can reduce the velocity of deployments.</span></span> <span data-ttu-id="2cc9b-146">因此您的 CI/CD 程序愈加自動化和可靠，中央授權的需求就愈低。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-146">The more that your CI/CD process is automated and reliable, the less there should be a need for a central authority.</span></span> <span data-ttu-id="2cc9b-147">儘管如此，您可能使用不同的原則來發行主要功能更新和次要錯誤修正。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-147">That said, you might have different policies for releasing major feature updates versus minor bug fixes.</span></span> <span data-ttu-id="2cc9b-148">分散管理並不表示就是零治理。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-148">Being decentralized does not mean there should be zero governance.</span></span>

- <span data-ttu-id="2cc9b-149">**容器映像版本控制**。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-149">**Container image versioning**.</span></span> <span data-ttu-id="2cc9b-150">在開發和測試週期內，CI/CD 程序將會建立許多容器映像。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-150">During the development and test cycle, the CI/CD process will build many container images.</span></span> <span data-ttu-id="2cc9b-151">其中只有一些映像是發行候選項目，然而只有其中一些發行候選項目會推送到生產環境中。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-151">Only some of those are candidates for release, and then only some of those release candidates will get pushed into production.</span></span> <span data-ttu-id="2cc9b-152">您應該有明確的版本控制策略，好讓您知道哪些映像目前已部署至生產環境，而且可以視需要復原至先前的版本。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-152">You should have a clear versioning strategy, so that you know which images are currently deployed to production, and can roll back to a previous version if necessary.</span></span>

- <span data-ttu-id="2cc9b-153">**服務更新**。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-153">**Service updates**.</span></span> <span data-ttu-id="2cc9b-154">當您將服務更新為新版本時，其不得中斷與其相依的其他服務。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-154">When you update a service to a new version, it shouldn't break other services that depend on it.</span></span> <span data-ttu-id="2cc9b-155">如果您執行輪流更新，則會有一段時間執行混合的版本。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-155">If you do a rolling update, there will be a period of time when a mix of versions is running.</span></span>

<span data-ttu-id="2cc9b-156">這些挑戰反映出主要壓力。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-156">These challenges reflect a fundamental tension.</span></span> <span data-ttu-id="2cc9b-157">一方面，小組必須盡可能獨立運作。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-157">On the one hand, teams need to work as independently as possible.</span></span> <span data-ttu-id="2cc9b-158">另一方面則需要一些協調，以便單一人員執行一些工作，例如執行整合測試、將整個解決方案重新部署到新叢集，或復原錯誤的更新。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-158">On the other hand, some coordination is needed so that a single person can do tasks like running an integration test, redeploying the entire solution to a new cluster, or rolling back a bad update.</span></span>

## <a name="cicd-approaches-for-microservices"></a><span data-ttu-id="2cc9b-159">微服務的 CI/CD 方法</span><span class="sxs-lookup"><span data-stu-id="2cc9b-159">CI/CD approaches for microservices</span></span>

<span data-ttu-id="2cc9b-160">每個服務小組最好能將其建置環境容器化。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-160">It's a good practice for every service team to containerize their build environment.</span></span> <span data-ttu-id="2cc9b-161">此容器應具有為其服務建立程式碼成品所需的所有建置工具。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-161">This container should have all of the build tools necessary to build the code artifacts for their service.</span></span> <span data-ttu-id="2cc9b-162">您通常可以找到您語言和架構的正式 Docker 映像。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-162">Often you can find an official Docker image for your language and framework.</span></span> <span data-ttu-id="2cc9b-163">然後您可以使用 `docker run` 或 Docker Compose 來執行組建。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-163">Then you can use `docker run` or Docker Compose to run the build.</span></span>

<span data-ttu-id="2cc9b-164">使用此方法時，設定新建置環境是件小事。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-164">With this approach, it's trivial to set up a new build environment.</span></span> <span data-ttu-id="2cc9b-165">為您建立程式碼的開發人員並不需要安裝一組建置工具，只要執行容器映像即可。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-165">A developer who wants to build your code doesn't need to install a set of build tools, but simply runs the container image.</span></span> <span data-ttu-id="2cc9b-166">可能更重要的是，您的組建伺服器可設定為執行相同的動作。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-166">Perhaps more importantly, your build server can be configured to do the same thing.</span></span> <span data-ttu-id="2cc9b-167">這樣一來，您就不需要將這些工具安裝到組建伺服器，或管理衝突的工具版本。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-167">That way, you don't need to install those tools onto the build server, or manage conflicting versions of tools.</span></span>

<span data-ttu-id="2cc9b-168">進行本機開發和測試時，可使用 Docker 在容器內執行服務。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-168">For local development and testing, use Docker to run the service inside a container.</span></span> <span data-ttu-id="2cc9b-169">在此程序中，您可能需要執行其他容器，因為這些容器具有本機測試所需的模擬服務或測試資料庫。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-169">As part of this process, you may need to run other containers that have mock services or test databases needed for local testing.</span></span> <span data-ttu-id="2cc9b-170">您可以使用 Docker Compose 來協調這些容器，或使用 Minikube 在本機執行 Kubernetes。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-170">You could use Docker Compose to coordinate these containers, or use Minikube to run Kubernetes locally.</span></span>

<span data-ttu-id="2cc9b-171">備妥程式碼時，發起提取要求並且併入主檔中。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-171">When the code is ready, open a pull request and merge into master.</span></span> <span data-ttu-id="2cc9b-172">這會在組建伺服器上啟動一項作業：</span><span class="sxs-lookup"><span data-stu-id="2cc9b-172">This will start a job on the build server:</span></span>

1. <span data-ttu-id="2cc9b-173">建置程式碼資產。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-173">Build the code assets.</span></span>
2. <span data-ttu-id="2cc9b-174">對程式碼執行單元測試。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-174">Run unit tests against the code.</span></span>
3. <span data-ttu-id="2cc9b-175">建置容器映像。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-175">Build the container image.</span></span>
4. <span data-ttu-id="2cc9b-176">在執行中的容器上執行功能測試，以測試容器映像。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-176">Test the container image by running functional tests on a running container.</span></span> <span data-ttu-id="2cc9b-177">此步驟可以攔截 Docker 檔案中的錯誤，例如錯誤的進入點。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-177">This step can catch errors in the Docker file, such as a bad entry point.</span></span>
5. <span data-ttu-id="2cc9b-178">將映像推送至容器登錄。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-178">Push the image to a container registry.</span></span>
6. <span data-ttu-id="2cc9b-179">使用新的映像來更新測試叢集，以執行整合測試。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-179">Update the test cluster with the new image to run integration tests.</span></span>

<span data-ttu-id="2cc9b-180">當映像準備好移入生產環境時，請視需要更新部署檔案，以指定最新的映像，包括任何 Kubernetes 設定檔。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-180">When the image is ready to go into production, update the deployment files as needed to specify the latest image, including any Kubernetes configuration files.</span></span> <span data-ttu-id="2cc9b-181">然後將更新套用到生產叢集。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-181">Then apply the update to the production cluster.</span></span>

<span data-ttu-id="2cc9b-182">以下是讓部署更可靠的一些建議：</span><span class="sxs-lookup"><span data-stu-id="2cc9b-182">Here are some recommendations for making deployments more reliable:</span></span>

- <span data-ttu-id="2cc9b-183">為部署到叢集 (Pod、服務等等) 的資源，定義容器標籤、版本控制和命名慣例的組織通用慣例。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-183">Define organization-wide conventions for container tags, versioning, and naming conventions for resources deployed to the cluster (pods, services, and so on).</span></span> <span data-ttu-id="2cc9b-184">這可讓您更輕鬆地診斷部署問題。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-184">That can make it easier to diagnose deployment issues.</span></span>

- <span data-ttu-id="2cc9b-185">建立兩個不同的容器登錄，一個用於開發/測試，一個用於生產。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-185">Create two separate container registries, one for development/testing and one for production.</span></span> <span data-ttu-id="2cc9b-186">在您準備好將映像部署到生產環境之前，請勿將它推送到生產登錄。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-186">Don't push an image to the production registry until you're ready to deploy it into production.</span></span> <span data-ttu-id="2cc9b-187">如果您結合這種做法與容器映像的語意版本控制，就能盡量避免意外部署到未獲准發行的版本。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-187">If you combine this practice with semantic versioning of container images, it can reduce the chance of accidentally deploying a version that wasn't approved for release.</span></span>

## <a name="updating-services"></a><span data-ttu-id="2cc9b-188">更新服務</span><span class="sxs-lookup"><span data-stu-id="2cc9b-188">Updating services</span></span>

<span data-ttu-id="2cc9b-189">有各種策略可用來更新已在生產環境中的服務。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-189">There are various strategies for updating a service that's already in production.</span></span> <span data-ttu-id="2cc9b-190">我們在此討論三個常見的選項：輪流更新、藍綠色部署和 Canary 版本。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-190">Here we discuss three common options: Rolling update, blue-green deployment, and canary release.</span></span>

### <a name="rolling-update"></a><span data-ttu-id="2cc9b-191">輪流更新</span><span class="sxs-lookup"><span data-stu-id="2cc9b-191">Rolling update</span></span>

<span data-ttu-id="2cc9b-192">在輪流更新中，您會部署新的服務執行個體，而新的執行個體會立刻開始接收要求。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-192">In a rolling update, you deploy new instances of a service, and the new instances start receiving requests right away.</span></span> <span data-ttu-id="2cc9b-193">隨著新執行個體的出現，系統會移除先前的執行個體。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-193">As the new instances come up, the previous instances are removed.</span></span>

<span data-ttu-id="2cc9b-194">當您更新部署的 pod 規格時，輪流更新是 Kubernetes 中的預設行為。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-194">Rolling updates are the default behavior in Kubernetes when you update the pod spec for a Deployment.</span></span> <span data-ttu-id="2cc9b-195">部署控制器會為已更新的 pod 建立新的 ReplicaSet。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-195">The Deployment controller creates a new ReplicaSet for the updated pods.</span></span> <span data-ttu-id="2cc9b-196">然後它會相應增加新的 ReplicaSet，同時相應減少舊的 ReplicaSet，以維持所需的複本計數。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-196">Then it scales up the new ReplicaSet while scaling down the old one, to maintain the desired replica count.</span></span> <span data-ttu-id="2cc9b-197">在新的 pod 備妥之前，舊的 pod 不會遭到刪除。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-197">It doesn't delete old pods until the new ones are ready.</span></span> <span data-ttu-id="2cc9b-198">Kubernetes 會保存更新歷程記錄，因此您可以視需要使用 kubectl 來復原更新。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-198">Kubernetes keeps a history of the update, so you can use kubectl to roll back an update if needed.</span></span>

<span data-ttu-id="2cc9b-199">如果您的服務執行長時間的啟動工作，您可以定義整備探查。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-199">If your service performs a long startup task, you can define a readiness probe.</span></span> <span data-ttu-id="2cc9b-200">當容器準備好開始接收流量時，就會回報整備探查。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-200">The readiness probe reports when the container is ready to start receiving traffic.</span></span> <span data-ttu-id="2cc9b-201">在探查回報成功之前，Kubernetes 不會將流量傳送至 pod。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-201">Kubernetes won't send traffic to the pod until the probe reports success.</span></span>

<span data-ttu-id="2cc9b-202">輪流更新的其中一項挑戰就是在更新過程中，新舊版本會混合執行及接收流量。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-202">One challenge of rolling updates is that during the update process, a mix of old and new versions are running and receiving traffic.</span></span> <span data-ttu-id="2cc9b-203">在這段期間，所有要求會路由傳送至任一個版本。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-203">During this period, any request could get routed to either of the two versions.</span></span> <span data-ttu-id="2cc9b-204">根據兩個版本之間的變動範圍而定，這或許可能會造成問題。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-204">That may or may not cause problems, depending on the scope of the changes between the two versions.</span></span>

### <a name="blue-green-deployment"></a><span data-ttu-id="2cc9b-205">藍綠部署</span><span class="sxs-lookup"><span data-stu-id="2cc9b-205">Blue-green deployment</span></span>

<span data-ttu-id="2cc9b-206">在藍綠色部署中，您可以一起部署新版本與前一個版本。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-206">In a blue-green deployment, you deploy the new version alongside the previous version.</span></span> <span data-ttu-id="2cc9b-207">在您驗證新版本之後，立刻將所有流量從前一個版本切換到新版本。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-207">After you validate the new version, you switch all traffic at once from the previous version to the new version.</span></span> <span data-ttu-id="2cc9b-208">切換之後，您可監視應用程式是否有任何問題。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-208">After the switch, you monitor the application for any problems.</span></span> <span data-ttu-id="2cc9b-209">如果發生錯誤，您可以換回舊版本。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-209">If something goes wrong, you can swap back to the old version.</span></span> <span data-ttu-id="2cc9b-210">假設沒有任何問題，您可以刪除舊版本。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-210">Assuming there are no problems, you can delete the old version.</span></span>

<span data-ttu-id="2cc9b-211">使用更傳統的單體式或多層式架構應用程式，藍綠部署通常是指佈建兩個相同的環境。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-211">With a more traditional monolithic or N-tier application, blue-green deployment generally meant provisioning two identical environments.</span></span> <span data-ttu-id="2cc9b-212">您會將新版本部署到預備環境，然後將用戶端流量重新導向至預備環境 &mdash; 例如，藉由交換 VIP 位址。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-212">You would deploy the new version to a staging environment, then redirect client traffic to the staging environment &mdash; for example, by swapping VIP addresses.</span></span>

<span data-ttu-id="2cc9b-213">在 Kubernetes 中，您不需佈建個別的叢集來進行藍綠部署。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-213">In Kubernetes, you don't need to provision a separate cluster to do blue-green deployments.</span></span> <span data-ttu-id="2cc9b-214">您反而可以利用選取器。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-214">Instead, you can take advantage of selectors.</span></span> <span data-ttu-id="2cc9b-215">利用新的 pod 規格和一組不同的標籤，建立新的部署資源。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-215">Create a new Deployment resource with a new pod spec and a different set of labels.</span></span> <span data-ttu-id="2cc9b-216">建立此部署，而不需刪除先前的部署，或修改指向它的服務。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-216">Create this deployment, without deleting the previous deployment or modifying the service that points to it.</span></span> <span data-ttu-id="2cc9b-217">當新的 pod 執行時，您可以更新服務的選取器，以符合新的部署。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-217">Once the new pods are running, you can update the service's selector to match the new deployment.</span></span>

<span data-ttu-id="2cc9b-218">藍綠部署的優點是服務可同時切換所有 pod。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-218">An advantage of blue-green deployments is that the service switches all the pods at the same time.</span></span> <span data-ttu-id="2cc9b-219">更新此服務後，所有新的要求都會路由傳送至新的版本。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-219">After the service is updated, all new requests get routed to the new version.</span></span> <span data-ttu-id="2cc9b-220">但有一個缺點，在更新期間您會對服務執行兩倍的 pod 數目 (目前和下一個)。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-220">One drawback is that during the update, you are running twice as many pods for the service (current and next).</span></span> <span data-ttu-id="2cc9b-221">如果 pod 需要大量 CPU 或記憶體資源，您可能需要暫時相應放大叢集，以處理資源耗用。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-221">If the pods require a lot of CPU or memory resources, you may need to scale out the cluster temporarily to handle the resource consumption.</span></span>

### <a name="canary-release"></a><span data-ttu-id="2cc9b-222">Canary 版本</span><span class="sxs-lookup"><span data-stu-id="2cc9b-222">Canary release</span></span>

<span data-ttu-id="2cc9b-223">在 Canary 版本中，您會向少數用戶端推出更新的版本。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-223">In a canary release, you roll out an updated version to a small number of clients.</span></span> <span data-ttu-id="2cc9b-224">然後您會先監視新服務的行為，然後再向所有的用戶端推出該服務。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-224">Then you monitor the behavior of the new service before rolling it out to all clients.</span></span> <span data-ttu-id="2cc9b-225">這可讓您以控制方式進行緩慢推出、觀察實際資料，以及在所有客戶受影響之前找出問題。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-225">This lets you do a slow rollout in a controlled fashion, observe real data, and spot problems before all customers are affected.</span></span>

<span data-ttu-id="2cc9b-226">Canary 版本的管理比藍綠或輪流更新更複雜，因為您必須動態將要求路由傳送到不同的服務版本。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-226">A canary release is more complex to manage than either blue-green or rolling update, because you must dynamically route requests to different versions of the service.</span></span> <span data-ttu-id="2cc9b-227">在 Kubernetes 中，您可以將服務設定為橫跨兩個複本集 (每個版本各一個) 並手動調整複本計數。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-227">In Kubernetes, you can configure a Service to span two replica sets (one for each version) and adjust the replica counts manually.</span></span> <span data-ttu-id="2cc9b-228">不過，此方法會因為 Kubernetes 在 pod 間進行平衡負載的方式而顯得相當粗糙。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-228">However, this approach is rather coarse-grained, because of the way Kubernetes load balances across pods.</span></span> <span data-ttu-id="2cc9b-229">例如，如果總計有十個複本，您只可透過 10% 的增量轉換流量。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-229">For example, if you have a total of ten replicas, you can only shift traffic in 10% increments.</span></span> <span data-ttu-id="2cc9b-230">如果您使用服務網格，則可以使用服務網格路由規則，實作更精緻的 Canary 版本策略。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-230">If you are using a service mesh, you can use the service mesh routing rules to implement a more sophisticated canary release strategy.</span></span> <span data-ttu-id="2cc9b-231">以下是一些可能有所幫助的資源：</span><span class="sxs-lookup"><span data-stu-id="2cc9b-231">Here are some resources that may be helpful:</span></span>

- <span data-ttu-id="2cc9b-232">沒有服務網格的 Kubernetes：[Canary 部署](https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments)</span><span class="sxs-lookup"><span data-stu-id="2cc9b-232">Kubernetes without service mesh: [Canary deployments](https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments)</span></span>
- <span data-ttu-id="2cc9b-233">Linkerd：[動態要求路由](https://linkerd.io/features/routing/)</span><span class="sxs-lookup"><span data-stu-id="2cc9b-233">Linkerd: [Dynamic request routing](https://linkerd.io/features/routing/)</span></span>
- <span data-ttu-id="2cc9b-234">Istio：[使用 Istio 的 Canary 部署](https://istio.io/blog/canary-deployments-using-istio.html)</span><span class="sxs-lookup"><span data-stu-id="2cc9b-234">Istio: [Canary Deployments using Istio](https://istio.io/blog/canary-deployments-using-istio.html)</span></span>

## <a name="conclusion"></a><span data-ttu-id="2cc9b-235">結論</span><span class="sxs-lookup"><span data-stu-id="2cc9b-235">Conclusion</span></span>

<span data-ttu-id="2cc9b-236">近年來，產業經歷大幅變動，從建置「記錄系統」移向建置「協作系統」。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-236">In recent years, there has been a sea change in the industry, a movement from building *systems of record* to building *systems of engagement*.</span></span>

<span data-ttu-id="2cc9b-237">記錄系統是傳統的後台資料管理應用程式。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-237">Systems of record are traditional back-office data management applications.</span></span> <span data-ttu-id="2cc9b-238">這些系統的核心通常有 RDBMS，而這是單一資料來源。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-238">At the heart of these systems there often sits an RDBMS that is the single source of truth.</span></span> <span data-ttu-id="2cc9b-239">「協作系統」一詞出自 Geoffrey Moore 在其 2011 年發表的 Systems of Engagement and the Future of Enterprise IT 論文中。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-239">The term "system of engagement" is credited to Geoffrey Moore, in his 2011 paper *Systems of Engagement and the Future of Enterprise IT*.</span></span> <span data-ttu-id="2cc9b-240">協作系統是著重於溝通和共同作業的應用程式。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-240">Systems of engagement are applications focused on communication and collaboration.</span></span> <span data-ttu-id="2cc9b-241">這類系統可即時聯繫人員。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-241">They connect people in real time.</span></span> <span data-ttu-id="2cc9b-242">必須全天候可供使用。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-242">They must be available 24/7.</span></span> <span data-ttu-id="2cc9b-243">定期引進新功能，且應用程式不需離線。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-243">New features are introduced regularly without taking the application offline.</span></span> <span data-ttu-id="2cc9b-244">因此，使用者的期望更高，且對於非預期的延遲或停機更沒有耐心。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-244">Users expect more and are less patient of unexpected delays or downtime.</span></span>

<span data-ttu-id="2cc9b-245">在取用者領域中，較佳的使用者體驗可能帶來可衡量的商務價值。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-245">In the consumer space, a better user experience can have measurable business value.</span></span> <span data-ttu-id="2cc9b-246">使用者使用應用程式的時間量可能會直接轉換成營收。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-246">The amount of time that a user engages with an application may translate directly into revenue.</span></span> <span data-ttu-id="2cc9b-247">而且在商務系統的領域中，使用者的期望已改變。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-247">And in the realm of business systems, users' expectations have changed.</span></span> <span data-ttu-id="2cc9b-248">如果這些系統致力於促進溝通和共同作業，則必須從取用者面向的應用程式取得其提示。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-248">If these systems aim to foster communication and collaboration, they must take their cue from consumer-facing applications.</span></span>

<span data-ttu-id="2cc9b-249">微服務回應了此不斷變動的情勢。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-249">Microservices are a response to this changing landscape.</span></span> <span data-ttu-id="2cc9b-250">將單體式應用程式分解成鬆散偶合的服務群組，我們可以控制每項服務的發行週期，並能夠頻繁更新，而不需要停機或重大變更。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-250">By decomposing a monolithic application into a group of loosely coupled services, we can control the release cycle of each service, and enable frequent updates without downtime or breaking changes.</span></span> <span data-ttu-id="2cc9b-251">微服務也有助於延展性、失敗隔離和復原。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-251">Microservices also help with scalability, failure isolation, and resiliency.</span></span> <span data-ttu-id="2cc9b-252">同時，雲端平台可自動佈建計算資源、容器即服務，以及事件驅動的無伺服器環境，讓您更輕鬆地建置和執行微服務。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-252">Meanwhile, cloud platforms are making it easier to build and run microservices, with automated provisioning of compute resources, container orchestrators as a service, and event-driven serverless environments.</span></span>

<span data-ttu-id="2cc9b-253">但如我們所見，微服務架構也具有許多挑戰。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-253">But as we've seen, microservices architectures also being a lot of challenges.</span></span> <span data-ttu-id="2cc9b-254">若要成功，您必須從堅實的設計著手。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-254">To succeed, you must start from a solid design.</span></span> <span data-ttu-id="2cc9b-255">您必須在分析網域、選擇技術、建立資料模型、設計 API，以及建立成熟的 DevOps 文化特性時深思熟慮。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-255">You must put careful thought into analyzing the domain, choosing technologies, modeling data, designing APIs, and building a mature DevOps culture.</span></span> <span data-ttu-id="2cc9b-256">我們希望這份指南以及隨附的[參考實作](https://github.com/mspnp/microservices-reference-implementation)，已協助您順利完成旅程。</span><span class="sxs-lookup"><span data-stu-id="2cc9b-256">We hope that this guide, and the accompanying [reference implementation](https://github.com/mspnp/microservices-reference-implementation), has helped to illuminate the journey.</span></span>
