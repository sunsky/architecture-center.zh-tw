---
title: 側車模式
titleSuffix: Cloud Design Patterns
description: 將應用程式的元件部署到個別的處理序或容器，以提供隔離和封裝。
keywords: 設計模式
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 2b0e46a06f7fe47f281f726f73128db1d7dd1067
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/20/2019
ms.locfileid: "58243559"
---
# <a name="sidecar-pattern"></a><span data-ttu-id="9a4db-104">側車模式</span><span class="sxs-lookup"><span data-stu-id="9a4db-104">Sidecar pattern</span></span>

<span data-ttu-id="9a4db-105">將應用程式的元件部署到個別的處理序或容器，以提供隔離和封裝。</span><span class="sxs-lookup"><span data-stu-id="9a4db-105">Deploy components of an application into a separate process or container to provide isolation and encapsulation.</span></span> <span data-ttu-id="9a4db-106">此模式也可讓應用程式由異質元件和技術組成。</span><span class="sxs-lookup"><span data-stu-id="9a4db-106">This pattern can also enable applications to be composed of heterogeneous components and technologies.</span></span>

<span data-ttu-id="9a4db-107">此模式名為「側車」，因為它類似於加裝到機車的「側車」。</span><span class="sxs-lookup"><span data-stu-id="9a4db-107">This pattern is named *Sidecar* because it resembles a sidecar attached to a motorcycle.</span></span> <span data-ttu-id="9a4db-108">在此模式中，側車會附加至父系應用程式，並為應用程式提供支援的功能。</span><span class="sxs-lookup"><span data-stu-id="9a4db-108">In the pattern, the sidecar is attached to a parent application and provides supporting features for the application.</span></span> <span data-ttu-id="9a4db-109">側車也會共用與父系應用程式相同的生命週期，隨著父系應用程式而建立和停用。</span><span class="sxs-lookup"><span data-stu-id="9a4db-109">The sidecar also shares the same lifecycle as the parent application, being created and retired alongside the parent.</span></span> <span data-ttu-id="9a4db-110">側車模式有時稱為 Sidekick (好友) 模式，是一種分解模式。</span><span class="sxs-lookup"><span data-stu-id="9a4db-110">The sidecar pattern is sometimes referred to as the sidekick pattern and is a decomposition pattern.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="9a4db-111">內容和問題</span><span class="sxs-lookup"><span data-stu-id="9a4db-111">Context and Problem</span></span>

<span data-ttu-id="9a4db-112">應用程式和服務通常需要相關的功能，例如監視、記錄、設定及網路服務。</span><span class="sxs-lookup"><span data-stu-id="9a4db-112">Applications and services often require related functionality, such as monitoring, logging, configuration, and networking services.</span></span> <span data-ttu-id="9a4db-113">這些週邊工作可實作為個別的元件或服務。</span><span class="sxs-lookup"><span data-stu-id="9a4db-113">These peripheral tasks can be implemented as separate components or services.</span></span>

<span data-ttu-id="9a4db-114">如果它們會緊密整合到應用程式，就可以和應用程式在相同的處理序中執行，以便有效率地使用共用資源。</span><span class="sxs-lookup"><span data-stu-id="9a4db-114">If they are tightly integrated into the application, they can run in the same process as the application, making efficient use of shared resources.</span></span> <span data-ttu-id="9a4db-115">不過，這也表示它們未隔離，若這些元件的其中一個中斷，便可能會影響其他元件或整個應用程式。</span><span class="sxs-lookup"><span data-stu-id="9a4db-115">However, this also means they are not well isolated, and an outage in one of these components can affect other components or the entire application.</span></span> <span data-ttu-id="9a4db-116">此外，它們通常需使用和父系應用程式相同的語言來實作。</span><span class="sxs-lookup"><span data-stu-id="9a4db-116">Also, they usually need to be implemented using the same language as the parent application.</span></span> <span data-ttu-id="9a4db-117">因此，元件和應用程式彼此具有緊密的相依關係。</span><span class="sxs-lookup"><span data-stu-id="9a4db-117">As a result, the component and the application have close interdependence on each other.</span></span>

<span data-ttu-id="9a4db-118">如果應用程式分解成多個服務，每個服務就能使用不同的語言和技術來建置。</span><span class="sxs-lookup"><span data-stu-id="9a4db-118">If the application is decomposed into services, then each service can be built using different languages and technologies.</span></span> <span data-ttu-id="9a4db-119">雖然這可提供更多彈性，但也表示每個元件有自己的相依性，而且需要特定語言程式庫來存取基礎平台和與父系應用程式共用的所有資源。</span><span class="sxs-lookup"><span data-stu-id="9a4db-119">While this gives more flexibility, it means that each component has its own dependencies and requires language-specific libraries to access the underlying platform and any resources shared with the parent application.</span></span> <span data-ttu-id="9a4db-120">此外，將這些功能部署為個別的服務，可能會增加應用程式延遲。</span><span class="sxs-lookup"><span data-stu-id="9a4db-120">In addition, deploying these features as separate services can add latency to the application.</span></span> <span data-ttu-id="9a4db-121">管理這些特定語言介面的程式碼和相依性也會大幅提高複雜性，特別是針對裝載、部署和管理等方面。</span><span class="sxs-lookup"><span data-stu-id="9a4db-121">Managing the code and dependencies for these language-specific interfaces can also add considerable complexity, especially for hosting, deployment, and management.</span></span>

## <a name="solution"></a><span data-ttu-id="9a4db-122">解決方法</span><span class="sxs-lookup"><span data-stu-id="9a4db-122">Solution</span></span>

<span data-ttu-id="9a4db-123">將一組相關工作與主要應用程式放在相同位置，但將它們放在自己的處理序或容器內，可為平台服務提供跨語言的同質介面。</span><span class="sxs-lookup"><span data-stu-id="9a4db-123">Co-locate a cohesive set of tasks with the primary application, but place them inside their own process or container, providing a homogeneous interface for platform services across languages.</span></span>

![側車模式圖](./_images/sidecar.png)

<span data-ttu-id="9a4db-125">側車服務不一定是應用程式的一部分，但會連線到應用程式。</span><span class="sxs-lookup"><span data-stu-id="9a4db-125">A sidecar service is not necessarily part of the application, but is connected to it.</span></span> <span data-ttu-id="9a4db-126">它會隨著父系應用程式移動。</span><span class="sxs-lookup"><span data-stu-id="9a4db-126">It goes wherever the parent application goes.</span></span> <span data-ttu-id="9a4db-127">側車是隨主要應用程式部署的支援處理序或服務。</span><span class="sxs-lookup"><span data-stu-id="9a4db-127">Sidecars are supporting processes or services that are deployed with the primary application.</span></span> <span data-ttu-id="9a4db-128">側車是加裝在機車上，每部機車都能有專屬的側車。</span><span class="sxs-lookup"><span data-stu-id="9a4db-128">On a motorcycle, the sidecar is attached to one motorcycle, and each motorcycle can have its own sidecar.</span></span> <span data-ttu-id="9a4db-129">同樣地，側車服務和其父系應用程式有相同的生命週期。</span><span class="sxs-lookup"><span data-stu-id="9a4db-129">In the same way, a sidecar service shares the fate of its parent application.</span></span> <span data-ttu-id="9a4db-130">對於應用程式的每個執行個體，側車的執行個體會隨之部署並裝載。</span><span class="sxs-lookup"><span data-stu-id="9a4db-130">For each instance of the application, an instance of the sidecar is deployed and hosted alongside it.</span></span>

<span data-ttu-id="9a4db-131">使用側車模式的優點包括：</span><span class="sxs-lookup"><span data-stu-id="9a4db-131">Advantages of using a sidecar pattern include:</span></span>

- <span data-ttu-id="9a4db-132">側車的執行階段環境和程式設計語言與主要應用程式是分開的，因此不需針對每一種語言開發一個側車。</span><span class="sxs-lookup"><span data-stu-id="9a4db-132">A sidecar is independent from its primary application in terms of runtime environment and programming language, so you don't need to develop one sidecar per language.</span></span>

- <span data-ttu-id="9a4db-133">側車可以和主要應用程式存取相同的資源。</span><span class="sxs-lookup"><span data-stu-id="9a4db-133">The sidecar can access the same resources as the primary application.</span></span> <span data-ttu-id="9a4db-134">例如，側車可以監視側車和主要應用程式所使用的系統資源。</span><span class="sxs-lookup"><span data-stu-id="9a4db-134">For example, a sidecar can monitor system resources used by both the sidecar and the primary application.</span></span>

- <span data-ttu-id="9a4db-135">因為側車鄰近主要應用程式，當兩者之間進行通訊時，沒有明顯的延遲。</span><span class="sxs-lookup"><span data-stu-id="9a4db-135">Because of its proximity to the primary application, there’s no significant latency when communicating between them.</span></span>

- <span data-ttu-id="9a4db-136">即使應用程式不提供擴充性機制，您也可以在和主要應用程式相同的主機或子容器中將側車附加為處理序，以擴充應用程式功能。</span><span class="sxs-lookup"><span data-stu-id="9a4db-136">Even for applications that don’t provide an extensibility mechanism, you can use a sidecar to extend functionality by attaching it as own process in the same host or sub-container as the primary application.</span></span>

<span data-ttu-id="9a4db-137">側車模式通常與容器搭配使用，因而稱為側車容器或 Sidekick 容器。</span><span class="sxs-lookup"><span data-stu-id="9a4db-137">The sidecar pattern is often used with containers and referred to as a sidecar container or sidekick container.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="9a4db-138">問題和考量</span><span class="sxs-lookup"><span data-stu-id="9a4db-138">Issues and Considerations</span></span>

- <span data-ttu-id="9a4db-139">請考慮將用來部署服務、處理序或容器的部署和封裝格式。</span><span class="sxs-lookup"><span data-stu-id="9a4db-139">Consider the deployment and packaging format you will use to deploy services, processes, or containers.</span></span> <span data-ttu-id="9a4db-140">容器特別適合側車模式。</span><span class="sxs-lookup"><span data-stu-id="9a4db-140">Containers are particularly well suited to the sidecar pattern.</span></span>
- <span data-ttu-id="9a4db-141">在設計側車服務時，請小心決定處理序間通訊機制。</span><span class="sxs-lookup"><span data-stu-id="9a4db-141">When designing a sidecar service, carefully decide on the interprocess communication mechanism.</span></span> <span data-ttu-id="9a4db-142">除非無法滿足效能需求，否則請嘗試使用不受限於特定語言或架構的技術。</span><span class="sxs-lookup"><span data-stu-id="9a4db-142">Try to use language- or framework-agnostic technologies unless performance requirements make that impractical.</span></span>
- <span data-ttu-id="9a4db-143">將功能放入側車之前，請考慮改用個別服務或更傳統的精靈是否會更好。</span><span class="sxs-lookup"><span data-stu-id="9a4db-143">Before putting functionality into a sidecar, consider whether it would work better as a separate service or a more traditional daemon.</span></span>
- <span data-ttu-id="9a4db-144">也請考慮功能是否可實作為程式庫，或使用傳統的擴充機制來實作。</span><span class="sxs-lookup"><span data-stu-id="9a4db-144">Also consider whether the functionality could be implemented as a library or using a traditional extension mechanism.</span></span> <span data-ttu-id="9a4db-145">特定語言程式庫可能有更深層的整合和較少的網路額外負荷。</span><span class="sxs-lookup"><span data-stu-id="9a4db-145">Language-specific libraries may have a deeper level of integration and less network overhead.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="9a4db-146">使用此模式的時機</span><span class="sxs-lookup"><span data-stu-id="9a4db-146">When to Use this Pattern</span></span>

<span data-ttu-id="9a4db-147">使用此模式的時機包括：</span><span class="sxs-lookup"><span data-stu-id="9a4db-147">Use this pattern when:</span></span>

- <span data-ttu-id="9a4db-148">您的主要應用程式使用一組異質的語言和架構。</span><span class="sxs-lookup"><span data-stu-id="9a4db-148">Your primary application uses a heterogeneous set of languages and frameworks.</span></span> <span data-ttu-id="9a4db-149">位於側車服務中的元件，可供使用不同架構以不同語言撰寫的應用程式使用。</span><span class="sxs-lookup"><span data-stu-id="9a4db-149">A component located in a sidecar service can be consumed by applications written in different languages using different frameworks.</span></span>
- <span data-ttu-id="9a4db-150">元件由遠端團隊或不同的組織所擁有。</span><span class="sxs-lookup"><span data-stu-id="9a4db-150">A component is owned by a remote team or a different organization.</span></span>
- <span data-ttu-id="9a4db-151">元件或功能必須位於和應用程式相同的主機</span><span class="sxs-lookup"><span data-stu-id="9a4db-151">A component or feature must be co-located on the same host as the application</span></span>
- <span data-ttu-id="9a4db-152">您需要會與主要應用程式共用整個生命週期的服務，但服務可獨立更新。</span><span class="sxs-lookup"><span data-stu-id="9a4db-152">You need a service that shares the overall lifecycle of your main application, but can be independently updated.</span></span>
- <span data-ttu-id="9a4db-153">您需要對特定資源或元件有更細微的資源限制控制。</span><span class="sxs-lookup"><span data-stu-id="9a4db-153">You need fine-grained control over resource limits for a particular resource or component.</span></span> <span data-ttu-id="9a4db-154">例如，您可能要限制特定元件所使用的記憶體數量。</span><span class="sxs-lookup"><span data-stu-id="9a4db-154">For example, you may want to restrict the amount of memory a specific component uses.</span></span> <span data-ttu-id="9a4db-155">您可以將元件部署為側車，並以獨立於主要應用程式的方式管理記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="9a4db-155">You can deploy the component as a sidecar and manage memory usage independently of the main application.</span></span>

<span data-ttu-id="9a4db-156">此模式可能不適合下列時機︰</span><span class="sxs-lookup"><span data-stu-id="9a4db-156">This pattern may not be suitable:</span></span>

- <span data-ttu-id="9a4db-157">處理序間通訊需要最佳化時。</span><span class="sxs-lookup"><span data-stu-id="9a4db-157">When interprocess communication needs to be optimized.</span></span> <span data-ttu-id="9a4db-158">父系應用程式與側車服務之間的通訊包含一些額外負荷，尤其是呼叫中的延遲。</span><span class="sxs-lookup"><span data-stu-id="9a4db-158">Communication between a parent application and sidecar services includes some overhead, notably latency in the calls.</span></span> <span data-ttu-id="9a4db-159">這可能不是對話式介面可接受的。</span><span class="sxs-lookup"><span data-stu-id="9a4db-159">This may not be an acceptable trade-off for chatty interfaces.</span></span>
- <span data-ttu-id="9a4db-160">對小型應用程式而言，並不值得為了隔離的優點而付出為每個執行個體部署側車服務的資源成本。</span><span class="sxs-lookup"><span data-stu-id="9a4db-160">For small applications where the resource cost of deploying a sidecar service for each instance is not worth the advantage of isolation.</span></span>
- <span data-ttu-id="9a4db-161">當服務必須以不同於或獨立於主要應用程式的方式調整時。</span><span class="sxs-lookup"><span data-stu-id="9a4db-161">When the service needs to scale differently than or independently from the main applications.</span></span> <span data-ttu-id="9a4db-162">如果是這樣，可能比較適合將功能部署為個別服務。</span><span class="sxs-lookup"><span data-stu-id="9a4db-162">If so, it may be better to deploy the feature as a separate service.</span></span>

## <a name="example"></a><span data-ttu-id="9a4db-163">範例</span><span class="sxs-lookup"><span data-stu-id="9a4db-163">Example</span></span>

<span data-ttu-id="9a4db-164">側車模式適用於許多情況。</span><span class="sxs-lookup"><span data-stu-id="9a4db-164">The sidecar pattern is applicable to many scenarios.</span></span> <span data-ttu-id="9a4db-165">一些常見的範例包括：</span><span class="sxs-lookup"><span data-stu-id="9a4db-165">Some common examples:</span></span>

- <span data-ttu-id="9a4db-166">基礎結構 API。</span><span class="sxs-lookup"><span data-stu-id="9a4db-166">Infrastructure API.</span></span> <span data-ttu-id="9a4db-167">基礎結構的開發小組建立連同每個應用程式一起部署的服務 (而不是特定語言的用戶端程式庫)，以存取基礎結構。</span><span class="sxs-lookup"><span data-stu-id="9a4db-167">The infrastructure development team creates a service that's deployed alongside each application, instead of a language-specific client library to access the infrastructure.</span></span> <span data-ttu-id="9a4db-168">服務會以側車模式載入，並為下列基礎結構服務提供通用層：記錄、環境資料、設定存放區、探索、健康狀態檢查和看門狗服務。</span><span class="sxs-lookup"><span data-stu-id="9a4db-168">The service is loaded as a sidecar and provides a common layer for infrastructure services, including logging, environment data, configuration store, discovery, health checks, and watchdog services.</span></span> <span data-ttu-id="9a4db-169">側車也會監視父系應用程式的主機環境和處理序 (或容器)，並將資訊記錄到集中式服務。</span><span class="sxs-lookup"><span data-stu-id="9a4db-169">The sidecar also monitors the parent application's host environment and process (or container) and logs the information to a centralized service.</span></span>
- <span data-ttu-id="9a4db-170">管理 NGINX/HAProxy。</span><span class="sxs-lookup"><span data-stu-id="9a4db-170">Manage NGINX/HAProxy.</span></span> <span data-ttu-id="9a4db-171">連同監視環境狀態的側車服務一起部署 NGINX，然後更新 NGINX 設定檔，並在需要變更狀態時回收處理序。</span><span class="sxs-lookup"><span data-stu-id="9a4db-171">Deploy NGINX with a sidecar service that monitors environment state, then updates the NGINX configuration file and recycles the process when a change in state is needed.</span></span>
- <span data-ttu-id="9a4db-172">Ambassador (外交官) 側車。</span><span class="sxs-lookup"><span data-stu-id="9a4db-172">Ambassador sidecar.</span></span> <span data-ttu-id="9a4db-173">部署[大使](./ambassador.md)服務作為側車。</span><span class="sxs-lookup"><span data-stu-id="9a4db-173">Deploy an [ambassador](./ambassador.md) service as a sidecar.</span></span> <span data-ttu-id="9a4db-174">應用程式會透過 Ambassador 進行呼叫，並由 Ambassador 處理要求記錄、路由、斷路及其他連線相關功能。</span><span class="sxs-lookup"><span data-stu-id="9a4db-174">The application calls through the ambassador, which handles request logging, routing, circuit breaking, and other connectivity related features.</span></span>
- <span data-ttu-id="9a4db-175">卸載 Proxy。</span><span class="sxs-lookup"><span data-stu-id="9a4db-175">Offload proxy.</span></span> <span data-ttu-id="9a4db-176">將 NGINX Proxy 放在 node.js 服務執行個體前端，以處理針對服務提供靜態檔案內容。</span><span class="sxs-lookup"><span data-stu-id="9a4db-176">Place an NGINX proxy in front of a node.js service instance, to handle serving static file content for the service.</span></span>

## <a name="related-guidance"></a><span data-ttu-id="9a4db-177">相關的指引</span><span class="sxs-lookup"><span data-stu-id="9a4db-177">Related guidance</span></span>

- [<span data-ttu-id="9a4db-178">大使模式</span><span class="sxs-lookup"><span data-stu-id="9a4db-178">Ambassador pattern</span></span>](./ambassador.md)
