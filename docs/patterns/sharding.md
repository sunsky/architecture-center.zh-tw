---
title: 分區化模式
titleSuffix: Cloud Design Patterns
description: 將資料存放區分割為一組水平分割或分區。
keywords: 設計模式
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 62c8f5be8975a5c05a9118dccadcebf8717bf0ff
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/20/2019
ms.locfileid: "58248249"
---
# <a name="sharding-pattern"></a><span data-ttu-id="fbf14-104">分區化模式</span><span class="sxs-lookup"><span data-stu-id="fbf14-104">Sharding pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="fbf14-105">將資料存放區分割為一組水平分割或分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-105">Divide a data store into a set of horizontal partitions or shards.</span></span> <span data-ttu-id="fbf14-106">這可改善在儲存及存取大量資料時的延展性。</span><span class="sxs-lookup"><span data-stu-id="fbf14-106">This can improve scalability when storing and accessing large volumes of data.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="fbf14-107">內容和問題</span><span class="sxs-lookup"><span data-stu-id="fbf14-107">Context and problem</span></span>

<span data-ttu-id="fbf14-108">單一伺服器所裝載的資料存放區必須遵守下列限制：</span><span class="sxs-lookup"><span data-stu-id="fbf14-108">A data store hosted by a single server might be subject to the following limitations:</span></span>

- <span data-ttu-id="fbf14-109">**儲存體空間**。</span><span class="sxs-lookup"><span data-stu-id="fbf14-109">**Storage space**.</span></span> <span data-ttu-id="fbf14-110">大規模雲端應用程式的資料存放區預計會包含可能隨著時間大幅增加的大量資料。</span><span class="sxs-lookup"><span data-stu-id="fbf14-110">A data store for a large-scale cloud application is expected to contain a huge volume of data that could increase significantly over time.</span></span> <span data-ttu-id="fbf14-111">伺服器通常只會提供有限數量的磁碟儲存體，但您可以用較大型的磁碟取代現有的磁碟，或隨著資料量成長將更多磁碟新增到機器。</span><span class="sxs-lookup"><span data-stu-id="fbf14-111">A server typically provides only a finite amount of disk storage, but you can replace existing disks with larger ones, or add further disks to a machine as data volumes grow.</span></span> <span data-ttu-id="fbf14-112">不過，系統最終會達到限制，而不可能輕易在指定的伺服器上增加儲存體容量。</span><span class="sxs-lookup"><span data-stu-id="fbf14-112">However, the system will eventually reach a limit where it isn't possible to easily increase the storage capacity on a given server.</span></span>

- <span data-ttu-id="fbf14-113">**計算資源**。</span><span class="sxs-lookup"><span data-stu-id="fbf14-113">**Computing resources**.</span></span> <span data-ttu-id="fbf14-114">需有雲端應用程式，才能支援大量的並行使用者，而每個並行使用者會執行查詢以從資料存放區擷取資訊。</span><span class="sxs-lookup"><span data-stu-id="fbf14-114">A cloud application is required to support a large number of concurrent users, each of which run queries that retrieve information from the data store.</span></span> <span data-ttu-id="fbf14-115">裝載資料存放區的單一伺服器可能無法提供支援此負載所需的運算能力，以致使用者回應時間延長和頻繁發生錯誤，因為嘗試儲存和擷取資料的應用程式逾時。有可能新增記憶體或升級處理器，但系統將會達到限制，而不可能進一步增加計算資源。</span><span class="sxs-lookup"><span data-stu-id="fbf14-115">A single server hosting the data store might not be able to provide the necessary computing power to support this load, resulting in extended response times for users and frequent failures as applications attempting to store and retrieve data time out. It might be possible to add memory or upgrade processors, but the system will reach a limit when it isn't possible to increase the compute resources any further.</span></span>

- <span data-ttu-id="fbf14-116">**網路頻寬**。</span><span class="sxs-lookup"><span data-stu-id="fbf14-116">**Network bandwidth**.</span></span> <span data-ttu-id="fbf14-117">最後，在單一伺服器上執行之資料存放區的效能是由伺服器可以接收要求和傳送回覆的比率控管。</span><span class="sxs-lookup"><span data-stu-id="fbf14-117">Ultimately, the performance of a data store running on a single server is governed by the rate the server can receive requests and send replies.</span></span> <span data-ttu-id="fbf14-118">網路流量可能會超過用來連線到伺服器的網路容量，進而導致要求失敗。</span><span class="sxs-lookup"><span data-stu-id="fbf14-118">It's possible that the volume of network traffic might exceed the capacity of the network used to connect to the server, resulting in failed requests.</span></span>

- <span data-ttu-id="fbf14-119">**地理**。</span><span class="sxs-lookup"><span data-stu-id="fbf14-119">**Geography**.</span></span> <span data-ttu-id="fbf14-120">有可能需要儲存相同區域中的特定使用者為了法律、合規性或效能因素，或為了降低資料存取延遲而產生的資料。</span><span class="sxs-lookup"><span data-stu-id="fbf14-120">It might be necessary to store data generated by specific users in the same region as those users for legal, compliance, or performance reasons, or to reduce latency of data access.</span></span> <span data-ttu-id="fbf14-121">如果使用者散佈於不同的國家或區域，則可能無法將應用程式的整個資料儲存在單一資料存放區中。</span><span class="sxs-lookup"><span data-stu-id="fbf14-121">If the users are dispersed across different countries or regions, it might not be possible to store the entire data for the application in a single data store.</span></span>

<span data-ttu-id="fbf14-122">藉由新增更多容量、處理能力、記憶體和網路連線來進行垂直調整，可以延後其中某些限制的影響，但可能只是暫時的解決方案。</span><span class="sxs-lookup"><span data-stu-id="fbf14-122">Scaling vertically by adding more disk capacity, processing power, memory, and network connections can postpone the effects of some of these limitations, but it's likely to only be a temporary solution.</span></span> <span data-ttu-id="fbf14-123">能夠支援大量使用者和大量資料的商業雲端應用程式，必須能夠幾乎無限期地調整，所以垂直調整不一定是最佳的解決方案。</span><span class="sxs-lookup"><span data-stu-id="fbf14-123">A commercial cloud application capable of supporting large numbers of users and high volumes of data must be able to scale almost indefinitely, so vertical scaling isn't necessarily the best solution.</span></span>

## <a name="solution"></a><span data-ttu-id="fbf14-124">解決方法</span><span class="sxs-lookup"><span data-stu-id="fbf14-124">Solution</span></span>

<span data-ttu-id="fbf14-125">將資料存放區分割為水平分割區或分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-125">Divide the data store into horizontal partitions or shards.</span></span> <span data-ttu-id="fbf14-126">每個分區具有相同的結構描述，但會保存自己的相異資料子集。</span><span class="sxs-lookup"><span data-stu-id="fbf14-126">Each shard has the same schema, but holds its own distinct subset of the data.</span></span> <span data-ttu-id="fbf14-127">分區本身就是資料存放區 (它可以包含各類型實體的資料)，其在伺服器上當作儲存體節點執行。</span><span class="sxs-lookup"><span data-stu-id="fbf14-127">A shard is a data store in its own right (it can contain the data for many entities of different types), running on a server acting as a storage node.</span></span>

<span data-ttu-id="fbf14-128">此模式具有下列優點：</span><span class="sxs-lookup"><span data-stu-id="fbf14-128">This pattern has the following benefits:</span></span>

- <span data-ttu-id="fbf14-129">藉由新增在其他儲存體節點上執行的更多分區，即可相應放大系統。</span><span class="sxs-lookup"><span data-stu-id="fbf14-129">You can scale the system out by adding further shards running on additional storage nodes.</span></span>

- <span data-ttu-id="fbf14-130">系統可以使用現成的硬體，而不是特殊且昂貴的電腦作為每個儲存體節點。</span><span class="sxs-lookup"><span data-stu-id="fbf14-130">A system can use off-the-shelf hardware rather than specialized and expensive computers for each storage node.</span></span>

- <span data-ttu-id="fbf14-131">您可以透過平衡分區的工作負載，減少爭用情況並改善效能。</span><span class="sxs-lookup"><span data-stu-id="fbf14-131">You can reduce contention and improve performance by balancing the workload across shards.</span></span>

- <span data-ttu-id="fbf14-132">在雲端，分區實體可以位於接近將存取資料的使用者。</span><span class="sxs-lookup"><span data-stu-id="fbf14-132">In the cloud, shards can be located physically close to the users that'll access the data.</span></span>

<span data-ttu-id="fbf14-133">將資料存放區分割成多個分區時，請決定每個分區應放入哪些資料。</span><span class="sxs-lookup"><span data-stu-id="fbf14-133">When dividing a data store up into shards, decide which data should be placed in each shard.</span></span> <span data-ttu-id="fbf14-134">分區包含的項目通常落在由資料的一或多個屬性所決定的指定範圍內。</span><span class="sxs-lookup"><span data-stu-id="fbf14-134">A shard typically contains items that fall within a specified range determined by one or more attributes of the data.</span></span> <span data-ttu-id="fbf14-135">這些屬性會形成分區化引鍵 (有時稱為分割區索引鍵)。</span><span class="sxs-lookup"><span data-stu-id="fbf14-135">These attributes form the shard key (sometimes referred to as the partition key).</span></span> <span data-ttu-id="fbf14-136">分區索引鍵應該是靜態的。</span><span class="sxs-lookup"><span data-stu-id="fbf14-136">The shard key should be static.</span></span> <span data-ttu-id="fbf14-137">它不該以可能變更的資料為基礎。</span><span class="sxs-lookup"><span data-stu-id="fbf14-137">It shouldn't be based on data that might change.</span></span>

<span data-ttu-id="fbf14-138">分區化實際上會組織資料。</span><span class="sxs-lookup"><span data-stu-id="fbf14-138">Sharding physically organizes the data.</span></span> <span data-ttu-id="fbf14-139">當應用程式儲存和擷取資料時，分區化邏輯會將應用程式導向至適當的分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-139">When an application stores and retrieves data, the sharding logic directs the application to the appropriate shard.</span></span> <span data-ttu-id="fbf14-140">此分區化邏輯可在應用程式中當作資料存取程式碼的一部分來實作，而如果它明確支援分區化，則可能由資料儲存系統來實作。</span><span class="sxs-lookup"><span data-stu-id="fbf14-140">This sharding logic can be implemented as part of the data access code in the application, or it could be implemented by the data storage system if it transparently supports sharding.</span></span>

<span data-ttu-id="fbf14-141">提取分區化邏輯中資料的實體位置，可提供哪些分區包含哪些資料的高階控制。</span><span class="sxs-lookup"><span data-stu-id="fbf14-141">Abstracting the physical location of the data in the sharding logic provides a high level of control over which shards contain which data.</span></span> <span data-ttu-id="fbf14-142">如果分區中的資料稍後需要重新分配 (例如，分區變得不平衡時)，這也可讓資料在分區之間移轉，而不需修改應用程式的商務邏輯。</span><span class="sxs-lookup"><span data-stu-id="fbf14-142">It also enables data to migrate between shards without reworking the business logic of an application if the data in the shards need to be redistributed later (for example, if the shards become unbalanced).</span></span> <span data-ttu-id="fbf14-143">代價是在擷取每個資料項目時判斷其位置所需的額外資料存取負荷。</span><span class="sxs-lookup"><span data-stu-id="fbf14-143">The tradeoff is the additional data access overhead required in determining the location of each data item as it's retrieved.</span></span>

<span data-ttu-id="fbf14-144">若要確保最佳效能和延展性，務必以適合應用程式所執行之查詢類型的方式將資料分割。</span><span class="sxs-lookup"><span data-stu-id="fbf14-144">To ensure optimal performance and scalability, it's important to split the data in a way that's appropriate for the types of queries that the application performs.</span></span> <span data-ttu-id="fbf14-145">在許多情況下，分區化配置不可能完全符合每個查詢的需求。</span><span class="sxs-lookup"><span data-stu-id="fbf14-145">In many cases, it's unlikely that the sharding scheme will exactly match the requirements of every query.</span></span> <span data-ttu-id="fbf14-146">例如，在多租用戶系統中，應用程式可能需要使用租用戶識別碼來擷取租用戶資料，但也可能需要根據其他屬性 (例如租用戶的名稱或位置) 來查閱此資料。</span><span class="sxs-lookup"><span data-stu-id="fbf14-146">For example, in a multi-tenant system an application might need to retrieve tenant data using the tenant ID, but it might also need to look up this data based on some other attribute such as the tenant’s name or location.</span></span> <span data-ttu-id="fbf14-147">若要處理這些情況，請使用支援最常執行之查詢的分區化索引鍵來實作分區化策略。</span><span class="sxs-lookup"><span data-stu-id="fbf14-147">To handle these situations, implement a sharding strategy with a shard key that supports the most commonly performed queries.</span></span>

<span data-ttu-id="fbf14-148">如果查詢使用屬性值組合來定期擷取資料，您有可能將屬性連結在一起來定義複合分區索引鍵。</span><span class="sxs-lookup"><span data-stu-id="fbf14-148">If queries regularly retrieve data using a combination of attribute values, you can likely define a composite shard key by linking attributes together.</span></span> <span data-ttu-id="fbf14-149">或者，使用[索引表格](./index-table.md)等模式，根據分區索引鍵所未涵蓋的屬性來提供資料快速查閱。</span><span class="sxs-lookup"><span data-stu-id="fbf14-149">Alternatively, use a pattern such as [Index Table](./index-table.md) to provide fast lookup to data based on attributes that aren't covered by the shard key.</span></span>

## <a name="sharding-strategies"></a><span data-ttu-id="fbf14-150">分區化策略</span><span class="sxs-lookup"><span data-stu-id="fbf14-150">Sharding strategies</span></span>

<span data-ttu-id="fbf14-151">選取分區索引鍵並決定如何將資料分散於各分區時經常使用三個策略。</span><span class="sxs-lookup"><span data-stu-id="fbf14-151">Three strategies are commonly used when selecting the shard key and deciding how to distribute data across shards.</span></span> <span data-ttu-id="fbf14-152">請注意，分區與裝載它們的伺服器之間不一定是一對一對應關係&mdash;單一伺服器可以裝載多個分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-152">Note that there doesn't have to be a one-to-one correspondence between shards and the servers that host them&mdash;a single server can host multiple shards.</span></span> <span data-ttu-id="fbf14-153">策略如下：</span><span class="sxs-lookup"><span data-stu-id="fbf14-153">The strategies are:</span></span>

<span data-ttu-id="fbf14-154">**查閱策略**。</span><span class="sxs-lookup"><span data-stu-id="fbf14-154">**The Lookup strategy**.</span></span> <span data-ttu-id="fbf14-155">在此策略中，分區化邏輯會實作以下對應：使用分區索引鍵將資料要求傳送至包含該資料的分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-155">In this strategy the sharding logic implements a map that routes a request for data to the shard that contains that data using the shard key.</span></span> <span data-ttu-id="fbf14-156">在多租用戶應用程式中，可使用租用戶識別碼作為分區索引鍵，將租用戶的所有資料一起儲存在一個分區中。</span><span class="sxs-lookup"><span data-stu-id="fbf14-156">In a multi-tenant application all the data for a tenant might be stored together in a shard using the tenant ID as the shard key.</span></span> <span data-ttu-id="fbf14-157">多個租用戶可以共用相同的分區，但是單一租用戶的資料將不會分散於多個分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-157">Multiple tenants might share the same shard, but the data for a single tenant won't be spread across multiple shards.</span></span> <span data-ttu-id="fbf14-158">下圖說明如何根據租用戶識別碼將租用戶資料分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-158">The figure illustrates sharding tenant data based on tenant IDs.</span></span>

   ![圖 1：根據租用戶識別碼將租用戶資料分區](./_images/sharding-tenant.png)

<span data-ttu-id="fbf14-160">分區索引鍵與實體儲存體之間的對應可以實體分區為基礎，其中每個分區索引鍵都會對應至一個實體分割區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-160">The mapping between the shard key and the physical storage can be based on physical shards where each shard key maps to a physical partition.</span></span> <span data-ttu-id="fbf14-161">此外，虛擬資料分割是較有彈性的重新平衡分區技巧，其中的分區索引鍵會對應至相同數目的虛擬分區，然後再對應至較少的實體資料分割。</span><span class="sxs-lookup"><span data-stu-id="fbf14-161">Alternatively, a more flexible technique for rebalancing shards is virtual partitioning, where shard keys map to the same number of virtual shards, which in turn map to fewer physical partitions.</span></span> <span data-ttu-id="fbf14-162">採用這種方法，應用程式可使用參照虛擬分區的分區索引鍵來找出資料，而系統會明確將虛擬分區對應至實體分割區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-162">In this approach, an application locates data using a shard key that refers to a virtual shard, and the system transparently maps virtual shards to physical partitions.</span></span> <span data-ttu-id="fbf14-163">不需將應用程式程式碼修改成使用一組不同的分區索引鍵，即可變更虛擬分區和實體分割區之間的對應。</span><span class="sxs-lookup"><span data-stu-id="fbf14-163">The mapping between a virtual shard and a physical partition can change without requiring the application code be modified to use a different set of shard keys.</span></span>

<span data-ttu-id="fbf14-164">**範圍策略**。</span><span class="sxs-lookup"><span data-stu-id="fbf14-164">**The Range strategy**.</span></span> <span data-ttu-id="fbf14-165">此策略會將相關項目一起分在相同的分區中，並依照分區索引鍵進行排序&mdash;分區索引鍵是連續的。</span><span class="sxs-lookup"><span data-stu-id="fbf14-165">This strategy groups related items together in the same shard, and orders them by shard key&mdash;the shard keys are sequential.</span></span> <span data-ttu-id="fbf14-166">對於經常使用範圍查詢 (針對落在指定範圍內的分區索引鍵傳回一組資料項目的查詢) 來擷取項目集的應用程式而言，這個策略很實用。</span><span class="sxs-lookup"><span data-stu-id="fbf14-166">It's useful for applications that frequently retrieve sets of items using range queries (queries that return a set of data items for a shard key that falls within a given range).</span></span> <span data-ttu-id="fbf14-167">例如，如果應用程式需要定期尋找在特定月份下單的所有訂單，若一個月份的所有訂單依照日期和時間順序儲存在相同的分區中，即可更快速地擷取此資料。</span><span class="sxs-lookup"><span data-stu-id="fbf14-167">For example, if an application regularly needs to find all orders placed in a given month, this data can be retrieved more quickly if all orders for a month are stored in date and time order in the same shard.</span></span> <span data-ttu-id="fbf14-168">如果每筆訂單儲存在不同的分區中，他們必須藉由執行大量的點查詢 (可傳回單一資料項目的查詢) 來個別擷取。</span><span class="sxs-lookup"><span data-stu-id="fbf14-168">If each order was stored in a different shard, they'd have to be fetched individually by performing a large number of point queries (queries that return a single data item).</span></span> <span data-ttu-id="fbf14-169">下圖說明如何在分區中儲存連續的資料集 (範圍)。</span><span class="sxs-lookup"><span data-stu-id="fbf14-169">The next figure illustrates storing sequential sets (ranges) of data in shard.</span></span>

   ![圖 2 - 在分區中儲存連續的資料集 (範圍)](./_images/sharding-sequential-sets.png)

<span data-ttu-id="fbf14-171">在此範例中，分區索引鍵是複合索引鍵，其中包含訂單月份 (作為最重要元素)，後面接著訂單日期和時間。</span><span class="sxs-lookup"><span data-stu-id="fbf14-171">In this example, the shard key is a composite key containing the order month as the most significant element, followed by the order day and the time.</span></span> <span data-ttu-id="fbf14-172">建立新訂單並將其新增到分區時，訂單資料會自然排序。</span><span class="sxs-lookup"><span data-stu-id="fbf14-172">The data for orders is naturally sorted when new orders are created and added to a shard.</span></span> <span data-ttu-id="fbf14-173">某些資料存放區支援兩個部分的分區索引鍵：包含可識別分區的分割區索引鍵元素，以及可唯一識別分區中項目的資料列索引鍵。</span><span class="sxs-lookup"><span data-stu-id="fbf14-173">Some data stores support two-part shard keys containing a partition key element that identifies the shard and a row key that uniquely identifies an item in the shard.</span></span> <span data-ttu-id="fbf14-174">資料通常會依照資料列索引鍵順序保存在分區中。</span><span class="sxs-lookup"><span data-stu-id="fbf14-174">Data is usually held in row key order in the shard.</span></span> <span data-ttu-id="fbf14-175">受限於範圍查詢而且需要分組在一起的項目，可以使用具有相同分割區索引鍵值，但其資料列索引鍵值是唯一的分區索引鍵。</span><span class="sxs-lookup"><span data-stu-id="fbf14-175">Items that are subject to range queries and need to be grouped together can use a shard key that has the same value for the partition key but a unique value for the row key.</span></span>

<span data-ttu-id="fbf14-176">**雜湊策略**。</span><span class="sxs-lookup"><span data-stu-id="fbf14-176">**The Hash strategy**.</span></span> <span data-ttu-id="fbf14-177">此策略的目的在於降低熱點 (接收不當負載量的分區) 的可能性。</span><span class="sxs-lookup"><span data-stu-id="fbf14-177">The purpose of this strategy is to reduce the chance of hotspots (shards that receive a disproportionate amount of load).</span></span> <span data-ttu-id="fbf14-178">它會將資料分散於各分區，方法是讓每個分區大小之間取得平衡，且每個分區的負載達到平均。</span><span class="sxs-lookup"><span data-stu-id="fbf14-178">It distributes the data across the shards in a way that achieves a balance between the size of each shard and the average load that each shard will encounter.</span></span> <span data-ttu-id="fbf14-179">分區化邏輯會根據資料的一或多個屬性之雜湊，計算要在其中儲存項目的分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-179">The sharding logic computes the shard to store an item in based on a hash of one or more attributes of the data.</span></span> <span data-ttu-id="fbf14-180">所選的雜湊函式應將資料平均分散於各分區，有可能是藉由在計算中引入某個隨機元素。</span><span class="sxs-lookup"><span data-stu-id="fbf14-180">The chosen hashing function should distribute data evenly across the shards, possibly by introducing some random element into the computation.</span></span> <span data-ttu-id="fbf14-181">下圖說明如何根據租用戶識別碼的雜湊將租用戶資料分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-181">The next figure illustrates sharding tenant data based on a hash of tenant IDs.</span></span>

   ![圖 3：根據租用戶識別碼的雜湊將租用戶資料分區](./_images/sharding-data-hash.png)

<span data-ttu-id="fbf14-183">若要了解雜湊策略超越其他分區化策略的優勢，請考慮陸續註冊新租用戶的多租用戶應用程式可能會如何將租用戶指派給資料存放區中的分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-183">To understand the advantage of the Hash strategy over other sharding strategies, consider how a multi-tenant application that enrolls new tenants sequentially might assign the tenants to shards in the data store.</span></span> <span data-ttu-id="fbf14-184">使用範圍策略時，租用戶 1 到 n 的資料會全部儲存在分區 A 中，資料租用戶 n+1 到 m 的資料會全部儲存在分區 B 中，依此類推。</span><span class="sxs-lookup"><span data-stu-id="fbf14-184">When using the Range strategy, the data for tenants 1 to n will all be stored in shard A, the data for tenants n+1 to m will all be stored in shard B, and so on.</span></span> <span data-ttu-id="fbf14-185">如果最近註冊的租用戶也是最活躍的租用戶，則大部分的資料活動會發生在少量分區中，這可能會造成熱點。</span><span class="sxs-lookup"><span data-stu-id="fbf14-185">If the most recently registered tenants are also the most active, most data activity will occur in a small number of shards, which could cause hotspots.</span></span> <span data-ttu-id="fbf14-186">相反地，雜湊策略會根據租用戶識別碼的雜湊，將租用戶配置到各分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-186">In contrast, the Hash strategy allocates tenants to shards based on a hash of their tenant ID.</span></span> <span data-ttu-id="fbf14-187">這表示後續租用戶最有可能配置到不同的分區，進而將負載分散於它們之中。</span><span class="sxs-lookup"><span data-stu-id="fbf14-187">This means that sequential tenants are most likely to be allocated to different shards, which will distribute the load across them.</span></span> <span data-ttu-id="fbf14-188">上圖顯示租用戶 55 和 56 的這點。</span><span class="sxs-lookup"><span data-stu-id="fbf14-188">The previous figure shows this for tenants 55 and 56.</span></span>

<span data-ttu-id="fbf14-189">這三個分區化策略具有下列優點和考量：</span><span class="sxs-lookup"><span data-stu-id="fbf14-189">The three sharding strategies have the following advantages and considerations:</span></span>

- <span data-ttu-id="fbf14-190">**查閱**。</span><span class="sxs-lookup"><span data-stu-id="fbf14-190">**Lookup**.</span></span> <span data-ttu-id="fbf14-191">這能夠更充分掌控分區的設定和使用方式。</span><span class="sxs-lookup"><span data-stu-id="fbf14-191">This offers more control over the way that shards are configured and used.</span></span> <span data-ttu-id="fbf14-192">使用虛擬分區可降低重新平衡資料時的影響，因為可以新增實體分割區來讓工作負載平均。</span><span class="sxs-lookup"><span data-stu-id="fbf14-192">Using virtual shards reduces the impact when rebalancing data because new physical partitions can be added to even out the workload.</span></span> <span data-ttu-id="fbf14-193">您可以修改虛擬分區與實作分區的實體分割區之間的對應，而不會影響使用分區索引鍵來儲存和擷取資料的應用程式程式碼。</span><span class="sxs-lookup"><span data-stu-id="fbf14-193">The mapping between a virtual shard and the physical partitions that implement the shard can be modified without affecting application code that uses a shard key to store and retrieve data.</span></span> <span data-ttu-id="fbf14-194">查閱分區位置也可能造成額外的負擔。</span><span class="sxs-lookup"><span data-stu-id="fbf14-194">Looking up shard locations can impose an additional overhead.</span></span>

- <span data-ttu-id="fbf14-195">**範圍**。</span><span class="sxs-lookup"><span data-stu-id="fbf14-195">**Range**.</span></span> <span data-ttu-id="fbf14-196">這很容易實作而且適用於範圍查詢，因為它們通常可以從單一作業中的單一分區擷取多個資料項目。</span><span class="sxs-lookup"><span data-stu-id="fbf14-196">This is easy to implement and works well with range queries because they can often fetch multiple data items from a single shard in a single operation.</span></span> <span data-ttu-id="fbf14-197">此策略提供更簡單的資料管理。</span><span class="sxs-lookup"><span data-stu-id="fbf14-197">This strategy offers easier data management.</span></span> <span data-ttu-id="fbf14-198">例如，如果相同區域中的使用者位於相同分區，則可根據本機負載和需求模式在每個時區排定更新。</span><span class="sxs-lookup"><span data-stu-id="fbf14-198">For example, if users in the same region are in the same shard, updates can be scheduled in each time zone based on the local load and demand pattern.</span></span> <span data-ttu-id="fbf14-199">不過，此策略不提供分區之間的最佳平衡。</span><span class="sxs-lookup"><span data-stu-id="fbf14-199">However, this strategy doesn't provide optimal balancing between shards.</span></span> <span data-ttu-id="fbf14-200">如果大部分的活動是針對相鄰的分區索引鍵，則重新平衡分區很困難，而且可能無法解決負載不平均的問題。</span><span class="sxs-lookup"><span data-stu-id="fbf14-200">Rebalancing shards is difficult and might not resolve the problem of uneven load if the majority of activity is for adjacent shard keys.</span></span>

- <span data-ttu-id="fbf14-201">**雜湊**。</span><span class="sxs-lookup"><span data-stu-id="fbf14-201">**Hash**.</span></span> <span data-ttu-id="fbf14-202">此策略更有機會達到更平均的資料和負載分配。</span><span class="sxs-lookup"><span data-stu-id="fbf14-202">This strategy offers a better chance of more even data and load distribution.</span></span> <span data-ttu-id="fbf14-203">使用雜湊函式可以直接完成要求傳送。</span><span class="sxs-lookup"><span data-stu-id="fbf14-203">Request routing can be accomplished directly by using the hash function.</span></span> <span data-ttu-id="fbf14-204">不需要維護對應。</span><span class="sxs-lookup"><span data-stu-id="fbf14-204">There's no need to maintain a map.</span></span> <span data-ttu-id="fbf14-205">請注意，計算雜湊可能會造成額外的負擔。</span><span class="sxs-lookup"><span data-stu-id="fbf14-205">Note that computing the hash might impose an additional overhead.</span></span> <span data-ttu-id="fbf14-206">此外，重新平衡分區很困難。</span><span class="sxs-lookup"><span data-stu-id="fbf14-206">Also, rebalancing shards is difficult.</span></span>

<span data-ttu-id="fbf14-207">最常見的分區化系統會實作上述其中一種方法，但您也應該考量您的應用程式的商務需求及其資料使用模式。</span><span class="sxs-lookup"><span data-stu-id="fbf14-207">Most common sharding systems implement one of the approaches described above, but you should also consider the business requirements of your applications and their patterns of data usage.</span></span> <span data-ttu-id="fbf14-208">例如，在多租用戶的應用程式中：</span><span class="sxs-lookup"><span data-stu-id="fbf14-208">For example, in a multi-tenant application:</span></span>

- <span data-ttu-id="fbf14-209">您可以根據工作負載將資料分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-209">You can shard data based on workload.</span></span> <span data-ttu-id="fbf14-210">您可以針對個別分區中變動極大的租用戶，隔離資料。</span><span class="sxs-lookup"><span data-stu-id="fbf14-210">You could segregate the data for highly volatile tenants in separate shards.</span></span> <span data-ttu-id="fbf14-211">其他租用戶的資料存取速度可能會因此獲得改善。</span><span class="sxs-lookup"><span data-stu-id="fbf14-211">The speed of data access for other tenants might be improved as a result.</span></span>

- <span data-ttu-id="fbf14-212">您可以根據租用戶的位置將資料分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-212">You can shard data based on the location of tenants.</span></span> <span data-ttu-id="fbf14-213">您可以讓特定地理區域的租用戶資料離線，以便在該區域的離峰時段進行備份和維護，而其他區域的租用戶資料仍在線上並可在其上班期間存取。</span><span class="sxs-lookup"><span data-stu-id="fbf14-213">You can take the data for tenants in a specific geographic region offline for backup and maintenance during off-peak hours in that region, while the data for tenants in other regions remains online and accessible during their business hours.</span></span>

- <span data-ttu-id="fbf14-214">高價值的租用戶可被指派自己的私用、高效能、輕量負載分區，然而較低價值的租用戶則有可能共用更緊密壓縮、忙碌的分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-214">High-value tenants could be assigned their own private, high performing, lightly loaded shards, whereas lower-value tenants might be expected to share more densely-packed, busy shards.</span></span>

- <span data-ttu-id="fbf14-215">您可以將需要高度資料隔離和隱私權之租用戶的資料儲存在完全不同的伺服器上。</span><span class="sxs-lookup"><span data-stu-id="fbf14-215">The data for tenants that need a high degree of data isolation and privacy can be stored on a completely separate server.</span></span>

## <a name="scaling-and-data-movement-operations"></a><span data-ttu-id="fbf14-216">調整和資料移動作業</span><span class="sxs-lookup"><span data-stu-id="fbf14-216">Scaling and data movement operations</span></span>

<span data-ttu-id="fbf14-217">每個分區化策略都意味著用於管理相應縮小、相應放大、資料移動以及維護狀態的不同功能和複雜度層級。</span><span class="sxs-lookup"><span data-stu-id="fbf14-217">Each of the sharding strategies implies different capabilities and levels of complexity for managing scale in, scale out, data movement, and maintaining state.</span></span>

<span data-ttu-id="fbf14-218">查閱策略允許在使用者層級實行調整和資料移動作業 (線上或離線)。</span><span class="sxs-lookup"><span data-stu-id="fbf14-218">The Lookup strategy permits scaling and data movement operations to be carried out at the user level, either online or offline.</span></span> <span data-ttu-id="fbf14-219">技巧是暫停部分或所有的使用者活動 (也許是在離峰期間)、將資料移到新的虛擬分割區或實體分區、變更對應、停用或重新整理任何保存此資料的快取，然後允許使用者活動繼續進行。</span><span class="sxs-lookup"><span data-stu-id="fbf14-219">The technique is to suspend some or all user activity (perhaps during off-peak periods), move the data to the new virtual partition or physical shard, change the mappings, invalidate or refresh any caches that hold this data, and then allow user activity to resume.</span></span> <span data-ttu-id="fbf14-220">通常可以集中管理這類型的作業。</span><span class="sxs-lookup"><span data-stu-id="fbf14-220">Often this type of operation can be centrally managed.</span></span> <span data-ttu-id="fbf14-221">查閱策略需要可高度快取且容易複寫的狀態。</span><span class="sxs-lookup"><span data-stu-id="fbf14-221">The Lookup strategy requires state to be highly cacheable and replica friendly.</span></span>

<span data-ttu-id="fbf14-222">範圍策略會對調整和資料移動作業強加一些限制，這些限制通常必須在部分或所有資料存放區離線時實行，因為資料必須跨分區進行分割與合併。</span><span class="sxs-lookup"><span data-stu-id="fbf14-222">The Range strategy imposes some limitations on scaling and data movement operations, which must typically be carried out when a part or all of the data store is offline because the data must be split and merged across the shards.</span></span> <span data-ttu-id="fbf14-223">如果大部分的活動是針對相鄰的分區索引鍵或相同範圍內的資料識別項，則移動資料來重新平衡分區可能無法解決負載不平均的問題。</span><span class="sxs-lookup"><span data-stu-id="fbf14-223">Moving the data to rebalance shards might not resolve the problem of uneven load if the majority of activity is for adjacent shard keys or data identifiers that are within the same range.</span></span> <span data-ttu-id="fbf14-224">範圍策略也可能需要維護狀態，以便將範圍對應至實體分割區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-224">The Range strategy might also require some state to be maintained in order to map ranges to the physical partitions.</span></span>

<span data-ttu-id="fbf14-225">雜湊策略讓調整和資料移動作業變得更複雜，因為分割區索引鍵是分區索引鍵或資料識別項的雜湊。</span><span class="sxs-lookup"><span data-stu-id="fbf14-225">The Hash strategy makes scaling and data movement operations more complex because the partition keys are hashes of the shard keys or data identifiers.</span></span> <span data-ttu-id="fbf14-226">必須從雜湊函式來決定每個分區的新位置，或修改此函式以提供正確的對應。</span><span class="sxs-lookup"><span data-stu-id="fbf14-226">The new location of each shard must be determined from the hash function, or the function modified to provide the correct mappings.</span></span> <span data-ttu-id="fbf14-227">不過，雜湊策略不需要維護狀態。</span><span class="sxs-lookup"><span data-stu-id="fbf14-227">However, the Hash strategy doesn't require maintenance of state.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="fbf14-228">問題和考量</span><span class="sxs-lookup"><span data-stu-id="fbf14-228">Issues and considerations</span></span>

<span data-ttu-id="fbf14-229">當您決定如何實作此模式時，請考慮下列幾點：</span><span class="sxs-lookup"><span data-stu-id="fbf14-229">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="fbf14-230">分區化可補足其他形式的資料分割，例如垂直資料分割和功能性資料分割。</span><span class="sxs-lookup"><span data-stu-id="fbf14-230">Sharding is complementary to other forms of partitioning, such as vertical partitioning and functional partitioning.</span></span> <span data-ttu-id="fbf14-231">例如，單一分區可以包含已垂直分割的實體，而功能性分割區可以實作為多個分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-231">For example, a single shard can contain entities that have been partitioned vertically, and a functional partition can be implemented as multiple shards.</span></span> <span data-ttu-id="fbf14-232">如需資料分割的詳細資訊，請參閱[資料分割指引](https://msdn.microsoft.com/library/dn589795.aspx)。</span><span class="sxs-lookup"><span data-stu-id="fbf14-232">For more information about partitioning, see the [Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span>

- <span data-ttu-id="fbf14-233">讓分區保持平衡，它們才能處理類似的 I/O 數量。</span><span class="sxs-lookup"><span data-stu-id="fbf14-233">Keep shards balanced so they all handle a similar volume of I/O.</span></span> <span data-ttu-id="fbf14-234">插入和刪除資料時，必須定期重新平衡分區，才能保證平均分配並降低熱點的可能性。</span><span class="sxs-lookup"><span data-stu-id="fbf14-234">As data is inserted and deleted, it's necessary to periodically rebalance the shards to guarantee an even distribution and to reduce the chance of hotspots.</span></span> <span data-ttu-id="fbf14-235">重新平衡是一項成本高昂的作業。</span><span class="sxs-lookup"><span data-stu-id="fbf14-235">Rebalancing can be an expensive operation.</span></span> <span data-ttu-id="fbf14-236">若要減少重新平衡的必要性，請確保每個分區都包含足夠的可用空間可處理預期的變更量，藉此規劃成長。</span><span class="sxs-lookup"><span data-stu-id="fbf14-236">To reduce the necessity of rebalancing, plan for growth by ensuring that each shard contains sufficient free space to handle the expected volume of changes.</span></span> <span data-ttu-id="fbf14-237">如有必須重新平衡，您也應該開發出可用來快速重新平衡分區的策略和指令碼。</span><span class="sxs-lookup"><span data-stu-id="fbf14-237">You should also develop strategies and scripts you can use to quickly rebalance shards if this becomes necessary.</span></span>

- <span data-ttu-id="fbf14-238">使用穩定的資料作為分區索引鍵。</span><span class="sxs-lookup"><span data-stu-id="fbf14-238">Use stable data for the shard key.</span></span> <span data-ttu-id="fbf14-239">如果分區索引鍵變更，則可能必須在分區之間移動對應的資料項目，因而增加更新作業所執行的工作量。</span><span class="sxs-lookup"><span data-stu-id="fbf14-239">If the shard key changes, the corresponding data item might have to move between shards, increasing the amount of work performed by update operations.</span></span> <span data-ttu-id="fbf14-240">基於這個理由，避免以可能易變的資訊作為分區化索引鍵的基礎。</span><span class="sxs-lookup"><span data-stu-id="fbf14-240">For this reason, avoid basing the shard key on potentially volatile information.</span></span> <span data-ttu-id="fbf14-241">請改為尋找不變或自然形成索引鍵的屬性。</span><span class="sxs-lookup"><span data-stu-id="fbf14-241">Instead, look for attributes that are invariant or that naturally form a key.</span></span>

- <span data-ttu-id="fbf14-242">確定分區索引鍵是唯一的。</span><span class="sxs-lookup"><span data-stu-id="fbf14-242">Ensure that shard keys are unique.</span></span> <span data-ttu-id="fbf14-243">例如，避免使用自動遞增欄位作為分區索引鍵。</span><span class="sxs-lookup"><span data-stu-id="fbf14-243">For example, avoid using autoincrementing fields as the shard key.</span></span> <span data-ttu-id="fbf14-244">在某些系統中，自動遞增欄位無法跨分區協調，而可能導致不同分區中的項目具有相同的分區索引鍵。</span><span class="sxs-lookup"><span data-stu-id="fbf14-244">Is some systems, autoincremented fields can't be coordinated across shards, possibly resulting in items in different shards having the same shard key.</span></span>

    >  <span data-ttu-id="fbf14-245">其他欄位中不是分區索引鍵的自動遞增值也可能造成問題。</span><span class="sxs-lookup"><span data-stu-id="fbf14-245">Autoincremented values in other fields that are not shard keys can also cause problems.</span></span> <span data-ttu-id="fbf14-246">例如，如果您使用自動遞增欄位來產生唯一識別碼，則不同分區中的兩個不同項目可能會被指定相同的識別碼。</span><span class="sxs-lookup"><span data-stu-id="fbf14-246">For example, if you use autoincremented fields to generate unique IDs, then two different items located in different shards might be assigned the same ID.</span></span>

- <span data-ttu-id="fbf14-247">有可能無法設計出符合每項可能資料查詢之需求的分區索引鍵。</span><span class="sxs-lookup"><span data-stu-id="fbf14-247">It might not be possible to design a shard key that matches the requirements of every possible query against the data.</span></span> <span data-ttu-id="fbf14-248">將資料分區以支援最常執行的查詢，並視需要建立次要索引表格，以支援使用以不屬於分區索引鍵的屬性為基礎的準則來擷取資料的查詢。</span><span class="sxs-lookup"><span data-stu-id="fbf14-248">Shard the data to support the most frequently performed queries, and if necessary create secondary index tables to support queries that retrieve data using criteria based on attributes that aren't part of the shard key.</span></span> <span data-ttu-id="fbf14-249">如需詳細資訊，請參閱[索引表格模式](./index-table.md)。</span><span class="sxs-lookup"><span data-stu-id="fbf14-249">For more information, see the [Index Table pattern](./index-table.md).</span></span>

- <span data-ttu-id="fbf14-250">只存取單一分區的查詢會比從多個分區擷取資料的查詢更有效率，所以請避免實作以下所述的分區化系統：導致應用程式執行會聯結不同分區所保存資料的大量查詢。</span><span class="sxs-lookup"><span data-stu-id="fbf14-250">Queries that access only a single shard are more efficient than those that retrieve data from multiple shards, so avoid implementing a sharding system that results in applications performing large numbers of queries that join data held in different shards.</span></span> <span data-ttu-id="fbf14-251">請記住，單一分區可以包含多種實體類型的資料。</span><span class="sxs-lookup"><span data-stu-id="fbf14-251">Remember that a single shard can contain the data for multiple types of entities.</span></span> <span data-ttu-id="fbf14-252">請考慮將資料反正規化，以將經常查詢的相關實體(例如客戶的詳細資料及其所下的訂單) 一起保留在相同的分區中，以減少應用程式執行的個別讀取次數。</span><span class="sxs-lookup"><span data-stu-id="fbf14-252">Consider denormalizing your data to keep related entities that are commonly queried together (such as the details of customers and the orders that they have placed) in the same shard to reduce the number of separate reads that an application performs.</span></span>

    >  <span data-ttu-id="fbf14-253">如果一個分區中的實體參考儲存在另一個分區中的實體，請將第二個實體的分區索引鍵納入第一個實體的結構描述中。</span><span class="sxs-lookup"><span data-stu-id="fbf14-253">If an entity in one shard references an entity stored in another shard, include the shard key for the second entity as part of the schema for the first entity.</span></span> <span data-ttu-id="fbf14-254">這有助於改善參考各分區相關資料的查詢效能。</span><span class="sxs-lookup"><span data-stu-id="fbf14-254">This can help to improve the performance of queries that reference related data across shards.</span></span>

- <span data-ttu-id="fbf14-255">如果應用程式必須執行可從多個分區擷取資料的查詢，則可能使用平行工作來擷取此資料。</span><span class="sxs-lookup"><span data-stu-id="fbf14-255">If an application must perform queries that retrieve data from multiple shards, it might be possible to fetch this data by using parallel tasks.</span></span> <span data-ttu-id="fbf14-256">範例包括展開傳送查詢，其中來自多個分區的資料是以平行方式擷取，然後彙總成單一結果。</span><span class="sxs-lookup"><span data-stu-id="fbf14-256">Examples include fan-out queries, where data from multiple shards is retrieved in parallel and then aggregated into a single result.</span></span> <span data-ttu-id="fbf14-257">不過，這種方法必然會使解決方案的資料存取邏輯增加一些複雜性。</span><span class="sxs-lookup"><span data-stu-id="fbf14-257">However, this approach inevitably adds some complexity to the data access logic of a solution.</span></span>

- <span data-ttu-id="fbf14-258">對於許多應用程式而言，建立較多小型分區可能會比具有少量大型分區更有效率，因為它們可提供比較多的負載平衡機會。</span><span class="sxs-lookup"><span data-stu-id="fbf14-258">For many applications, creating a larger number of small shards can be more efficient than having a small number of large shards because they can offer increased opportunities for load balancing.</span></span> <span data-ttu-id="fbf14-259">如果您預料有在不同實體位置之間移轉分區的需求，這也很有用。</span><span class="sxs-lookup"><span data-stu-id="fbf14-259">This can also be useful if you anticipate the need to migrate shards from one physical location to another.</span></span> <span data-ttu-id="fbf14-260">移動小型分區比移動大型分區還要快。</span><span class="sxs-lookup"><span data-stu-id="fbf14-260">Moving a small shard is quicker than moving a large one.</span></span>

- <span data-ttu-id="fbf14-261">確保每個分區儲存體節點的可用資源充足，可處理資料大小和輸送量方面的延展性需求。</span><span class="sxs-lookup"><span data-stu-id="fbf14-261">Make sure the resources available to each shard storage node are sufficient to handle the scalability requirements in terms of data size and throughput.</span></span> <span data-ttu-id="fbf14-262">如需詳細資訊，請參閱[資料分割指引](https://msdn.microsoft.com/library/dn589795.aspx)中的「設計分割區的延展性」一節。</span><span class="sxs-lookup"><span data-stu-id="fbf14-262">For more information, see the section “Designing Partitions for Scalability” in the [Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span>

- <span data-ttu-id="fbf14-263">請考慮將參考資料複寫到所有分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-263">Consider replicating reference data to all shards.</span></span> <span data-ttu-id="fbf14-264">如果從分區擷取資料的作業在相同查詢的過程中，也會參考靜態或移動緩慢的資料，請將此資料新增至該分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-264">If an operation that retrieves data from a shard also references static or slow-moving data as part of the same query, add this data to the shard.</span></span> <span data-ttu-id="fbf14-265">應用程式可以接著輕鬆擷取查詢的所有資料，而不需要對不同的資料存放區進而額外的來回行程。</span><span class="sxs-lookup"><span data-stu-id="fbf14-265">The application can then fetch all of the data for the query easily, without having to make an additional round trip to a separate data store.</span></span>

    >  <span data-ttu-id="fbf14-266">如果參考資料保存於多個分區變更中，則系統必須在所有分區間同步處理這些變更。</span><span class="sxs-lookup"><span data-stu-id="fbf14-266">If reference data held in multiple shards changes, the system must synchronize these changes across all shards.</span></span> <span data-ttu-id="fbf14-267">進行此同步處理時，系統可能遭遇某個程度的不一致。</span><span class="sxs-lookup"><span data-stu-id="fbf14-267">The system can experience a degree of inconsistency while this synchronization occurs.</span></span> <span data-ttu-id="fbf14-268">如果您這麼做，您應該將應用程式設計成能夠處理這種情況。</span><span class="sxs-lookup"><span data-stu-id="fbf14-268">If you do this, you should design your applications to be able to handle it.</span></span>

- <span data-ttu-id="fbf14-269">分區之間的參考完整性和一致性難以維護，因此您應該將會影響多個分區中資料的作業減至最少。</span><span class="sxs-lookup"><span data-stu-id="fbf14-269">It can be difficult to maintain referential integrity and consistency between shards, so you should minimize operations that affect data in multiple shards.</span></span> <span data-ttu-id="fbf14-270">如果應用程式必須修改跨分區的資料，請評估是否確實需要完全的資料一致性。</span><span class="sxs-lookup"><span data-stu-id="fbf14-270">If an application must modify data across shards, evaluate whether complete data consistency is actually required.</span></span> <span data-ttu-id="fbf14-271">相反地，雲端中的常見方法是實作最終一致性。</span><span class="sxs-lookup"><span data-stu-id="fbf14-271">Instead, a common approach in the cloud is to implement eventual consistency.</span></span> <span data-ttu-id="fbf14-272">每個分割區中的資料會分開更新，而應用程式邏輯必須負責確保成功完成所有更新，以及處理在執行最終一致的作業時，由查詢資料所引起的不一致。</span><span class="sxs-lookup"><span data-stu-id="fbf14-272">The data in each partition is updated separately, and the application logic must take responsibility for ensuring that the updates all complete successfully, as well as handling the inconsistencies that can arise from querying data while an eventually consistent operation is running.</span></span> <span data-ttu-id="fbf14-273">如需實作最終一致性的詳細資訊，請參閱[資料一致性入門](https://msdn.microsoft.com/library/dn589800.aspx)。</span><span class="sxs-lookup"><span data-stu-id="fbf14-273">For more information about implementing eventual consistency, see the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

- <span data-ttu-id="fbf14-274">設定和管理大量分區可能是一大挑戰。</span><span class="sxs-lookup"><span data-stu-id="fbf14-274">Configuring and managing a large number of shards can be a challenge.</span></span> <span data-ttu-id="fbf14-275">必須在可能保存於多個位置的多個分區與伺服器上完成各項工作 (例如監視、備份、一致性檢查和記錄或稽核)。</span><span class="sxs-lookup"><span data-stu-id="fbf14-275">Tasks such as monitoring, backing up, checking for consistency, and logging or auditing must be accomplished on multiple shards and servers, possibly held in multiple locations.</span></span> <span data-ttu-id="fbf14-276">這些工作可能是使用指令碼或其他自動化解決方案來實作，但是這不可能完全消除其他系統管理需求。</span><span class="sxs-lookup"><span data-stu-id="fbf14-276">These tasks are likely to be implemented using scripts or other automation solutions, but that might not completely eliminate the additional administrative requirements.</span></span>

- <span data-ttu-id="fbf14-277">分區可以進行地理定位，所以其中包含的資料很接近使用該分區之應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="fbf14-277">Shards can be geolocated so that the data that they contain is close to the instances of an application that use it.</span></span> <span data-ttu-id="fbf14-278">這種方法可以大幅改善效能，但是對於必須存取不同位置中多個分區的工作，則需要額外的考量。</span><span class="sxs-lookup"><span data-stu-id="fbf14-278">This approach can considerably improve performance, but requires additional consideration for tasks that must access multiple shards in different locations.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="fbf14-279">使用此模式的時機</span><span class="sxs-lookup"><span data-stu-id="fbf14-279">When to use this pattern</span></span>

<span data-ttu-id="fbf14-280">當資料存放區可能需要擴充超過單一儲存體節點可用的資源時，或藉由減少資料存放區中的爭用情形來改善效能時，請使用此模式。</span><span class="sxs-lookup"><span data-stu-id="fbf14-280">Use this pattern when a data store is likely to need to scale beyond the resources available to a single storage node, or to improve performance by reducing contention in a data store.</span></span>

> [!NOTE]
<span data-ttu-id="fbf14-281">分區化的主要焦點在於改善系統的效能和延展性，但其附帶結果是也可因為資料分割成不同分割區的方式而改善可用性。</span><span class="sxs-lookup"><span data-stu-id="fbf14-281">The primary focus of sharding is to improve the performance and scalability of a system, but as a by-product it can also improve availability due to how the data is divided into separate partitions.</span></span> <span data-ttu-id="fbf14-282">一個分割區發生失敗不一定會使應用程式無法存取其他分割區中保存的資料，而操作人員可以執行一或多個分割區的維護或復原，而不會使應用程式的整個資料無法存取。</span><span class="sxs-lookup"><span data-stu-id="fbf14-282">A failure in one partition doesn't necessarily prevent an application from accessing data held in other partitions, and an operator can perform maintenance or recovery of one or more partitions without making the entire data for an application inaccessible.</span></span> <span data-ttu-id="fbf14-283">如需詳細資訊，請參閱[資料分割指引](https://msdn.microsoft.com/library/dn589795.aspx)。</span><span class="sxs-lookup"><span data-stu-id="fbf14-283">For more information, see the [Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span>

## <a name="example"></a><span data-ttu-id="fbf14-284">範例</span><span class="sxs-lookup"><span data-stu-id="fbf14-284">Example</span></span>

<span data-ttu-id="fbf14-285">下列以 C# 撰寫的範例使用一組 SQL Server 資料庫作為分區。</span><span class="sxs-lookup"><span data-stu-id="fbf14-285">The following example in C# uses a set of SQL Server databases acting as shards.</span></span> <span data-ttu-id="fbf14-286">每個資料庫都會保存應用程式所使用的資料子集。</span><span class="sxs-lookup"><span data-stu-id="fbf14-286">Each database holds a subset of the data used by an application.</span></span> <span data-ttu-id="fbf14-287">應用程式會使用自己的分區化邏輯來擷取分散於各分區的資料 (這是展開傳送查詢範例)。</span><span class="sxs-lookup"><span data-stu-id="fbf14-287">The application retrieves data that's distributed across the shards using its own sharding logic (this is an example of a fan-out query).</span></span> <span data-ttu-id="fbf14-288">`GetShards` 方法會傳回各分區中資料的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="fbf14-288">The details of the data that's located in each shard is returned by a method called `GetShards`.</span></span> <span data-ttu-id="fbf14-289">這個方法會傳回可列舉的 `ShardInformation` 物件清單，其中 `ShardInformation` 類型包含每個分區的識別碼，以及應用程式應用於連線至分區的 SQL Server 連接字串 (此連接字串不會顯示在程式碼範例中)。</span><span class="sxs-lookup"><span data-stu-id="fbf14-289">This method returns an enumerable list of `ShardInformation` objects, where the `ShardInformation` type contains an identifier for each shard and the SQL Server connection string that an application should use to connect to the shard (the connection strings aren't shown in the code example).</span></span>

```csharp
private IEnumerable<ShardInformation> GetShards()
{
  // This retrieves the connection information from a shard store
  // (commonly a root database).
  return new[]
  {
    new ShardInformation
    {
      Id = 1,
      ConnectionString = ...
    },
    new ShardInformation
    {
      Id = 2,
      ConnectionString = ...
    }
  };
}
```

<span data-ttu-id="fbf14-290">下列程式碼顯示應用程式如何使用 `ShardInformation` 清單物件來執行查詢，以從每個分區平行擷取資料。</span><span class="sxs-lookup"><span data-stu-id="fbf14-290">The code below shows how the application uses the list of `ShardInformation` objects to perform a query that fetches data from each shard in parallel.</span></span> <span data-ttu-id="fbf14-291">不會顯示查詢的詳細資料，但在此範例中，如果分區包含客戶的詳細資料，則所擷取的資料包含可保存客戶名稱等資訊的字串。</span><span class="sxs-lookup"><span data-stu-id="fbf14-291">The details of the query aren't shown, but in this example the data that's retrieved contains a string that could hold information such as the name of a customer if the shards contain the details of customers.</span></span> <span data-ttu-id="fbf14-292">結果會彙總成 `ConcurrentBag` 集合，以供應用程式處理。</span><span class="sxs-lookup"><span data-stu-id="fbf14-292">The results are aggregated into a `ConcurrentBag` collection for processing by the application.</span></span>

```csharp
// Retrieve the shards as a ShardInformation[] instance.
var shards = GetShards();

var results = new ConcurrentBag<string>();

// Execute the query against each shard in the shard list.
// This list would typically be retrieved from configuration
// or from a root/master shard store.
Parallel.ForEach(shards, shard =>
{
  // NOTE: Transient fault handling isn't included,
  // but should be incorporated when used in a real world application.
  using (var con = new SqlConnection(shard.ConnectionString))
  {
    con.Open();
    var cmd = new SqlCommand("SELECT ... FROM ...", con);

    Trace.TraceInformation("Executing command against shard: {0}", shard.Id);

    var reader = cmd.ExecuteReader();
    // Read the results in to a thread-safe data structure.
    while (reader.Read())
    {
      results.Add(reader.GetString(0));
    }
  }
});

Trace.TraceInformation("Fanout query complete - Record Count: {0}",
                        results.Count);
```

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="fbf14-293">相關的模式和指導方針</span><span class="sxs-lookup"><span data-stu-id="fbf14-293">Related patterns and guidance</span></span>

<span data-ttu-id="fbf14-294">實作此模式時，下列模式和指導方針可能也相關：</span><span class="sxs-lookup"><span data-stu-id="fbf14-294">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="fbf14-295">[資料一致性入門](https://msdn.microsoft.com/library/dn589800.aspx)。</span><span class="sxs-lookup"><span data-stu-id="fbf14-295">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span> <span data-ttu-id="fbf14-296">有可能必須維護分散於不同分區之資料的一致性。</span><span class="sxs-lookup"><span data-stu-id="fbf14-296">It might be necessary to maintain consistency for data distributed across different shards.</span></span> <span data-ttu-id="fbf14-297">摘要說明維護分散式資料一致性的相關問題，並說明不同的一致性模型的優點和權衡取捨。</span><span class="sxs-lookup"><span data-stu-id="fbf14-297">Summarizes the issues surrounding maintaining consistency over distributed data, and describes the benefits and tradeoffs of different consistency models.</span></span>
- <span data-ttu-id="fbf14-298">[資料分割指引](https://msdn.microsoft.com/library/dn589795.aspx)。</span><span class="sxs-lookup"><span data-stu-id="fbf14-298">[Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span> <span data-ttu-id="fbf14-299">將資料存放區分區化會造成其他各種問題。</span><span class="sxs-lookup"><span data-stu-id="fbf14-299">Sharding a data store can introduce a range of additional issues.</span></span> <span data-ttu-id="fbf14-300">說明在雲端分割資料存放區的相關問題，可改善延展性、減少爭用，以及將效能最佳化。</span><span class="sxs-lookup"><span data-stu-id="fbf14-300">Describes these issues in relation to partitioning data stores in the cloud to improve scalability, reduce contention, and optimize performance.</span></span>
- <span data-ttu-id="fbf14-301">[索引表格模式](./index-table.md)。</span><span class="sxs-lookup"><span data-stu-id="fbf14-301">[Index Table pattern](./index-table.md).</span></span> <span data-ttu-id="fbf14-302">有時不可能只透過分區化索引鍵的設計來完全支援查詢。</span><span class="sxs-lookup"><span data-stu-id="fbf14-302">Sometimes it isn't possible to completely support queries just through the design of the shard key.</span></span> <span data-ttu-id="fbf14-303">指定分區索引鍵以外的索引鍵，即可讓應用程式從大型資料存放區快速擷取資料。</span><span class="sxs-lookup"><span data-stu-id="fbf14-303">Enables an application to quickly retrieve data from a large data store by specifying a key other than the shard key.</span></span>
- <span data-ttu-id="fbf14-304">[具體化檢視模式](./materialized-view.md)。</span><span class="sxs-lookup"><span data-stu-id="fbf14-304">[Materialized View pattern](./materialized-view.md).</span></span> <span data-ttu-id="fbf14-305">若要維護某些查詢作業的效能，建立可彙總及摘要資料的具體化檢視很實用，尤其在此摘要資料是以分散於各分區的資訊為基礎時。</span><span class="sxs-lookup"><span data-stu-id="fbf14-305">To maintain the performance of some query operations, it's useful to create materialized views that aggregate and summarize data, especially if this summary data is based on information that's distributed across shards.</span></span> <span data-ttu-id="fbf14-306">說明如何產生及填入這些檢視。</span><span class="sxs-lookup"><span data-stu-id="fbf14-306">Describes how to generate and populate these views.</span></span>
