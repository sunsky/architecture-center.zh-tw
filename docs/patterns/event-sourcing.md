---
title: 事件來源模式
titleSuffix: Cloud Design Patterns
description: 使用附加專用存放區記錄完整系列的事件，其描述對網域中的資料採取的動作。
keywords: 設計模式
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 0183342257c676538aedc073f4f31a1c38ffdeef
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/20/2019
ms.locfileid: "58248793"
---
# <a name="event-sourcing-pattern"></a>事件來源模式

[!INCLUDE [header](../_includes/header.md)]

不只是在網域中儲存資料的目前狀態，請使用附加專用存放區來記錄對資料採取的完整系列動作。
存放區會作為記錄的系統，而且可用來將網域物件具體化。 這可簡化複雜網域中的工作，方法是避免同步處理資料模型和商務網域的需求，同時改善效能、延展性及回應性。 它也可以提供交易資料的一致性，並維護完整稽核記錄和歷程記錄 (可以啟用補償動作)。

## <a name="context-and-problem"></a>內容和問題

大部分的應用程式能使用資料，一般的方法是當使用者在使用它時加以更新，針對應用程式維護資料的目前狀態。 例如，在傳統的建立、讀取、更新和刪除 (CRUD) 模型中，一般資料程序是從存放區讀取資料、對它進行一些修改，然後使用新值更新資料的目前狀態&mdash;通常是使用鎖定資料的交易。

CRUD 方法有一些限制：

- CRUD 系統會針對資料存放區直接執行更新作業，這可能會因為它所需要的處理負擔而使效能和回應變慢，並且限制延展性。

- 在與許多並行使用者的共同作業網域中，由於更新作業會在資料的單一項目上進行，資料更新會更有可能發生衝突。

- 除非有其他稽核機制，會在個別記錄中記錄每個作業的詳細資料，否則歷程記錄會遺失。

> 若要更深入了解 CRUD 方法的限制，請參閱 [CRUD，只有當您可以負擔時](https://blogs.msdn.microsoft.com/maarten_mullender/2004/07/23/crud-only-when-you-can-afford-it-revisited/)。

## <a name="solution"></a>解決方法

事件來源模式會定義方法，來處理由一系列事件所驅動之資料上的作業，其中每個都會記錄在附加專用存放區中。 應用程式程式碼會傳送一系列事件，以命令方式向當中保存事件的事件存放區描述資料上所發生的每個動作。 每個事件代表對資料的一組變更 (例如 `AddedItemToOrder`)。

事件會保存在事件存放區中，作為有關資料目前狀態的記錄系統 (授權的資料來源)。 事件存放區通常會發行這些事件，讓取用者可以收到通知，並可以視需要處理它們。 例如，取用者可以起始將事件中的作業套用至其他系統的工作，或執行任何其他完成此作業所需的相關聯動作。 請注意，會從訂閱事件的系統減少產生事件的應用程式程式碼。

事件存放區所發行之事件的一般用法，是當應用程式中的動作變更實體的具體化檢視時加以維護，以及與外部系統進行整合。 例如，系統可以維護所有用來填入 UI 組件的客戶訂單之具體化檢視。 隨著應用程式新增新的訂單、新增或移除訂單上的項目，然後新增出貨資訊，可以處理並使用描述這些變更的事件來更新[具體化檢視](./materialized-view.md)。

此外，在任何時間點，應用程式都可以讀取事件的歷程記錄，並用它來具體化實體的目前狀態，方法是播放並使用與該實體相關的所有事件。 這可以隨需發生，從而在處理要求時或透過已排程的工作具體化網域物件，使實體的狀態可以儲存為具體化檢視，以支援展示層。

此圖會顯示模式的概觀，包括使用事件串流的一些選項，例如建立具體化檢視、使用外部應用程式和系統整合事件，以及重新執行事件來建立特定實體目前狀態的預測。

![事件來源模式的概觀及範例](./_images/event-sourcing-overview.png)

事件來源模式可提供下列優點：

- 事件為不變，且可以使用附加專用作業加以儲存。 使用者介面、工作流程或起始事件的程序可以繼續，而處理事件的工作可以在背景中執行。 這與處理交易期間不會發生爭用合併，可以大幅提升應用程式的效能和延展性，特別是針對展示層級或使用者介面。

- 事件是簡單物件，會描述所發生的某些動作，以及描述事件所代表之動作所需的任何相關聯資料。 事件不會直接更新資料存放區。 它們只會加以記錄，以便在適當的時間進行處理。 這可簡化實作和管理。

- 事件通常對於網域專家具有意義，而[物件關聯的阻抗不符情形](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch)可能會使複雜的資料庫資料表難以理解。 資料表是人工建構，代表系統的目前狀態，而非所發生的事件。

- 事件來源有助於防止並行更新造成衝突，因為它可避免需求直接更新資料存放區中的物件。 不過，網域模型仍然必須設計成保護本身避免可能導致不一致狀態的要求。

- 事件的附加專用儲存體會提供稽核記錄，可用來監視針對資料存放區所採取的動作、隨時重新執行來重新產生目前的狀態作為具體化檢視或預期，並協助測試和偵錯系統。 此外，使用補償事件取消變更的需求會提供已還原變更的歷程記錄，如果模型只有儲存目前的狀態，就不會如此。 事件清單也可用來分析應用程式效能，並偵測使用者行為趨勢，或是取得其他實用的商務資訊。

- 事件存放區會引發事件，而工作會執行作業來回應這些事件。 這樣從事件減少工作能提供彈性和擴充性。 工作會知道事件的類型和事件資料，但不知道觸發事件的作業。 此外，多個工作可處理每個事件。 這樣可輕鬆整合其他服務，以及只接聽事件存放區所引發之新事件的系統。 不過，事件來源事件通常是非常低的層級，而且可能需要改為產生特定的整合事件。

> 事件來源通常會透過執行資料管理工作來回應事件，以及透過來自儲存之事件的具體化檢視，從而與 CQRS 模式結合。

## <a name="issues-and-considerations"></a>問題和考量

當您決定如何實作此模式時，請考慮下列幾點：

僅在建立具體化檢視或透過重新執行事件來產生資料預測時，系統最終才會保持一致。 因處理要求而將事件新增至事件存放區的應用程式、發行的事件和進行處理之事件的取用者之間，會發生一些延遲。 在這段期間，描述實體進一步變更的新事件可能已抵達事件存放區。

> [!NOTE]
> 如需最終一致性的詳細資訊，請參閱[資料一致性入門](https://msdn.microsoft.com/library/dn589800.aspx)。

事件存放區是資訊的永久來源，因此一律不得更新事件資料。 更新實體以復原變更的唯一方式是將補償事件新增至事件存放區。 如果持續性事件的格式 (而非資料) 需要變更，可能是在移轉時，可能會難以在存放區中結合現有事件與新的版本。 可能必須逐一查看進行變更的所有事件，以便符合新的格式，或新增使用新格式的新事件。 請考慮使用事件結構描述每個版本上的版本戳記來維護舊的和新的事件格式。

多執行緒應用程式和多個應用程式的執行個體可能會將事件儲存在事件存放區中。 事件存放區中的事件一致性很重要，如同影響特定實體的事件順序 (對實體發生變更的順序會影響其目前的狀態)。 將時間戳記新增至每一個事件有助於避免發生問題。 另一個常見的做法，是使用累加識別碼來註解要求所產生的每個事件。 如果兩個動作嘗試同時新增相同實體的事件，事件存放區可能會拒絕符合現有實體識別碼和事件識別碼的事件。

沒有任何標準方法或現有的機制 (例如 SQL 查詢) 可讀取事件以取得資訊。 唯一可以擷取的資料是使用事件識別碼作為準則的事件串流。 事件識別碼通常會對應至個別實體。 實體的目前狀態只能透過重新執行針對該實體原始狀態與其相關的所有事件來判斷。

每個事件串流的長度會影響管理和更新系統。 如果串流很大，請考慮在特定時間間隔 (例如指定的事件數目) 建立快照集。 實體的目前狀態可從快照集，也可透過重新執行該時間點之後發生的任何事件取得。 如需建立資料之快照集的詳細資訊，請參閱 [Martin Fowler 企業應用程式架構網站上的快照集](https://martinfowler.com/eaaDev/Snapshot.html)和[主要從屬快照集複寫](https://msdn.microsoft.com/library/ff650012.aspx)。

即使事件來源可大幅降低資料更新衝突的機會，應用程式仍必須能夠處理最終一致性所造成的不一致和缺乏交易。 例如，表示庫存降低的事件可能會在該項目的訂單下單時送達資料存放區，從而導致透過通知客戶或建立延期交貨訂單來協調這兩項作業的需求。

事件發行集可能是「至少一次」，因此事件的取用者必須具有等冪性。 如果事件處理超過一次，它們就不得重新套用事件中所述的更新。 例如，如果取用者的多個執行個體維持彙總實體的屬性，例如所下訂單的總數，則在訂單事件發生時，只有一個必須成功遞增彙總。 雖然這並不是事件來源的主要特性，但它是一般的實作決策。

## <a name="when-to-use-this-pattern"></a>使用此模式的時機

在下列情節中使用此模式：

- 當您需要資料中的擷取意圖、用途或原因時。 例如，可以擷取對客戶實體的變更作為一系列的特定事件類型，例如_移動首頁_、_關閉帳戶_或_死亡_。

- 當務必盡可能降低或完全避免發生資料更新衝突時。

- 當您需要記錄所發生的事件，且能夠加以重新執行來還原系統狀態、復原變更，或保留歷程記錄和稽核記錄時。 例如，當工作牽涉到許多步驟，可能需要您執行動作來還原更新，然後重新執行一些步驟將資料回復為一致狀態時。

- 使用事件是應用程式作業的自然功能，且需要一些額外開發或實作投入時間時。

- 當您需要減少輸入程序或從必要工作更新資料來套用這些動作時。 這可能是為了改善 UI 效能，或將事件發佈至事件發生時採取動作的其他接聽程式。 例如，將薪資系統與費用提交網站整合，以便網站和薪資系統都會採用為回應網站中所進行之資料更新而在事件存放區引發的事件。

- 當您需要在需求變更時能夠彈性變更具體化模型的格式和實體資料時，或是&mdash;當與 CQRS 搭配使用時&mdash;，您必須調整讀取模型或公開資料的檢視。

- 當與 CQRS 搭配使用時，以及在讀取模型更新時可接受最終一致性時，或是解除凍結實體和事件串流中的資料造成之效能影響可接受時。

此模式在下列情況下可能不是很有用：

- 小型或簡單網域、有少量或沒有商務邏輯的系統，或是自然適用於傳統 CRUD 資料管理機制的非網域系統。

- 需要資料檢視一致性和即時更新的系統。

- 不需要稽核記錄、歷程記錄和功能來復原和重新執行動作的系統。

- 基礎資料幾乎沒有發生衝突更新的系統。 例如，主要新增資料而非加以更新的系統。

## <a name="example"></a>範例

會議管理系統需要追蹤已完成預約會議的數目，以便檢查當潛在出席者嘗試進行預約時，是否還有空位。 系統可使用至少兩種方式來儲存會議的預約總數：

- 系統可在存放預約資訊的資料庫中，儲存預約總數作為個別實體的相關資訊。 隨預約或取消，系統可視這個數字加以遞增或遞減。 這種方法理論上很簡單，但如果有大量的出席者在短時間內嘗試預約座位，就可能會導致延展性問題。 例如，在預約期間結束之前的最後一天左右。

- 當事件保存在事件存放區時，系統可以儲存關於預約和取消的資訊。 然後它可以重新執行這些事件，來計算空位的數目。 這個方法可能會因為事件的不變性而更具擴充性。 系統只需要能夠讀取事件存放區中的資料，或將資料附加到事件存放區。 一律不會修改關於預約和取消的事件資訊。

下圖說明會議管理系統的座位保留子系統可能會使用事件來源加以實作的方式。

![使用事件來源來擷取會議管理系統中的座位保留相關資訊](./_images/event-sourcing-bounded-context.png)

保留兩個座位的動作順序如下所示：

1. 使用者介面會發出命令來保留兩個出席者的座位。 此命令是由個別的命令處理常式進行處理。 從使用者介面減少並負責處理張貼作為命令之要求的一段邏輯。

2. 包含所有會議保留相關資訊的彙總，是透過查詢說明預約和取消的事件進行建構。 此彙總稱為 `SeatAvailability`，包含在的網域模型中，會公開在彙總中查詢和修改資料的方法。

    > 可考慮的一些最佳化是使用快照集 (如此您就不需要查詢並重新執行完整事件清單，就能取得彙總的目前狀態的)，並維持記憶體中彙總的快取複本。

3. 命令處理常式會叫用網域模型所公開的方法來建立保留。

4. `SeatAvailability` 彙總會記錄包含已保留座位數目的事件。 彙總下一次套用事件時，所有保留都會用來計算還剩下多少座位。

5. 系統會將新的事件附加至事件存放區中的事件清單。

如果使用者取消座位，系統會依照除了命令處理常式之外的類似程序，發出命令來產生座位取消事件，並將它附加到事件存放區。

以及提供延展性的更多範圍，使用事件存放區也會提供預約和取消會議的完整歷程記錄或稽核記錄。 事件存放區中的事件是正確的記錄。 不需要使用任何其他方式來保存彙總，因為系統可以輕鬆地重新執行事件，並將狀態還原到任何時間點。

> 您可以在[事件來源簡介](https://msdn.microsoft.com/library/jj591559.aspx)中找到有關這個範例的詳細資訊。

## <a name="related-patterns-and-guidance"></a>相關的模式和指導方針

實作此模式時，下列模式和指導方針可能也相關：

- [命令與查詢責任隔離 (CQRS) 模式](./cqrs.md)。 提供 CQRS 實作永久資訊來源的寫入存放區通常是以實作事件來源模式錯作為基礎。 描述如何將讀取應用程式資料的作業與使用個別介面更新資料的作業進行隔離。

- [具體化檢視模式](./materialized-view.md)。 以事件來源作為基礎的系統中所使用的資料存放區通常不適合進行有效率的查詢。 相反地，常見的方法是在固定間隔，或在資料變更時，產生預先填入的資料檢視。 示範如何完成。

- [補償交易模式](./compensating-transaction.md)。 事件來源存放區中的現有資料不會更新，而是新增的新項目會將實體的狀態轉換為新的值。 若要反向變更，就要使用補償項目，因為不可能直接將先前的變更反向。 描述如何復原先前作業所執行的工作。

- [資料一致性入門](https://msdn.microsoft.com/library/dn589800.aspx)。 使用事件來源搭配個別讀取存放區或具體化檢視時，讀取資料不會立即一致，而只會最終保持一致。 摘要說明透過分散式資料維護一致性的相關問題。

- [資料分割指引](https://msdn.microsoft.com/library/dn589795.aspx)。 通常會在使用事件來源改善調整性、減少爭用並最佳化效能時，進行資料分割。 描述如何將資料分割成不連續的分割區，以及可能會發生的問題。
