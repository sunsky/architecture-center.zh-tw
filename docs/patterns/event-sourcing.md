---
title: 事件來源模式
titleSuffix: Cloud Design Patterns
description: 使用附加專用存放區記錄完整系列的事件，其描述對網域中的資料採取的動作。
keywords: 設計模式
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 0183342257c676538aedc073f4f31a1c38ffdeef
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/20/2019
ms.locfileid: "58248793"
---
# <a name="event-sourcing-pattern"></a><span data-ttu-id="48a1b-104">事件來源模式</span><span class="sxs-lookup"><span data-stu-id="48a1b-104">Event Sourcing pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="48a1b-105">不只是在網域中儲存資料的目前狀態，請使用附加專用存放區來記錄對資料採取的完整系列動作。</span><span class="sxs-lookup"><span data-stu-id="48a1b-105">Instead of storing just the current state of the data in a domain, use an append-only store to record the full series of actions taken on that data.</span></span>
<span data-ttu-id="48a1b-106">存放區會作為記錄的系統，而且可用來將網域物件具體化。</span><span class="sxs-lookup"><span data-stu-id="48a1b-106">The store acts as the system of record and can be used to materialize the domain objects.</span></span> <span data-ttu-id="48a1b-107">這可簡化複雜網域中的工作，方法是避免同步處理資料模型和商務網域的需求，同時改善效能、延展性及回應性。</span><span class="sxs-lookup"><span data-stu-id="48a1b-107">This can simplify tasks in complex domains, by avoiding the need to synchronize the data model and the business domain, while improving performance, scalability, and responsiveness.</span></span> <span data-ttu-id="48a1b-108">它也可以提供交易資料的一致性，並維護完整稽核記錄和歷程記錄 (可以啟用補償動作)。</span><span class="sxs-lookup"><span data-stu-id="48a1b-108">It can also provide consistency for transactional data, and maintain full audit trails and history that can enable compensating actions.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="48a1b-109">內容和問題</span><span class="sxs-lookup"><span data-stu-id="48a1b-109">Context and problem</span></span>

<span data-ttu-id="48a1b-110">大部分的應用程式能使用資料，一般的方法是當使用者在使用它時加以更新，針對應用程式維護資料的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="48a1b-110">Most applications work with data, and the typical approach is for the application to maintain the current state of the data by updating it as users work with it.</span></span> <span data-ttu-id="48a1b-111">例如，在傳統的建立、讀取、更新和刪除 (CRUD) 模型中，一般資料程序是從存放區讀取資料、對它進行一些修改，然後使用新值更新資料的目前狀態&mdash;通常是使用鎖定資料的交易。</span><span class="sxs-lookup"><span data-stu-id="48a1b-111">For example, in the traditional create, read, update, and delete (CRUD) model a typical data process is to read data from the store, make some modifications to it, and update the current state of the data with the new values&mdash;often by using transactions that lock the data.</span></span>

<span data-ttu-id="48a1b-112">CRUD 方法有一些限制：</span><span class="sxs-lookup"><span data-stu-id="48a1b-112">The CRUD approach has some limitations:</span></span>

- <span data-ttu-id="48a1b-113">CRUD 系統會針對資料存放區直接執行更新作業，這可能會因為它所需要的處理負擔而使效能和回應變慢，並且限制延展性。</span><span class="sxs-lookup"><span data-stu-id="48a1b-113">CRUD systems perform update operations directly against a data store, which can slow down performance and responsiveness, and limit scalability, due to the processing overhead it requires.</span></span>

- <span data-ttu-id="48a1b-114">在與許多並行使用者的共同作業網域中，由於更新作業會在資料的單一項目上進行，資料更新會更有可能發生衝突。</span><span class="sxs-lookup"><span data-stu-id="48a1b-114">In a collaborative domain with many concurrent users, data update conflicts are more likely because the update operations take place on a single item of data.</span></span>

- <span data-ttu-id="48a1b-115">除非有其他稽核機制，會在個別記錄中記錄每個作業的詳細資料，否則歷程記錄會遺失。</span><span class="sxs-lookup"><span data-stu-id="48a1b-115">Unless there's an additional auditing mechanism that records the details of each operation in a separate log, history is lost.</span></span>

> <span data-ttu-id="48a1b-116">若要更深入了解 CRUD 方法的限制，請參閱 [CRUD，只有當您可以負擔時](https://blogs.msdn.microsoft.com/maarten_mullender/2004/07/23/crud-only-when-you-can-afford-it-revisited/)。</span><span class="sxs-lookup"><span data-stu-id="48a1b-116">For a deeper understanding of the limits of the CRUD approach see [CRUD, Only When You Can Afford It](https://blogs.msdn.microsoft.com/maarten_mullender/2004/07/23/crud-only-when-you-can-afford-it-revisited/).</span></span>

## <a name="solution"></a><span data-ttu-id="48a1b-117">解決方法</span><span class="sxs-lookup"><span data-stu-id="48a1b-117">Solution</span></span>

<span data-ttu-id="48a1b-118">事件來源模式會定義方法，來處理由一系列事件所驅動之資料上的作業，其中每個都會記錄在附加專用存放區中。</span><span class="sxs-lookup"><span data-stu-id="48a1b-118">The Event Sourcing pattern defines an approach to handling operations on data that's driven by a sequence of events, each of which is recorded in an append-only store.</span></span> <span data-ttu-id="48a1b-119">應用程式程式碼會傳送一系列事件，以命令方式向當中保存事件的事件存放區描述資料上所發生的每個動作。</span><span class="sxs-lookup"><span data-stu-id="48a1b-119">Application code sends a series of events that imperatively describe each action that has occurred on the data to the event store, where they're persisted.</span></span> <span data-ttu-id="48a1b-120">每個事件代表對資料的一組變更 (例如 `AddedItemToOrder`)。</span><span class="sxs-lookup"><span data-stu-id="48a1b-120">Each event represents a set of changes to the data (such as `AddedItemToOrder`).</span></span>

<span data-ttu-id="48a1b-121">事件會保存在事件存放區中，作為有關資料目前狀態的記錄系統 (授權的資料來源)。</span><span class="sxs-lookup"><span data-stu-id="48a1b-121">The events are persisted in an event store that acts as the system of record (the authoritative data source) about the current state of the data.</span></span> <span data-ttu-id="48a1b-122">事件存放區通常會發行這些事件，讓取用者可以收到通知，並可以視需要處理它們。</span><span class="sxs-lookup"><span data-stu-id="48a1b-122">The event store typically publishes these events so that consumers can be notified and can handle them if needed.</span></span> <span data-ttu-id="48a1b-123">例如，取用者可以起始將事件中的作業套用至其他系統的工作，或執行任何其他完成此作業所需的相關聯動作。</span><span class="sxs-lookup"><span data-stu-id="48a1b-123">Consumers could, for example, initiate tasks that apply the operations in the events to other systems, or perform any other associated action that's required to complete the operation.</span></span> <span data-ttu-id="48a1b-124">請注意，會從訂閱事件的系統減少產生事件的應用程式程式碼。</span><span class="sxs-lookup"><span data-stu-id="48a1b-124">Notice that the application code that generates the events is decoupled from the systems that subscribe to the events.</span></span>

<span data-ttu-id="48a1b-125">事件存放區所發行之事件的一般用法，是當應用程式中的動作變更實體的具體化檢視時加以維護，以及與外部系統進行整合。</span><span class="sxs-lookup"><span data-stu-id="48a1b-125">Typical uses of the events published by the event store are to maintain materialized views of entities as actions in the application change them, and for integration with external systems.</span></span> <span data-ttu-id="48a1b-126">例如，系統可以維護所有用來填入 UI 組件的客戶訂單之具體化檢視。</span><span class="sxs-lookup"><span data-stu-id="48a1b-126">For example, a system can maintain a materialized view of all customer orders that's used to populate parts of the UI.</span></span> <span data-ttu-id="48a1b-127">隨著應用程式新增新的訂單、新增或移除訂單上的項目，然後新增出貨資訊，可以處理並使用描述這些變更的事件來更新[具體化檢視](./materialized-view.md)。</span><span class="sxs-lookup"><span data-stu-id="48a1b-127">As the application adds new orders, adds or removes items on the order, and adds shipping information, the events that describe these changes can be handled and used to update the [materialized view](./materialized-view.md).</span></span>

<span data-ttu-id="48a1b-128">此外，在任何時間點，應用程式都可以讀取事件的歷程記錄，並用它來具體化實體的目前狀態，方法是播放並使用與該實體相關的所有事件。</span><span class="sxs-lookup"><span data-stu-id="48a1b-128">In addition, at any point it's possible for applications to read the history of events, and use it to materialize the current state of an entity by playing back and consuming all the events related to that entity.</span></span> <span data-ttu-id="48a1b-129">這可以隨需發生，從而在處理要求時或透過已排程的工作具體化網域物件，使實體的狀態可以儲存為具體化檢視，以支援展示層。</span><span class="sxs-lookup"><span data-stu-id="48a1b-129">This can occur on demand to materialize a domain object when handling a request, or through a scheduled task so that the state of the entity can be stored as a materialized view to support the presentation layer.</span></span>

<span data-ttu-id="48a1b-130">此圖會顯示模式的概觀，包括使用事件串流的一些選項，例如建立具體化檢視、使用外部應用程式和系統整合事件，以及重新執行事件來建立特定實體目前狀態的預測。</span><span class="sxs-lookup"><span data-stu-id="48a1b-130">The figure shows an overview of the pattern, including some of the options for using the event stream such as creating a materialized view, integrating events with external applications and systems, and replaying events to create projections of the current state of specific entities.</span></span>

![事件來源模式的概觀及範例](./_images/event-sourcing-overview.png)

<span data-ttu-id="48a1b-132">事件來源模式可提供下列優點：</span><span class="sxs-lookup"><span data-stu-id="48a1b-132">The Event Sourcing pattern provides the following advantages:</span></span>

- <span data-ttu-id="48a1b-133">事件為不變，且可以使用附加專用作業加以儲存。</span><span class="sxs-lookup"><span data-stu-id="48a1b-133">Events are immutable and can be stored using an append-only operation.</span></span> <span data-ttu-id="48a1b-134">使用者介面、工作流程或起始事件的程序可以繼續，而處理事件的工作可以在背景中執行。</span><span class="sxs-lookup"><span data-stu-id="48a1b-134">The user interface, workflow, or process that initiated an event can continue, and tasks that handle the events can run in the background.</span></span> <span data-ttu-id="48a1b-135">這與處理交易期間不會發生爭用合併，可以大幅提升應用程式的效能和延展性，特別是針對展示層級或使用者介面。</span><span class="sxs-lookup"><span data-stu-id="48a1b-135">This, combined with the fact that there's no contention during the processing of transactions, can vastly improve performance and scalability for applications, especially for the presentation level or user interface.</span></span>

- <span data-ttu-id="48a1b-136">事件是簡單物件，會描述所發生的某些動作，以及描述事件所代表之動作所需的任何相關聯資料。</span><span class="sxs-lookup"><span data-stu-id="48a1b-136">Events are simple objects that describe some action that occurred, together with any associated data required to describe the action represented by the event.</span></span> <span data-ttu-id="48a1b-137">事件不會直接更新資料存放區。</span><span class="sxs-lookup"><span data-stu-id="48a1b-137">Events don't directly update a data store.</span></span> <span data-ttu-id="48a1b-138">它們只會加以記錄，以便在適當的時間進行處理。</span><span class="sxs-lookup"><span data-stu-id="48a1b-138">They're simply recorded for handling at the appropriate time.</span></span> <span data-ttu-id="48a1b-139">這可簡化實作和管理。</span><span class="sxs-lookup"><span data-stu-id="48a1b-139">This can simplify implementation and management.</span></span>

- <span data-ttu-id="48a1b-140">事件通常對於網域專家具有意義，而[物件關聯的阻抗不符情形](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch)可能會使複雜的資料庫資料表難以理解。</span><span class="sxs-lookup"><span data-stu-id="48a1b-140">Events typically have meaning for a domain expert, whereas [object-relational impedance mismatch](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch) can make complex database tables hard to understand.</span></span> <span data-ttu-id="48a1b-141">資料表是人工建構，代表系統的目前狀態，而非所發生的事件。</span><span class="sxs-lookup"><span data-stu-id="48a1b-141">Tables are artificial constructs that represent the current state of the system, not the events that occurred.</span></span>

- <span data-ttu-id="48a1b-142">事件來源有助於防止並行更新造成衝突，因為它可避免需求直接更新資料存放區中的物件。</span><span class="sxs-lookup"><span data-stu-id="48a1b-142">Event sourcing can help prevent concurrent updates from causing conflicts because it avoids the requirement to directly update objects in the data store.</span></span> <span data-ttu-id="48a1b-143">不過，網域模型仍然必須設計成保護本身避免可能導致不一致狀態的要求。</span><span class="sxs-lookup"><span data-stu-id="48a1b-143">However, the domain model must still be designed to protect itself from requests that might result in an inconsistent state.</span></span>

- <span data-ttu-id="48a1b-144">事件的附加專用儲存體會提供稽核記錄，可用來監視針對資料存放區所採取的動作、隨時重新執行來重新產生目前的狀態作為具體化檢視或預期，並協助測試和偵錯系統。</span><span class="sxs-lookup"><span data-stu-id="48a1b-144">The append-only storage of events provides an audit trail that can be used to monitor actions taken against a data store, regenerate the current state as materialized views or projections by replaying the events at any time, and assist in testing and debugging the system.</span></span> <span data-ttu-id="48a1b-145">此外，使用補償事件取消變更的需求會提供已還原變更的歷程記錄，如果模型只有儲存目前的狀態，就不會如此。</span><span class="sxs-lookup"><span data-stu-id="48a1b-145">In addition, the requirement to use compensating events to cancel changes provides a history of changes that were reversed, which wouldn't be the case if the model simply stored the current state.</span></span> <span data-ttu-id="48a1b-146">事件清單也可用來分析應用程式效能，並偵測使用者行為趨勢，或是取得其他實用的商務資訊。</span><span class="sxs-lookup"><span data-stu-id="48a1b-146">The list of events can also be used to analyze application performance and detect user behavior trends, or to obtain other useful business information.</span></span>

- <span data-ttu-id="48a1b-147">事件存放區會引發事件，而工作會執行作業來回應這些事件。</span><span class="sxs-lookup"><span data-stu-id="48a1b-147">The event store raises events, and tasks perform operations in response to those events.</span></span> <span data-ttu-id="48a1b-148">這樣從事件減少工作能提供彈性和擴充性。</span><span class="sxs-lookup"><span data-stu-id="48a1b-148">This decoupling of the tasks from the events provides flexibility and extensibility.</span></span> <span data-ttu-id="48a1b-149">工作會知道事件的類型和事件資料，但不知道觸發事件的作業。</span><span class="sxs-lookup"><span data-stu-id="48a1b-149">Tasks know about the type of event and the event data, but not about the operation that triggered the event.</span></span> <span data-ttu-id="48a1b-150">此外，多個工作可處理每個事件。</span><span class="sxs-lookup"><span data-stu-id="48a1b-150">In addition, multiple tasks can handle each event.</span></span> <span data-ttu-id="48a1b-151">這樣可輕鬆整合其他服務，以及只接聽事件存放區所引發之新事件的系統。</span><span class="sxs-lookup"><span data-stu-id="48a1b-151">This enables easy integration with other services and systems that only listen for new events raised by the event store.</span></span> <span data-ttu-id="48a1b-152">不過，事件來源事件通常是非常低的層級，而且可能需要改為產生特定的整合事件。</span><span class="sxs-lookup"><span data-stu-id="48a1b-152">However, the event sourcing events tend to be very low level, and it might be necessary to generate specific integration events instead.</span></span>

> <span data-ttu-id="48a1b-153">事件來源通常會透過執行資料管理工作來回應事件，以及透過來自儲存之事件的具體化檢視，從而與 CQRS 模式結合。</span><span class="sxs-lookup"><span data-stu-id="48a1b-153">Event sourcing is commonly combined with the CQRS pattern by performing the data management tasks in response to the events, and by materializing views from the stored events.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="48a1b-154">問題和考量</span><span class="sxs-lookup"><span data-stu-id="48a1b-154">Issues and considerations</span></span>

<span data-ttu-id="48a1b-155">當您決定如何實作此模式時，請考慮下列幾點：</span><span class="sxs-lookup"><span data-stu-id="48a1b-155">Consider the following points when deciding how to implement this pattern:</span></span>

<span data-ttu-id="48a1b-156">僅在建立具體化檢視或透過重新執行事件來產生資料預測時，系統最終才會保持一致。</span><span class="sxs-lookup"><span data-stu-id="48a1b-156">The system will only be eventually consistent when creating materialized views or generating projections of data by replaying events.</span></span> <span data-ttu-id="48a1b-157">因處理要求而將事件新增至事件存放區的應用程式、發行的事件和進行處理之事件的取用者之間，會發生一些延遲。</span><span class="sxs-lookup"><span data-stu-id="48a1b-157">There's some delay between an application adding events to the event store as the result of handling a request, the events being published, and consumers of the events handling them.</span></span> <span data-ttu-id="48a1b-158">在這段期間，描述實體進一步變更的新事件可能已抵達事件存放區。</span><span class="sxs-lookup"><span data-stu-id="48a1b-158">During this period, new events that describe further changes to entities might have arrived at the event store.</span></span>

> [!NOTE]
> <span data-ttu-id="48a1b-159">如需最終一致性的詳細資訊，請參閱[資料一致性入門](https://msdn.microsoft.com/library/dn589800.aspx)。</span><span class="sxs-lookup"><span data-stu-id="48a1b-159">See the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx) for information about eventual consistency.</span></span>

<span data-ttu-id="48a1b-160">事件存放區是資訊的永久來源，因此一律不得更新事件資料。</span><span class="sxs-lookup"><span data-stu-id="48a1b-160">The event store is the permanent source of information, and so the event data should never be updated.</span></span> <span data-ttu-id="48a1b-161">更新實體以復原變更的唯一方式是將補償事件新增至事件存放區。</span><span class="sxs-lookup"><span data-stu-id="48a1b-161">The only way to update an entity to undo a change is to add a compensating event to the event store.</span></span> <span data-ttu-id="48a1b-162">如果持續性事件的格式 (而非資料) 需要變更，可能是在移轉時，可能會難以在存放區中結合現有事件與新的版本。</span><span class="sxs-lookup"><span data-stu-id="48a1b-162">If the format (rather than the data) of the persisted events needs to change, perhaps during a migration, it can be difficult to combine existing events in the store with the new version.</span></span> <span data-ttu-id="48a1b-163">可能必須逐一查看進行變更的所有事件，以便符合新的格式，或新增使用新格式的新事件。</span><span class="sxs-lookup"><span data-stu-id="48a1b-163">It might be necessary to iterate through all the events making changes so they're compliant with the new format, or add new events that use the new format.</span></span> <span data-ttu-id="48a1b-164">請考慮使用事件結構描述每個版本上的版本戳記來維護舊的和新的事件格式。</span><span class="sxs-lookup"><span data-stu-id="48a1b-164">Consider using a version stamp on each version of the event schema to maintain both the old and the new event formats.</span></span>

<span data-ttu-id="48a1b-165">多執行緒應用程式和多個應用程式的執行個體可能會將事件儲存在事件存放區中。</span><span class="sxs-lookup"><span data-stu-id="48a1b-165">Multi-threaded applications and multiple instances of applications might be storing events in the event store.</span></span> <span data-ttu-id="48a1b-166">事件存放區中的事件一致性很重要，如同影響特定實體的事件順序 (對實體發生變更的順序會影響其目前的狀態)。</span><span class="sxs-lookup"><span data-stu-id="48a1b-166">The consistency of events in the event store is vital, as is the order of events that affect a specific entity (the order that changes occur to an entity affects its current state).</span></span> <span data-ttu-id="48a1b-167">將時間戳記新增至每一個事件有助於避免發生問題。</span><span class="sxs-lookup"><span data-stu-id="48a1b-167">Adding a timestamp to every event can help to avoid issues.</span></span> <span data-ttu-id="48a1b-168">另一個常見的做法，是使用累加識別碼來註解要求所產生的每個事件。</span><span class="sxs-lookup"><span data-stu-id="48a1b-168">Another common practice is to annotate each event resulting from a request with an incremental identifier.</span></span> <span data-ttu-id="48a1b-169">如果兩個動作嘗試同時新增相同實體的事件，事件存放區可能會拒絕符合現有實體識別碼和事件識別碼的事件。</span><span class="sxs-lookup"><span data-stu-id="48a1b-169">If two actions attempt to add events for the same entity at the same time, the event store can reject an event that matches an existing entity identifier and event identifier.</span></span>

<span data-ttu-id="48a1b-170">沒有任何標準方法或現有的機制 (例如 SQL 查詢) 可讀取事件以取得資訊。</span><span class="sxs-lookup"><span data-stu-id="48a1b-170">There's no standard approach, or existing mechanisms such as SQL queries, for reading the events to obtain information.</span></span> <span data-ttu-id="48a1b-171">唯一可以擷取的資料是使用事件識別碼作為準則的事件串流。</span><span class="sxs-lookup"><span data-stu-id="48a1b-171">The only data that can be extracted is a stream of events using an event identifier as the criteria.</span></span> <span data-ttu-id="48a1b-172">事件識別碼通常會對應至個別實體。</span><span class="sxs-lookup"><span data-stu-id="48a1b-172">The event ID typically maps to individual entities.</span></span> <span data-ttu-id="48a1b-173">實體的目前狀態只能透過重新執行針對該實體原始狀態與其相關的所有事件來判斷。</span><span class="sxs-lookup"><span data-stu-id="48a1b-173">The current state of an entity can be determined only by replaying all of the events that relate to it against the original state of that entity.</span></span>

<span data-ttu-id="48a1b-174">每個事件串流的長度會影響管理和更新系統。</span><span class="sxs-lookup"><span data-stu-id="48a1b-174">The length of each event stream affects managing and updating the system.</span></span> <span data-ttu-id="48a1b-175">如果串流很大，請考慮在特定時間間隔 (例如指定的事件數目) 建立快照集。</span><span class="sxs-lookup"><span data-stu-id="48a1b-175">If the streams are large, consider creating snapshots at specific intervals such as a specified number of events.</span></span> <span data-ttu-id="48a1b-176">實體的目前狀態可從快照集，也可透過重新執行該時間點之後發生的任何事件取得。</span><span class="sxs-lookup"><span data-stu-id="48a1b-176">The current state of the entity can be obtained from the snapshot and by replaying any events that occurred after that point in time.</span></span> <span data-ttu-id="48a1b-177">如需建立資料之快照集的詳細資訊，請參閱 [Martin Fowler 企業應用程式架構網站上的快照集](https://martinfowler.com/eaaDev/Snapshot.html)和[主要從屬快照集複寫](https://msdn.microsoft.com/library/ff650012.aspx)。</span><span class="sxs-lookup"><span data-stu-id="48a1b-177">For more information about creating snapshots of data, see [Snapshot on Martin Fowler’s Enterprise Application Architecture website](https://martinfowler.com/eaaDev/Snapshot.html) and [Master-Subordinate Snapshot Replication](https://msdn.microsoft.com/library/ff650012.aspx).</span></span>

<span data-ttu-id="48a1b-178">即使事件來源可大幅降低資料更新衝突的機會，應用程式仍必須能夠處理最終一致性所造成的不一致和缺乏交易。</span><span class="sxs-lookup"><span data-stu-id="48a1b-178">Even though event sourcing minimizes the chance of conflicting updates to the data, the application must still be able to deal with inconsistencies that result from eventual consistency and the lack of transactions.</span></span> <span data-ttu-id="48a1b-179">例如，表示庫存降低的事件可能會在該項目的訂單下單時送達資料存放區，從而導致透過通知客戶或建立延期交貨訂單來協調這兩項作業的需求。</span><span class="sxs-lookup"><span data-stu-id="48a1b-179">For example, an event that indicates a reduction in stock inventory might arrive in the data store while an order for that item is being placed, resulting in a requirement to reconcile the two operations either by advising the customer or creating a back order.</span></span>

<span data-ttu-id="48a1b-180">事件發行集可能是「至少一次」，因此事件的取用者必須具有等冪性。</span><span class="sxs-lookup"><span data-stu-id="48a1b-180">Event publication might be “at least once,” and so consumers of the events must be idempotent.</span></span> <span data-ttu-id="48a1b-181">如果事件處理超過一次，它們就不得重新套用事件中所述的更新。</span><span class="sxs-lookup"><span data-stu-id="48a1b-181">They must not reapply the update described in an event if the event is handled more than once.</span></span> <span data-ttu-id="48a1b-182">例如，如果取用者的多個執行個體維持彙總實體的屬性，例如所下訂單的總數，則在訂單事件發生時，只有一個必須成功遞增彙總。</span><span class="sxs-lookup"><span data-stu-id="48a1b-182">For example, if multiple instances of a consumer maintain an aggregate an entity's property, such as the total number of orders placed, only one must succeed in incrementing the aggregate when an order placed event occurs.</span></span> <span data-ttu-id="48a1b-183">雖然這並不是事件來源的主要特性，但它是一般的實作決策。</span><span class="sxs-lookup"><span data-stu-id="48a1b-183">While this isn't a key characteristic of event sourcing, it's the usual implementation decision.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="48a1b-184">使用此模式的時機</span><span class="sxs-lookup"><span data-stu-id="48a1b-184">When to use this pattern</span></span>

<span data-ttu-id="48a1b-185">在下列情節中使用此模式：</span><span class="sxs-lookup"><span data-stu-id="48a1b-185">Use this pattern in the following scenarios:</span></span>

- <span data-ttu-id="48a1b-186">當您需要資料中的擷取意圖、用途或原因時。</span><span class="sxs-lookup"><span data-stu-id="48a1b-186">When you want to capture intent, purpose, or reason in the data.</span></span> <span data-ttu-id="48a1b-187">例如，可以擷取對客戶實體的變更作為一系列的特定事件類型，例如_移動首頁_、_關閉帳戶_或_死亡_。</span><span class="sxs-lookup"><span data-stu-id="48a1b-187">For example, changes to a customer entity can be captured as a series of specific event types such as _Moved home_, _Closed account_, or _Deceased_.</span></span>

- <span data-ttu-id="48a1b-188">當務必盡可能降低或完全避免發生資料更新衝突時。</span><span class="sxs-lookup"><span data-stu-id="48a1b-188">When it's vital to minimize or completely avoid the occurrence of conflicting updates to data.</span></span>

- <span data-ttu-id="48a1b-189">當您需要記錄所發生的事件，且能夠加以重新執行來還原系統狀態、復原變更，或保留歷程記錄和稽核記錄時。</span><span class="sxs-lookup"><span data-stu-id="48a1b-189">When you want to record events that occur, and be able to replay them to restore the state of a system, roll back changes, or keep a history and audit log.</span></span> <span data-ttu-id="48a1b-190">例如，當工作牽涉到許多步驟，可能需要您執行動作來還原更新，然後重新執行一些步驟將資料回復為一致狀態時。</span><span class="sxs-lookup"><span data-stu-id="48a1b-190">For example, when a task involves multiple steps you might need to execute actions to revert updates and then replay some steps to bring the data back into a consistent state.</span></span>

- <span data-ttu-id="48a1b-191">使用事件是應用程式作業的自然功能，且需要一些額外開發或實作投入時間時。</span><span class="sxs-lookup"><span data-stu-id="48a1b-191">When using events is a natural feature of the operation of the application, and requires little additional development or implementation effort.</span></span>

- <span data-ttu-id="48a1b-192">當您需要減少輸入程序或從必要工作更新資料來套用這些動作時。</span><span class="sxs-lookup"><span data-stu-id="48a1b-192">When you need to decouple the process of inputting or updating data from the tasks required to apply these actions.</span></span> <span data-ttu-id="48a1b-193">這可能是為了改善 UI 效能，或將事件發佈至事件發生時採取動作的其他接聽程式。</span><span class="sxs-lookup"><span data-stu-id="48a1b-193">This might be to improve UI performance, or to distribute events to other listeners that take action when the events occur.</span></span> <span data-ttu-id="48a1b-194">例如，將薪資系統與費用提交網站整合，以便網站和薪資系統都會採用為回應網站中所進行之資料更新而在事件存放區引發的事件。</span><span class="sxs-lookup"><span data-stu-id="48a1b-194">For example, integrating a payroll system with an expense submission website so that events raised by the event store in response to data updates made in the website are consumed by both the website and the payroll system.</span></span>

- <span data-ttu-id="48a1b-195">當您需要在需求變更時能夠彈性變更具體化模型的格式和實體資料時，或是&mdash;當與 CQRS 搭配使用時&mdash;，您必須調整讀取模型或公開資料的檢視。</span><span class="sxs-lookup"><span data-stu-id="48a1b-195">When you want flexibility to be able to change the format of materialized models and entity data if requirements change, or&mdash;when used in conjunction with CQRS&mdash;you need to adapt a read model or the views that expose the data.</span></span>

- <span data-ttu-id="48a1b-196">當與 CQRS 搭配使用時，以及在讀取模型更新時可接受最終一致性時，或是解除凍結實體和事件串流中的資料造成之效能影響可接受時。</span><span class="sxs-lookup"><span data-stu-id="48a1b-196">When used in conjunction with CQRS, and eventual consistency is acceptable while a read model is updated, or the performance impact of rehydrating entities and data from an event stream is acceptable.</span></span>

<span data-ttu-id="48a1b-197">此模式在下列情況下可能不是很有用：</span><span class="sxs-lookup"><span data-stu-id="48a1b-197">This pattern might not be useful in the following situations:</span></span>

- <span data-ttu-id="48a1b-198">小型或簡單網域、有少量或沒有商務邏輯的系統，或是自然適用於傳統 CRUD 資料管理機制的非網域系統。</span><span class="sxs-lookup"><span data-stu-id="48a1b-198">Small or simple domains, systems that have little or no business logic, or nondomain systems that naturally work well with traditional CRUD data management mechanisms.</span></span>

- <span data-ttu-id="48a1b-199">需要資料檢視一致性和即時更新的系統。</span><span class="sxs-lookup"><span data-stu-id="48a1b-199">Systems where consistency and real-time updates to the views of the data are required.</span></span>

- <span data-ttu-id="48a1b-200">不需要稽核記錄、歷程記錄和功能來復原和重新執行動作的系統。</span><span class="sxs-lookup"><span data-stu-id="48a1b-200">Systems where audit trails, history, and capabilities to roll back and replay actions are not required.</span></span>

- <span data-ttu-id="48a1b-201">基礎資料幾乎沒有發生衝突更新的系統。</span><span class="sxs-lookup"><span data-stu-id="48a1b-201">Systems where there's only a very low occurrence of conflicting updates to the underlying data.</span></span> <span data-ttu-id="48a1b-202">例如，主要新增資料而非加以更新的系統。</span><span class="sxs-lookup"><span data-stu-id="48a1b-202">For example, systems that predominantly add data rather than updating it.</span></span>

## <a name="example"></a><span data-ttu-id="48a1b-203">範例</span><span class="sxs-lookup"><span data-stu-id="48a1b-203">Example</span></span>

<span data-ttu-id="48a1b-204">會議管理系統需要追蹤已完成預約會議的數目，以便檢查當潛在出席者嘗試進行預約時，是否還有空位。</span><span class="sxs-lookup"><span data-stu-id="48a1b-204">A conference management system needs to track the number of completed bookings for a conference so that it can check whether there are seats still available when a potential attendee tries to make a booking.</span></span> <span data-ttu-id="48a1b-205">系統可使用至少兩種方式來儲存會議的預約總數：</span><span class="sxs-lookup"><span data-stu-id="48a1b-205">The system could store the total number of bookings for a conference in at least two ways:</span></span>

- <span data-ttu-id="48a1b-206">系統可在存放預約資訊的資料庫中，儲存預約總數作為個別實體的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="48a1b-206">The system could store the information about the total number of bookings as a separate entity in a database that holds booking information.</span></span> <span data-ttu-id="48a1b-207">隨預約或取消，系統可視這個數字加以遞增或遞減。</span><span class="sxs-lookup"><span data-stu-id="48a1b-207">As bookings are made or canceled, the system could increment or decrement this number as appropriate.</span></span> <span data-ttu-id="48a1b-208">這種方法理論上很簡單，但如果有大量的出席者在短時間內嘗試預約座位，就可能會導致延展性問題。</span><span class="sxs-lookup"><span data-stu-id="48a1b-208">This approach is simple in theory, but can cause scalability issues if a large number of attendees are attempting to book seats during a short period of time.</span></span> <span data-ttu-id="48a1b-209">例如，在預約期間結束之前的最後一天左右。</span><span class="sxs-lookup"><span data-stu-id="48a1b-209">For example, in the last day or so prior to the booking period closing.</span></span>

- <span data-ttu-id="48a1b-210">當事件保存在事件存放區時，系統可以儲存關於預約和取消的資訊。</span><span class="sxs-lookup"><span data-stu-id="48a1b-210">The system could store information about bookings and cancellations as events held in an event store.</span></span> <span data-ttu-id="48a1b-211">然後它可以重新執行這些事件，來計算空位的數目。</span><span class="sxs-lookup"><span data-stu-id="48a1b-211">It could then calculate the number of seats available by replaying these events.</span></span> <span data-ttu-id="48a1b-212">這個方法可能會因為事件的不變性而更具擴充性。</span><span class="sxs-lookup"><span data-stu-id="48a1b-212">This approach can be more scalable due to the immutability of events.</span></span> <span data-ttu-id="48a1b-213">系統只需要能夠讀取事件存放區中的資料，或將資料附加到事件存放區。</span><span class="sxs-lookup"><span data-stu-id="48a1b-213">The system only needs to be able to read data from the event store, or append data to the event store.</span></span> <span data-ttu-id="48a1b-214">一律不會修改關於預約和取消的事件資訊。</span><span class="sxs-lookup"><span data-stu-id="48a1b-214">Event information about bookings and cancellations is never modified.</span></span>

<span data-ttu-id="48a1b-215">下圖說明會議管理系統的座位保留子系統可能會使用事件來源加以實作的方式。</span><span class="sxs-lookup"><span data-stu-id="48a1b-215">The following diagram illustrates how the seat reservation subsystem of the conference management system might be implemented using event sourcing.</span></span>

![使用事件來源來擷取會議管理系統中的座位保留相關資訊](./_images/event-sourcing-bounded-context.png)

<span data-ttu-id="48a1b-217">保留兩個座位的動作順序如下所示：</span><span class="sxs-lookup"><span data-stu-id="48a1b-217">The sequence of actions for reserving two seats is as follows:</span></span>

1. <span data-ttu-id="48a1b-218">使用者介面會發出命令來保留兩個出席者的座位。</span><span class="sxs-lookup"><span data-stu-id="48a1b-218">The user interface issues a command to reserve seats for two attendees.</span></span> <span data-ttu-id="48a1b-219">此命令是由個別的命令處理常式進行處理。</span><span class="sxs-lookup"><span data-stu-id="48a1b-219">The command is handled by a separate command handler.</span></span> <span data-ttu-id="48a1b-220">從使用者介面減少並負責處理張貼作為命令之要求的一段邏輯。</span><span class="sxs-lookup"><span data-stu-id="48a1b-220">A piece of logic that is decoupled from the user interface and is responsible for handling requests posted as commands.</span></span>

2. <span data-ttu-id="48a1b-221">包含所有會議保留相關資訊的彙總，是透過查詢說明預約和取消的事件進行建構。</span><span class="sxs-lookup"><span data-stu-id="48a1b-221">An aggregate containing information about all reservations for the conference is constructed by querying the events that describe bookings and cancellations.</span></span> <span data-ttu-id="48a1b-222">此彙總稱為 `SeatAvailability`，包含在的網域模型中，會公開在彙總中查詢和修改資料的方法。</span><span class="sxs-lookup"><span data-stu-id="48a1b-222">This aggregate is called `SeatAvailability`, and is contained within a domain model that exposes methods for querying and modifying the data in the aggregate.</span></span>

    > <span data-ttu-id="48a1b-223">可考慮的一些最佳化是使用快照集 (如此您就不需要查詢並重新執行完整事件清單，就能取得彙總的目前狀態的)，並維持記憶體中彙總的快取複本。</span><span class="sxs-lookup"><span data-stu-id="48a1b-223">Some optimizations to consider are using snapshots (so that you don’t need to query and replay the full list of events to obtain the current state of the aggregate), and maintaining a cached copy of the aggregate in memory.</span></span>

3. <span data-ttu-id="48a1b-224">命令處理常式會叫用網域模型所公開的方法來建立保留。</span><span class="sxs-lookup"><span data-stu-id="48a1b-224">The command handler invokes a method exposed by the domain model to make the reservations.</span></span>

4. <span data-ttu-id="48a1b-225">`SeatAvailability` 彙總會記錄包含已保留座位數目的事件。</span><span class="sxs-lookup"><span data-stu-id="48a1b-225">The `SeatAvailability` aggregate records an event containing the number of seats that were reserved.</span></span> <span data-ttu-id="48a1b-226">彙總下一次套用事件時，所有保留都會用來計算還剩下多少座位。</span><span class="sxs-lookup"><span data-stu-id="48a1b-226">The next time the aggregate applies events, all the reservations will be used to compute how many seats remain.</span></span>

5. <span data-ttu-id="48a1b-227">系統會將新的事件附加至事件存放區中的事件清單。</span><span class="sxs-lookup"><span data-stu-id="48a1b-227">The system appends the new event to the list of events in the event store.</span></span>

<span data-ttu-id="48a1b-228">如果使用者取消座位，系統會依照除了命令處理常式之外的類似程序，發出命令來產生座位取消事件，並將它附加到事件存放區。</span><span class="sxs-lookup"><span data-stu-id="48a1b-228">If a user cancels a seat, the system follows a similar process except the command handler issues a command that generates a seat cancellation event and appends it to the event store.</span></span>

<span data-ttu-id="48a1b-229">以及提供延展性的更多範圍，使用事件存放區也會提供預約和取消會議的完整歷程記錄或稽核記錄。</span><span class="sxs-lookup"><span data-stu-id="48a1b-229">As well as providing more scope for scalability, using an event store also provides a complete history, or audit trail, of the bookings and cancellations for a conference.</span></span> <span data-ttu-id="48a1b-230">事件存放區中的事件是正確的記錄。</span><span class="sxs-lookup"><span data-stu-id="48a1b-230">The events in the event store are the accurate record.</span></span> <span data-ttu-id="48a1b-231">不需要使用任何其他方式來保存彙總，因為系統可以輕鬆地重新執行事件，並將狀態還原到任何時間點。</span><span class="sxs-lookup"><span data-stu-id="48a1b-231">There is no need to persist aggregates in any other way because the system can easily replay the events and restore the state to any point in time.</span></span>

> <span data-ttu-id="48a1b-232">您可以在[事件來源簡介](https://msdn.microsoft.com/library/jj591559.aspx)中找到有關這個範例的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="48a1b-232">You can find more information about this example in [Introducing Event Sourcing](https://msdn.microsoft.com/library/jj591559.aspx).</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="48a1b-233">相關的模式和指導方針</span><span class="sxs-lookup"><span data-stu-id="48a1b-233">Related patterns and guidance</span></span>

<span data-ttu-id="48a1b-234">實作此模式時，下列模式和指導方針可能也相關：</span><span class="sxs-lookup"><span data-stu-id="48a1b-234">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="48a1b-235">[命令與查詢責任隔離 (CQRS) 模式](./cqrs.md)。</span><span class="sxs-lookup"><span data-stu-id="48a1b-235">[Command and Query Responsibility Segregation (CQRS) pattern](./cqrs.md).</span></span> <span data-ttu-id="48a1b-236">提供 CQRS 實作永久資訊來源的寫入存放區通常是以實作事件來源模式錯作為基礎。</span><span class="sxs-lookup"><span data-stu-id="48a1b-236">The write store that provides the permanent source of information for a CQRS implementation is often based on an implementation of the Event Sourcing pattern.</span></span> <span data-ttu-id="48a1b-237">描述如何將讀取應用程式資料的作業與使用個別介面更新資料的作業進行隔離。</span><span class="sxs-lookup"><span data-stu-id="48a1b-237">Describes how to segregate the operations that read data in an application from the operations that update data by using separate interfaces.</span></span>

- <span data-ttu-id="48a1b-238">[具體化檢視模式](./materialized-view.md)。</span><span class="sxs-lookup"><span data-stu-id="48a1b-238">[Materialized View pattern](./materialized-view.md).</span></span> <span data-ttu-id="48a1b-239">以事件來源作為基礎的系統中所使用的資料存放區通常不適合進行有效率的查詢。</span><span class="sxs-lookup"><span data-stu-id="48a1b-239">The data store used in a system based on event sourcing is typically not well suited to efficient querying.</span></span> <span data-ttu-id="48a1b-240">相反地，常見的方法是在固定間隔，或在資料變更時，產生預先填入的資料檢視。</span><span class="sxs-lookup"><span data-stu-id="48a1b-240">Instead, a common approach is to generate prepopulated views of the data at regular intervals, or when the data changes.</span></span> <span data-ttu-id="48a1b-241">示範如何完成。</span><span class="sxs-lookup"><span data-stu-id="48a1b-241">Shows how this can be done.</span></span>

- <span data-ttu-id="48a1b-242">[補償交易模式](./compensating-transaction.md)。</span><span class="sxs-lookup"><span data-stu-id="48a1b-242">[Compensating Transaction pattern](./compensating-transaction.md).</span></span> <span data-ttu-id="48a1b-243">事件來源存放區中的現有資料不會更新，而是新增的新項目會將實體的狀態轉換為新的值。</span><span class="sxs-lookup"><span data-stu-id="48a1b-243">The existing data in an event sourcing store is not updated, instead new entries are added that transition the state of entities to the new values.</span></span> <span data-ttu-id="48a1b-244">若要反向變更，就要使用補償項目，因為不可能直接將先前的變更反向。</span><span class="sxs-lookup"><span data-stu-id="48a1b-244">To reverse a change, compensating entries are used because it isn't possible to simply reverse the previous change.</span></span> <span data-ttu-id="48a1b-245">描述如何復原先前作業所執行的工作。</span><span class="sxs-lookup"><span data-stu-id="48a1b-245">Describes how to undo the work that was performed by a previous operation.</span></span>

- <span data-ttu-id="48a1b-246">[資料一致性入門](https://msdn.microsoft.com/library/dn589800.aspx)。</span><span class="sxs-lookup"><span data-stu-id="48a1b-246">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span> <span data-ttu-id="48a1b-247">使用事件來源搭配個別讀取存放區或具體化檢視時，讀取資料不會立即一致，而只會最終保持一致。</span><span class="sxs-lookup"><span data-stu-id="48a1b-247">When using event sourcing with a separate read store or materialized views, the read data won't be immediately consistent, instead it'll be only eventually consistent.</span></span> <span data-ttu-id="48a1b-248">摘要說明透過分散式資料維護一致性的相關問題。</span><span class="sxs-lookup"><span data-stu-id="48a1b-248">Summarizes the issues surrounding maintaining consistency over distributed data.</span></span>

- <span data-ttu-id="48a1b-249">[資料分割指引](https://msdn.microsoft.com/library/dn589795.aspx)。</span><span class="sxs-lookup"><span data-stu-id="48a1b-249">[Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span> <span data-ttu-id="48a1b-250">通常會在使用事件來源改善調整性、減少爭用並最佳化效能時，進行資料分割。</span><span class="sxs-lookup"><span data-stu-id="48a1b-250">Data is often partitioned when using event sourcing to improve scalability, reduce contention, and optimize performance.</span></span> <span data-ttu-id="48a1b-251">描述如何將資料分割成不連續的分割區，以及可能會發生的問題。</span><span class="sxs-lookup"><span data-stu-id="48a1b-251">Describes how to divide data into discrete partitions, and the issues that can arise.</span></span>
