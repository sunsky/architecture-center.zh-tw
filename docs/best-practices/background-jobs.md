---
title: 背景作業指引
titleSuffix: Best practices for cloud applications
description: 獨立於使用者介面之外執行的背景工作指引。
author: dragon119
ms.date: 11/05/2018
ms.topic: best-practice
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 4b96c19dd8613a941a7408e1b99945d5fa0f5364
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/20/2019
ms.locfileid: "58248963"
---
# <a name="background-jobs"></a>背景作業作業

許多類型的應用程式需要執行與使用者介面 (UI) 無關的背景工作。 範例包括批次作業、大量處理的工作，以及長時間執行的處理序，例如工作流程。 背景作業可以在不需要和使用者互動的情形下執行。應用程式可以啟動此作業，然後繼續處理使用者的互動式要求。 這有助於減少應用程式 UI 的負載，如此可以改善可用性，並降低互動式回應時間。

比方說，如果產生使用者上傳的影像縮圖時需要使用應用程式，可將它作為背景作業執行，並在完成時將縮圖儲存到儲存體，使用者不需要等待處理序完成。 同樣地，下訂單的使用者可以起始背景工作流程來處理訂單，而同時 UI 能讓使用者繼續瀏覽 Web 應用程式。 當背景作業完成時，可更新儲存的訂單資料，並將電子郵件傳送給確認訂單的使用者。

當您考慮是否將工作作為背景作業執行時，主要的準則是：是否可以執行工作而不需要使用者互動，且不需要讓 UI 等待作業完成。 需要讓使用者或 UI 等待完成的工作，可能不適合作為背景作業。

## <a name="types-of-background-jobs"></a>背景工作類型

背景作業通常具有下列一個或多個的作業類型：

- 需要大量 CPU 處理的作業，例如數學計算或結構化模型分析。
- 進行大量 I/O 動作的作業，例如執行一系列的儲存體交易或索引檔。
- 如夜間資料更新或排程處理的批次作業。
- 長時間執行的工作流程，例如訂單履行或佈建服務和系統。
- 其中的工作移交至更安全的位置，以便進行處理的敏感性資料處理序。 例如，您可能不想在 Web 應用程式中處理敏感性資料。 相反的，您可以改用如 [閘道管理員](../patterns/gatekeeper.md)的模式將資料傳送到隔離的背景處理序中，且該處理序擁有受保護儲存體的存取權。

## <a name="triggers"></a>觸發程序

可利用數個不同的方式啟動背景工作。 它們全都屬於下列類別之一：

- [**事件驅動觸發程序**](#event-driven-triggers)。 工作會啟動以回應事件，通常是使用者或工作流程中的步驟所採取的動作。
- [**排程驅動觸發程序**](#schedule-driven-triggers)。 根據計時器在排程上叫用的工作。 這可能是重複執行的排程，或指定在稍後執行的一次性叫用。

### <a name="event-driven-triggers"></a>事件驅動觸發程序

事件驅動叫用會使用觸發程序來啟動背景工作。 使用事件驅動觸發程序的範例包括：

- UI 或另一項工作可將訊息放在佇列中。 訊息包含已經執行的動作相關資料，例如下訂單的使用者。 背景工作會在此佇列上接聽，並偵測新訊息到達。 它會讀取訊息，並將其中的資料做為背景工作的輸入。
- UI 或另一項工作會儲存或更新儲存體中的值。 背景工作監視儲存體並偵測變更。 它會讀取資料，並使用它做為背景工作的輸入。
- UI 或另一項作業會要求端點 (例如 HTTPS URI)，或公開為 Web 服務的 API。 它會在要求的過程中，傳遞完成背景工作所需的資料。 端點或 Web 服務會叫用背景工作，將資料做為其輸入。

適合事件驅動叫用的工作一般範例包括影像處理、工作流程、將資訊傳送至遠端服務、傳送電子郵件訊息、在多組織用戶共享的應用程式中佈建新使用者等等。

### <a name="schedule-driven-triggers"></a>排程驅動觸發程序

排程驅動叫用會使用計時器啟動背景工作。 使用排程驅動觸發程序的範例包括：

- 在應用程式內本機執行的計時器，或作為應用程式作業系統一部分的計時器，會定期叫用背景工作。
- 在不同的應用程式中執行的計時器，或計時器服務 (例如 Azure 排程器)，會定期將要求傳送到 API 或 Web 服務。 API 或 Web 服務會叫用背景工作。
- 不同的程序或應用程式會啟動計時器，以便在指定的時間延遲後或特定的時間，叫用背景工作一次。

適合排程驅動叫用工作的一般範例包含批次處理常式 (例如根據使用者最新的行為來更新其相關的產品清單)、例行資料處理工作 (例如更新索引或產生累積結果)、每日報告的資料分析、資料保留清除、資料一致性檢查。

如果您使用必須作為單一執行個體執行的排程驅動工作，請注意下列事項：

- 如果調整正在執行排程器的計算執行個體 (例如使用 Windows 排程工作的虛擬機器)，您必須執行排程器的多個執行個體。 這些動作可能啟動工作的多個執行個體。
- 如果工作的執行時間超過排程器事件之間的期間，排程器可能在前一個工作仍在執行時啟動工作的另一個執行個體。

## <a name="returning-results"></a>傳回結果

背景作業以非同步的方式，在不同的處理序或甚至不同的位置內 (從 UI 或叫用背景工作的處理序) 中執行。 在理想的情況下，背景工作是「射後不理」(Fire and Forget) 的作業，而且其執行進度不會影響 UI 或呼叫程序。 這表示呼叫處理序不會等候工作完成。 因此，此處理序就無法自動偵測工作的結束時間。

如果您需要背景工作與呼叫工作通訊，以指出進度或完成，您必須為此實作一種機制。 部分範例如下：

- 將狀態指標值寫入至可存取 UI 或呼叫者工作的儲存體，也就是可在必要時監視或檢查此值。 可將背景工作必須傳回給呼叫端的資料，放入相同的儲存體中。
- 建立 UI 或呼叫端會接聽的回覆佇列。 背景工作可以將訊息傳送至佇列，此佇列表示出狀態和工作的完成。 可將背景工作必須傳回給呼叫端的資料放入訊息中。 如果您使用 Azure 服務匯流排，您可以使用 **ReplyTo** 和 **CorrelationId** 屬性來實作這項功能。
- 從 UI 或呼叫端可以存取來取得狀態資訊的背景工作中，公開 API 或端點。 可在回應中包含背景工作必須傳回給呼叫端的資料。
- 讓背景工作透過 API 回呼至 UI 或呼叫端，以表示預先定義的時間點或完成時的狀態。 這可能是透過本機引發的事件，或透過發佈和訂閱機制。 可在要求或事件裝載中，包含背景工作必須傳回給呼叫端的資料。

## <a name="hosting-environment"></a>裝載環境

您可以使用各種不同的 Azure 平台服務來裝載背景工作：

- [**Azure Web Apps 及 WebJobs**](#azure-web-apps-and-webjobs)。 您可以根據 Web 應用程式內容中各種不同類型的指令碼或可執行程式，來使用 Web 工作執行自訂工作。
- [**Azure 虛擬機器**](#azure-virtual-machines)。 如果您使用 Windows 服務，或您想要使用 Windows 工作排程器，它一般會在專用的虛擬機器內裝載您的背景工作。
- [**Azure Batch**](#azure-batch)。 Batch 是一項平台服務，可排程要在一組受控虛擬機器上執行的計算密集型工作， ，而且可以自動調整計算資源。
- [**Azure Kubernetes Service**](#azure-kubernetes-service) (AKS)。 Azure Kubernetes Service 會提供 Azure 上適用於 Kubernetes 的受控裝載環境。

下列各節更詳細描述其中每個選項，並包含可協助您選擇適當選項的注意事項。

### <a name="azure-web-apps-and-webjobs"></a>Azure Web Apps 及 WebJobs

您可以使用 Azure WebJobs，把自訂工作當做 Azure Web 應用程式內的背景工作來執行。 Web 工作會在 Web 應用程式內容中作為連續處理序來執行。 Web 工作也會為回應 Azure 排程器的觸發事件或外部因素 (例如變更儲存體 Blob 和訊息佇列) 而執行。 工作可在要求時啟動和停止，及正常關機。 如果連續執行 WebJob 失敗，會自動重新啟動。 重試和錯誤動作皆可設定。

當您設定 Web 工作時︰

- 如果您想要讓作業回應事件驅動觸發程序，應該將其設定為 [連續執行] 。 指令碼或程式會儲存在名為 site/wwwroot/app_data/jobs/continuous 的資料夾中。
- 如果您想要作業回應排程驅動觸發程序，您應該將其設定為 [依排程執行] 。 指令碼或程式會儲存在名為 site/wwwroot/app_data/jobs/triggered 的資料夾中。
- 如果在設定作業時選擇 [視需要執行] 選項，它會執行您在啟動它時，與 [依排程執行] 選項相同的程式碼。

Azure WebJobs 在 Web 應用程式的沙箱中執行。 這代表它們可以存取環境變數，並且與 Web 應用程式分享資訊 (例如連接字串)。 作業可存取執行工作之電腦的唯一識別碼。 名為 **AzureWebJobsStorage** 的連接字串為應用程式資料提供 Azure 儲存體佇列、Blob 和資料表的存取權，以及為傳訊和通訊提供服務匯流排的存取權。 名為 **AzureWebJobsDashboard** 的連接字串工作動作記錄檔的存取權。

Azure WebJobs 具有下列特性：

- **安全性**：WebJobs 受到 Web 應用程式的部署認證所保護。
- **支援的檔案類型**：您可以使用命令指令碼 (.cmd)、批次檔 (.bat)、PowerShell 指令碼 (.ps1)、Bash 殼層指令碼 (.sh)、PHP 指令碼 (.php)、Python 指令碼 (.py)、JavaScript 程式碼 (.js) 和可執行程式 (.exe、.jar 等等) 定義 Web 工作。
- **部署**：您可以使用 [Azure 入口網站](/azure/app-service-web/web-sites-create-web-jobs)、使用 [Visual Studio](/azure/app-service-web/websites-dotnet-deploy-webjobs)、使用 [Azure WebJobs SDK](/azure/app-service/webjobs-sdk-get-started)，或將它們直接複製到下列位置，來部署指令碼和可執行檔：
  - 針對觸發執行：site/wwwroot/app_data/jobs/triggered/{job name}
  - 針對連續執行：site/wwwroot/app_data/jobs/continuous/{job name}
- **記錄**：Console.Out 會被視為 (標示為) INFO。 Console.Error 會被視為 ERROR。 您可以使用 Azure 入口網站存取監視和診斷資訊。 您可以直接從網站下載記錄檔。 這些資訊會儲存在下列位置：
  - 針對觸發執行：Vfs/data/jobs/triggered/jobName
  - 針對連續執行：Vfs/data/jobs/continuous/jobName
- **設定**：您可以使用入口網站、REST API 和 PowerShell 對 Web 工作進行設定。 您可以使用和工作指令碼位於相同根目錄的設定檔 (名為 settings.job) 來提供作業的設定資訊。 例如︰
  - { "stopping_wait_time":60 }
  - { "is_singleton": true }

#### <a name="considerations"></a>考量

- 根據預設，WebJobs 會跟據 Web 應用程式來調整自己。 不過，您可以藉由將 **is_singleton** 設定屬性設為 **true**，進而設定為在單一執行個體上執行作業。 單一執行個體 Web 工作可用於您不想要調整的工作，或作為同時進行的多重執行個體來執行，例如重新建立索引、資料分析和類似的工作。
- 若要將作業對 Web 應用程式效能的影響降到最低，請考慮在新的 App Service 方案中建立空的 Azure Web 應用程式執行個體，來裝載可能會長時間執行或耗用大量資源的 Web 工作。

### <a name="azure-virtual-machines"></a>Azure 虛擬機器

背景工作的實作方式可能會讓它們無法部署到 Azure Web 應用程式，或是這些選項都不可行。 常見的範例有 Windows 服務、協力廠商公用程式和可執行程式。 另一個例子是針對某個執行環境 (和裝載應用程式的環境不同) 所撰寫的程式。 比方說，它可能是您想要從 Windows 或 .NET 應用程式執行的 Unix 或 Linux 程式。 您可以選擇各式各樣的 Azure 虛擬機器的作業系統，並在該虛擬機器上執行您的服務或可執行檔。

如要了解如何選擇使用虛擬機器的時機，請參閱 [Azure App Services、雲端服務與虛擬機器之比較](/azure/app-service-web/choose-web-site-cloud-service-vm/)。 如需虛擬機器選項的相關資訊，請參閱 [Azure 中的 Windows 虛擬機器大小](/azure/virtual-machines/windows/sizes)。 如需虛擬機器可用之作業系統和預先建立映像的詳細資訊，請參閱 [Azure 虛擬機器 Marketplace](https://azure.microsoft.com/gallery/virtual-machines/)。

若要在個別虛擬機器中起始背景工作，您有一系列的選項可選：

- 您可以藉由將要求傳送至工作所公開的端點，以視需要直接從您的應用程式執行工作。 這會傳入工作所需的任何資料。 此端點會叫用工作。
- 您可以使用所選作業系統中的可用排程器或計時器，將工作設定為依據排程執行。 例如，在 Windows 上可以使用 Windows 工作排程器來執行指令碼和工作。 或者，如果您已在虛擬機器上安裝 SQL Server，您可以使用 SQL Server 代理程式來執行指令碼和工作。
- 您可以使用 Azure 排程器來起始工作，方法是將訊息加入至工作接聽的佇列，或將要求傳送至工作所公開的 API。

如需有關如何啟動背景工作的詳細資訊，請參閱先前的＜ [觸發程序](#triggers) ＞一節。

<!-- markdownlint-disable MD024 -->

#### <a name="considerations"></a>考量

<!-- markdownlint-enable MD024 -->

當您決定是否要在 Azure 虛擬機器中部署背景工作時，請考慮下列幾點：

- 在不同的 Azure 虛擬機器中裝載背景工作提供了彈性，並可透過起始、執行、排程及資源配置以精確控制。 不過，如果必須部署虛擬機器，並只是為了執行背景工作，則會增加執行階段成本。
- 沒有任何設備可監視 Azure 入口網站中的工作，且沒有適用於失敗工作的自動重新啟動功能，但您可以監視虛擬機器的基本狀態，並使用 [Azure Resource Manager Cmdlet](https://msdn.microsoft.com/library/mt125356.aspx) 管理它。 不過，計算節點中沒有機制可用來控制程序和執行緒。 通常，使用虛擬機器將會需要額外的工作，才能在工作中實作機制，以便從檢測中收集資料，並從虛擬機器中的作業系統收集資料。 一個可能適當的解決方案是使用 [System Center Management Pack for Azure](https://www.microsoft.com/download/details.aspx?id=50013)。
- 您可以考慮建立透過 HTTP 端點公開的監視探查。 這些探查的程式碼可執行健康狀態檢查、收集操作資訊和統計資料，或自動分頁錯誤資訊，以及將它傳回給管理應用程式。 如需詳細資訊，請參閱[健康情況端點監控模式](../patterns/health-endpoint-monitoring.md)。

如需詳細資訊，請參閱

- [虛擬機器](https://azure.microsoft.com/services/virtual-machines/)
- [Azure 虛擬機器常見問題集](/azure/virtual-machines/virtual-machines-linux-classic-faq?toc=%2fazure%2fvirtual-machines%2flinux%2fclassic%2ftoc.json)

### <a name="azure-batch"></a>Azure Batch

如果您需要跨數十、數百或數千個 VM 執行大型、平行的高效能計算 (HPC) 工作負載，請考慮 [Azure Batch](/azure/batch/)。

Batch 服務會佈建 VM、將工作指派給 VM、執行工作，並監視進度。 Batch 可以自動相應放大 VM 來反應工作負載。 Batch 也提供作業排程。 Azure Batch 支援 Linux 和 Windows VM。

<!-- markdownlint-disable MD024 -->

#### <a name="considerations"></a>考量

<!-- markdownlint-enable MD024 -->

Batch 適合執行本質平行的工作負載。 也可以執行最後有歸納步驟的平行計算，或是執行[訊息傳遞介面 (MPI) 應用程式](/azure/batch/batch-mpi) (用於需要在節點間傳遞訊息的平行工作)。

節點 (VM) 集區上執行的 Azure Batch 作業。 其中一個做法是只在需要的時候配置集區，且在作業完成後便刪除。 這能將使用率最大化，因為節點不會閒置，但作業必須等候節點的配置。 或者，您可以事先建立集區。 這個做法可以降低作業開始所需的時間，但是會造成節點閒置。 如需詳細資訊，請參閱[集區和計算節點存留期](/azure/batch/batch-api-basics#pool-and-compute-node-lifetime)。

如需詳細資訊，請參閱

- [什麼是 Azure Batch？](/azure/batch/batch-technical-overview)
- [使用 Batch 開發大規模的平行運算解決方案](/azure/batch/batch-api-basics)
- [大規模運算工作負載的 Batch 和 HPC 解決方案](/azure/batch/batch-hpc-solutions)

### <a name="azure-kubernetes-service"></a>Azure Kubernetes Service

Azure Kubernetes Service (AKS) 可管理裝載 Kubernetes 的環境，以便輕鬆地部署及管理容器化應用程式。

容器適合用於執行背景作業。 以下是其中一些優點：

- 容器支援高密度裝載。 您可以在容器中隔離背景工作，同時在每個 VM 中入放多個容器。
- 容器協調器會處理內部負載平衡、設定內部網路，以及其他設定工作。
- 視需要啟動或停止容器。
- Azure Container Registry 可讓您註冊在 Azure 界限內註冊您的容器。 這同時具有安全性、隱私權和相近的優點。

<!-- markdownlint-disable MD024 -->

#### <a name="considerations"></a>考量

<!-- markdownlint-enable MD024 -->

- 必須了解如何使用容器協調器。 這會不會是個問題，取決於您的 DevOps 小組技能。

如需詳細資訊，請參閱

- [Azure 中容器的概觀](https://azure.microsoft.com/overview/containers/)

- [私人 Docker 容器登錄的簡介](/azure/container-registry/container-registry-intro)

## <a name="partitioning"></a>分割

如果您決定讓背景工作加入現有的計算執行個體，您必須考慮這對計算執行個體的品質屬性和背景工作本身的影響。 這些因素會幫助您決定是否要以現有的計算執行個體共置工作，或將它們分成不同的計算執行個體：

- **可用性**：背景工作可能不需要具有應用程式的其他部分所擁有的相同可用性層級，特別是直接參與使用者互動的 UI 和其他部分。 由於可將作業排入佇列，背景工作可能更容許延遲、重試的連線失敗，及影響可用性的其他因素。 不過，必須有足夠的容量以防止備份可能會封鎖佇列及影響整個應用程式的要求。

- **延展性**：背景工作對 UI 和應用程式的互動部分，可能有不同的延展性需求。 可能需要調整 UI 以符合要求的尖峰期，而未完成的背景工作可在較空閒的時間，由較少的計算執行個體數目完成。

- **災害復原**：如果僅裝載背景工作的要求可以直到工作再次可用為止，先排入佇列或延遲，則這些工作的計算執行個體失敗可能不會嚴重影響整體應用程式。 如果計算執行個體及/或工作可以在適當的間隔內重新啟動，可能不會影響應用程式的使用者。

- **安全性**：相較於 UI 或應用程式的其他部分，背景工作可能會有不同的安全性需求或限制。 藉由使用不同的計算執行個體，您可以為工作指定不同的安全性環境。 您也可以使用模式 (例如閘道管理員)，將背景計算執行個體與 UI 隔離，以提供最大的安全性和區隔。

- **效能**：您可以選擇背景工作的計算執行個體類型，以符合工作的效能特定需求。 這可能代表當工作不需要與 UI 具有相同的處理能力的話，可使用較便宜的計算選項；或如果他們需要額外的容量和資源的話，則需要更大的執行個體。

- **管理能力**：相較於主應用程式程式碼或 UI，背景工作可能有不同的開發和部署節奏。 將它們部署到不同的計算執行個體可簡化更新與版本控制。

- **成本**：加入計算執行個體來執行背景工作會增加裝載成本。 您應該仔細考量額外的容量與這些額外的成本之間的取捨。

如需詳細資訊，請參閱 [Leader Election Pattern (前置選擇模式)](../patterns/leader-election.md) 和 [Competing Consumers Pattern (競爭取用者模式)](../patterns/competing-consumers.md)。

## <a name="conflicts"></a>衝突

如果您有背景作業的多個執行個體，它們就可能爭用資源和服務的存取權，例如資料庫和儲存體。 這個並行存取可能會導致資源爭用情況，其可能會造成服務可用性及儲存體中資料完整性衝突。 您可以使用悲觀鎖定方法來解決資源爭用的情況。 這可避免相互競爭的工作執行個體同時存取服務或損毀資料。

另一種解決衝突的方法是將背景工作定義為單一性，如此只有一個執行中的執行個體。 不過，這會排除多個執行個體設定可提供的可靠性和效能權益。 若 UI 可以提供足夠的工作，以讓多個背景工作保持忙碌時更是如此。

請務必確定背景工作可以自動重新啟動，而且它有足夠的容量來應付需求的尖峰期。 您可配置給計算執行個體足夠的資源、實作可儲存要求的佇列機制，供稍後需求降低時執行；或使用這些技術組合，藉此完成這個工作。

## <a name="coordination"></a>協調

背景工作可能很複雜，而且可能需要執行多個個別的工作以產生結果或滿足所有需求。 通常在這些案例中可將工作分成較小的步驟或子工作，並由多個取用者執行。 多步驟作業可以更有效率且更具彈性，因為個別步驟可能可在多個作業中重複使用。 它也能輕鬆地新增、移除或修改步驟的順序。

協調多個工作和步驟可能相當困難，但是有三種常見的模式可用來引導您的實作方案：

- **將一個工作分解成多個可重複使用的步驟**。 應用程式可能需要在其處理的資訊上，執行具有不同複雜度的各種工作。 有一項實作此應用程式簡單但具彈性的方法，此方法為將這項處理序作為整合模組執行。 不過，這種方法可能會降低重構程式碼、最佳化它，或在應用程式的其他位置需要相同處理程序的部分時，重複使用它的機會。 如需詳細資訊，請參閱[管道與篩選模式](../patterns/pipes-and-filters.md)(英文)。

- **管理工作的步驟執行**。 應用程式可能會執行包含數個步驟 (其中有些可能會叫用遠端服務或存取遠端資源) 的工作。 個別的步驟可能會彼此獨立，但是它們會由實作工作的應用程式邏輯進行協調。 如需詳細資訊，請參閱[排程器代理程式監督員模式](../patterns/scheduler-agent-supervisor.md)(英文)。

- **管理失敗工作步驟的復原**。 如果一個或多個步驟失敗，應用程式可能需要對執行一系列步驟的工作進行復原 (它們會共同定義最終的一致作業)。 如需詳細資訊，請參閱[補償交易模式](../patterns/compensating-transaction.md)。

## <a name="resiliency-considerations"></a>恢復功能考量

背景工作必須具有恢復功能，以便為應用程式提供可靠的服務。 當您規劃和設計背景工作時，請考慮下列幾點：

- 背景工作必須能正常處理重新啟動，而不會損毀資料或導致應用程式不一致。 對於長時間執行或多步驟的工作，請考慮使用「檢查指出」  ，方法是在永續性儲存體中儲存作業狀態，或在佇列中作為訊息儲存 (如果這是適當的)。 例如，您可以在佇列的訊息中永久保存狀態資訊，並使用工作進度累加地更新此狀態資訊，以便從上次已知的良好檢查點處理工作，而不是從頭重新啟動。 使用 Azure 服務匯流排佇列時，您可以使用訊息工作階段來啟用相同的案例。 工作階段可讓您使用 [SetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate?view=azureservicebus-4.0.0) 和 [GetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate?view=azureservicebus-4.0.0) 方法來儲存和擷取應用程式處理狀態。 如需設計可靠的多步驟處理序和工作流程詳細資訊，請參閱 [Scheduler Agent Supervisor Pattern (排程器代理程式監督員模式)](../patterns/scheduler-agent-supervisor.md)。

- 當您使用佇列與背景工作通訊時，佇列可在應用程式高於一般負載時，作為緩衝區來儲存傳送給工作的要求。 如此能讓工作在較空閒期間使用 UI。 這也表示重新啟動不會封鎖 UI。 如需詳細資訊，請參閱[佇列型負載調節模式](../patterns/queue-based-load-leveling.md)。 如果某些工作比其他工作更重要，請考慮實作 [優先順序佇列模式](../patterns/priority-queue.md) (英文)，確保這些工作在較不重要的工作之前執行。

- 必須將由訊息或處理訊息初始化的背景工作設計為能夠處理不一致情況，例如以錯誤順序到達的訊息、重複導致錯誤的訊息 (通常稱為「有害訊息」 )，以及多次傳遞的訊息。 請考慮下列：

  - 必須依特定順序處理訊息，像是根據其現有值變更資料的訊息 (例如，將值加入至現有值)，可能不會以其原始的傳送順序到達。 或者，可能因每個執行個體上變動的負載，而依不同順序由背景工作的不同執行個體處理。 必須依特定順序處理的訊息應該包含序號、金鑰或其他某些指標，好讓背景工作使用以確保能依正確的順序處理這些訊息。 如果您使用 Azure 服務匯流排，您可以使用訊息工作階段來保證傳遞順序。 不過，盡可能設計處理序以讓訊息順序變得不重要，通常會更有效率。

  - 一般而言，背景工作會在佇列中查看訊息，這會暫時對其他訊息取用者隱藏這些訊息。 然後它會在成功處理完畢後刪除訊息。 如果背景工作在處理訊息時失敗，該訊息將會在查看逾時到期之後重新出現在佇列上。 它將會由工作的另一個執行個體進行處理，或在此執行個體的下一個處理週期進行處理。 如果訊息在取用者中發生相同的錯誤，它會封鎖工作、佇列，最終在佇列已滿時封鎖應用程式本身。 因此，請務必從佇列偵測並移除有害訊息。 如果您使用 Azure 服務匯流排，造成錯誤的訊息可能會被自動或手動地移至相關聯的無效信件佇列。

  - 佇列會保證「至少一次」  使用傳遞機制，但它們可能會傳遞相同的訊息多次。 此外，如果背景工作在處理訊息後、但在從佇列刪除前失敗，訊息將會變成可再次處理。 背景工作應該具有等冪性，這表示超過一次處理相同的訊息不會造成錯誤，或使應用程式的資料不一致。 某些作業自然是等冪，例如將儲存的值設為特定的新值。 不過，將值加入到現有的儲存值，而不檢查儲存值是否仍然與原先傳送的訊息相同之類的作業，可能會導致不一致情況。 Azure 服務匯流排佇列可以設定為自動移除重複的訊息。

  - 某些傳訊系統 (例如 Azure 儲存體佇列和 Azure 服務匯流排佇列) 支援 de-queue count 屬性，指出已從佇列讀取訊息的次數。 這在處理重複及有害訊息時很有用。 如需詳細資訊，請參閱[非同步傳訊入門](https://msdn.microsoft.com/library/dn589781.aspx)和[等冪性模式](https://blog.jonathanoliver.com/idempotency-patterns/)。

## <a name="scaling-and-performance-considerations"></a>調整和效能考量

背景工作必須提供足夠的效能，確保它們不會封鎖應用程式，或不會因系統負載不足而延遲作業時導致不一致。 一般而言，藉由調整裝載背景工作的計算執行個體可提升效能。 當您規劃和設計背景工作時，請考慮下列有關延展性和效能的重點：

- Azure 會根據目前的需求和負載，或預先定義的排程，來支援 Web 應用程式及虛擬機器裝載部署的自動調整 (相應放大及相應縮小回來都支援)。 使用此功能可確保整體應用程式具備足夠的效能，同時將執行階段成本降到最低。

- 當背景工作具有應用程式的其他部分的不同效能時 (例如，UI 或元件，如資料存取層)，可將不同計算服務的背景工作裝載在一起，讓 UI 和背景工作角色進行調整而不理會負載管理。 如果多個背景工作彼此有明顯不同的效能，請考慮將它們分成不同的背景工作並單獨調整每個類型。 不過請注意，這可能會增加執行階段成本。

- 只是調整計算資源可能不足以防止在高負載下損失效能。 您也可能需要調整儲存體佇列和其他資源，以避免整體處理鏈的單一點成為瓶頸。 另外，請考慮其他限制，例如儲存體的最大輸送量，和應用程式和背景工作依賴的其他服務。

- 您必須針對調整設計背景工作。 比方說，他們必須能夠以動態方式偵測正在使用的儲存體佇列數目，以接聽或傳送訊息給適當的佇列。

- 根據預設，WebJobs 會根據相關聯的 Azure Web 應用程式執行個體來調整。 不過，如果您只想要將 WebJob 當作單一執行個體來執行，您可以建立包含 JSON 資料 **{ "is_singleton": true }** 的 Settings.job 檔案。 這會強制 Azure 只能執行單一 Web 工作的執行個體，即使有多個相關聯的 Web 應用程式執行個體也一樣。 這可能是針對必須執行為單一執行個體之排程作業的有用技巧。

## <a name="related-patterns"></a>相關的模式

- [計算分割指引 (英文)](https://msdn.microsoft.com/library/dn589773.aspx)
