---
title: 自我修復設計
titleSuffix: Azure Application Architecture Guide
description: 具有復原功能的應用程式無須手動介入即可從失敗中復原。
author: MikeWasson
ms.date: 08/30/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: seojan19
ms.openlocfilehash: 5e5af0be41fa892e490d556ef4286d5367144fd9
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/20/2019
ms.locfileid: "58249503"
---
# <a name="design-for-self-healing"></a><span data-ttu-id="f14fe-103">自我修復設計</span><span class="sxs-lookup"><span data-stu-id="f14fe-103">Design for self healing</span></span>

## <a name="design-your-application-to-be-self-healing-when-failures-occur"></a><span data-ttu-id="f14fe-104">將您的應用程式設計為可在發生失敗時自我修復</span><span class="sxs-lookup"><span data-stu-id="f14fe-104">Design your application to be self healing when failures occur</span></span>

<span data-ttu-id="f14fe-105">在分散式系統中，發生失敗在所難免。</span><span class="sxs-lookup"><span data-stu-id="f14fe-105">In a distributed system, failures happen.</span></span> <span data-ttu-id="f14fe-106">硬體可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="f14fe-106">Hardware can fail.</span></span> <span data-ttu-id="f14fe-107">網路可能會暫時性失敗。</span><span class="sxs-lookup"><span data-stu-id="f14fe-107">The network can have transient failures.</span></span> <span data-ttu-id="f14fe-108">整個服務或區域很少會發生中斷，但即使如此仍必須加以規劃。</span><span class="sxs-lookup"><span data-stu-id="f14fe-108">Rarely, an entire service or region may experience a disruption, but even those must be planned for.</span></span>

<span data-ttu-id="f14fe-109">因此，請將應用程式設計為可在發生失敗時自我修復。</span><span class="sxs-lookup"><span data-stu-id="f14fe-109">Therefore, design an application to be self healing when failures occur.</span></span> <span data-ttu-id="f14fe-110">這種設計需要有蘊含三個面向的方法：</span><span class="sxs-lookup"><span data-stu-id="f14fe-110">This requires a three-pronged approach:</span></span>

- <span data-ttu-id="f14fe-111">偵測失敗。</span><span class="sxs-lookup"><span data-stu-id="f14fe-111">Detect failures.</span></span>
- <span data-ttu-id="f14fe-112">正常地回應失敗。</span><span class="sxs-lookup"><span data-stu-id="f14fe-112">Respond to failures gracefully.</span></span>
- <span data-ttu-id="f14fe-113">記錄和監視失敗，以提供作業方面的深入資訊。</span><span class="sxs-lookup"><span data-stu-id="f14fe-113">Log and monitor failures, to give operational insight.</span></span>

<span data-ttu-id="f14fe-114">該如何回應特定類型的失敗可能取決於您的應用程式可用性需求。</span><span class="sxs-lookup"><span data-stu-id="f14fe-114">How you respond to a particular type of failure may depend on your application's availability requirements.</span></span> <span data-ttu-id="f14fe-115">例如，如果您需要極高的可用性，您可以在發生區域性中斷的期間，自動容錯移轉到次要區域。</span><span class="sxs-lookup"><span data-stu-id="f14fe-115">For example, if you require very high availability, you might automatically fail over to a secondary region during a regional outage.</span></span> <span data-ttu-id="f14fe-116">不過，這麼做的成本會比單一區域部署的成本高。</span><span class="sxs-lookup"><span data-stu-id="f14fe-116">However, that will incur a higher cost than a single-region deployment.</span></span>

<span data-ttu-id="f14fe-117">此外，請不要只是考慮重大事件 (例如區域性中斷)，這種事件一般很少發生。</span><span class="sxs-lookup"><span data-stu-id="f14fe-117">Also, don't just consider big events like regional outages, which are generally rare.</span></span> <span data-ttu-id="f14fe-118">您應該更加專注在處理當地的短期性失敗，例如網路連線失敗或資料庫連線失敗。</span><span class="sxs-lookup"><span data-stu-id="f14fe-118">You should focus as much, if not more, on handling local, short-lived failures, such as network connectivity failures or failed database connections.</span></span>

## <a name="recommendations"></a><span data-ttu-id="f14fe-119">建議</span><span class="sxs-lookup"><span data-stu-id="f14fe-119">Recommendations</span></span>

<span data-ttu-id="f14fe-120">**重試失敗的作業**。</span><span class="sxs-lookup"><span data-stu-id="f14fe-120">**Retry failed operations**.</span></span> <span data-ttu-id="f14fe-121">可能會因為暫時遺失網路連線、卸除資料庫連線或服務忙碌時的逾時而發生暫時性失敗。</span><span class="sxs-lookup"><span data-stu-id="f14fe-121">Transient failures may occur due to momentary loss of network connectivity, a dropped database connection, or a timeout when a service is busy.</span></span> <span data-ttu-id="f14fe-122">請在應用程式中建置重試邏輯以處理暫時性失敗。</span><span class="sxs-lookup"><span data-stu-id="f14fe-122">Build retry logic into your application to handle transient failures.</span></span> <span data-ttu-id="f14fe-123">用戶端 SDK 會對許多 Azure 服務實作自動重試功能。</span><span class="sxs-lookup"><span data-stu-id="f14fe-123">For many Azure services, the client SDK implements automatic retries.</span></span> <span data-ttu-id="f14fe-124">如需詳細資訊，請參閱[暫時性錯誤處理][transient-fault-handling]和[重試模式][retry]。</span><span class="sxs-lookup"><span data-stu-id="f14fe-124">For more information, see [Transient fault handling][transient-fault-handling] and the [Retry pattern][retry].</span></span>

<span data-ttu-id="f14fe-125">**保護失敗的遠端服務 (斷路器)**。</span><span class="sxs-lookup"><span data-stu-id="f14fe-125">**Protect failing remote services (Circuit Breaker)**.</span></span> <span data-ttu-id="f14fe-126">在發生暫時性失敗後進行重試是不錯的舉動，但如果失敗持續發生，最終的結果可能是會有無數的呼叫者不斷衝擊失敗的服務。</span><span class="sxs-lookup"><span data-stu-id="f14fe-126">It's good to retry after a transient failure, but if the failure persists, you can end up with too many callers hammering a failing service.</span></span> <span data-ttu-id="f14fe-127">這可能會導致連鎖性失敗，因為要求會堵塞起來。</span><span class="sxs-lookup"><span data-stu-id="f14fe-127">This can lead to cascading failures, as requests back up.</span></span> <span data-ttu-id="f14fe-128">請使用[斷路器模式][circuit-breaker]，以在作業可能會失敗時快速檢錯 (而不進行遠端呼叫)。</span><span class="sxs-lookup"><span data-stu-id="f14fe-128">Use the [Circuit Breaker pattern][circuit-breaker] to fail fast (without making the remote call) when an operation is likely to fail.</span></span>

<span data-ttu-id="f14fe-129">**隔離重要的資源 (隔艙)**。</span><span class="sxs-lookup"><span data-stu-id="f14fe-129">**Isolate critical resources (Bulkhead)**.</span></span> <span data-ttu-id="f14fe-130">某個子系統發生失敗有時可能會產生連鎖反應。</span><span class="sxs-lookup"><span data-stu-id="f14fe-130">Failures in one subsystem can sometimes cascade.</span></span> <span data-ttu-id="f14fe-131">如果失敗造成某些資源 (例如執行緒或通訊端) 無法即時釋出，而導致資源耗盡，就會發生這個情況。</span><span class="sxs-lookup"><span data-stu-id="f14fe-131">This can happen if a failure causes some resources, such as threads or sockets, not to get freed in a timely manner, leading to resource exhaustion.</span></span> <span data-ttu-id="f14fe-132">為了避免這個問題，請將系統分割為隔離群組，讓一個分割區中的失敗不會使整個系統當機。</span><span class="sxs-lookup"><span data-stu-id="f14fe-132">To avoid this, partition a system into isolated groups, so that a failure in one partition does not bring down the entire system.</span></span>

<span data-ttu-id="f14fe-133">**執行負載調節**。</span><span class="sxs-lookup"><span data-stu-id="f14fe-133">**Perform load leveling**.</span></span> <span data-ttu-id="f14fe-134">應用程式可能會突然出現流量尖峰，可能會在後端灌爆服務。</span><span class="sxs-lookup"><span data-stu-id="f14fe-134">Applications may experience sudden spikes in traffic that can overwhelm services on the backend.</span></span> <span data-ttu-id="f14fe-135">若要避免這個問題，請使用[佇列型負載調節模式][load-level]，將工作項目排入佇列進而以非同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="f14fe-135">To avoid this, use the [Queue-Based Load Leveling pattern][load-level] to queue work items to run asynchronously.</span></span> <span data-ttu-id="f14fe-136">佇列會作為消除負載尖峰的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="f14fe-136">The queue acts as a buffer that smooths out peaks in the load.</span></span>

<span data-ttu-id="f14fe-137">**容錯移轉**。</span><span class="sxs-lookup"><span data-stu-id="f14fe-137">**Fail over**.</span></span> <span data-ttu-id="f14fe-138">如果有執行個體無法連線，請容錯移轉至其他執行個體。</span><span class="sxs-lookup"><span data-stu-id="f14fe-138">If an instance can't be reached, fail over to another instance.</span></span> <span data-ttu-id="f14fe-139">對於無狀態的項目 (例如 Web 伺服器)，請在負載平衡器或流量管理員後面放置數個執行個體。</span><span class="sxs-lookup"><span data-stu-id="f14fe-139">For things that are stateless, like a web server, put several instances behind a load balancer or traffic manager.</span></span> <span data-ttu-id="f14fe-140">對於有儲存狀態的物件 (例如資料庫)，請使用複本並容錯移轉。</span><span class="sxs-lookup"><span data-stu-id="f14fe-140">For things that store state, like a database, use replicas and fail over.</span></span> <span data-ttu-id="f14fe-141">根據資料存放區和其複寫方式，這可能需要應用程式處理最終一致性。</span><span class="sxs-lookup"><span data-stu-id="f14fe-141">Depending on the data store and how it replicates, this may require the application to deal with eventual consistency.</span></span>

<span data-ttu-id="f14fe-142">**補償失敗的交易**。</span><span class="sxs-lookup"><span data-stu-id="f14fe-142">**Compensate failed transactions**.</span></span> <span data-ttu-id="f14fe-143">一般來說，請避免分散式交易，因為這些交易會需要進行跨服務和資源的協調。</span><span class="sxs-lookup"><span data-stu-id="f14fe-143">In general, avoid distributed transactions, as they require coordination across services and resources.</span></span> <span data-ttu-id="f14fe-144">相反地，請撰寫從較小型的個別交易所進行的作業。</span><span class="sxs-lookup"><span data-stu-id="f14fe-144">Instead, compose an operation from smaller individual transactions.</span></span> <span data-ttu-id="f14fe-145">如果作業中途失敗，請使用[補償交易][compensating-transactions]來復原任何已完成的步驟。</span><span class="sxs-lookup"><span data-stu-id="f14fe-145">If the operation fails midway through, use [Compensating Transactions][compensating-transactions] to undo any step that already completed.</span></span>

<span data-ttu-id="f14fe-146">**為長時間執行的交易設立檢查點**。</span><span class="sxs-lookup"><span data-stu-id="f14fe-146">**Checkpoint long-running transactions**.</span></span> <span data-ttu-id="f14fe-147">檢查點可以在長時間執行的作業失敗時提供復原功能。</span><span class="sxs-lookup"><span data-stu-id="f14fe-147">Checkpoints can provide resiliency if a long-running operation fails.</span></span> <span data-ttu-id="f14fe-148">當作業重新啟動時 (例如，有其他 VM 選擇了此作業)，它便可從最後一個檢查點繼續進行。</span><span class="sxs-lookup"><span data-stu-id="f14fe-148">When the operation restarts (for example, it is picked up by another VM), it can be resumed from the last checkpoint.</span></span>

<span data-ttu-id="f14fe-149">**正常降級**。</span><span class="sxs-lookup"><span data-stu-id="f14fe-149">**Degrade gracefully**.</span></span> <span data-ttu-id="f14fe-150">有時候您無法解決問題，但您可以提供仍然有用的精簡功能。</span><span class="sxs-lookup"><span data-stu-id="f14fe-150">Sometimes you can't work around a problem, but you can provide reduced functionality that is still useful.</span></span> <span data-ttu-id="f14fe-151">請考慮顯示書籍目錄的應用程式。</span><span class="sxs-lookup"><span data-stu-id="f14fe-151">Consider an application that shows a catalog of books.</span></span> <span data-ttu-id="f14fe-152">如果應用程式無法擷取封面的縮圖映像，它可能會顯示預留位置映像。</span><span class="sxs-lookup"><span data-stu-id="f14fe-152">If the application can't retrieve the thumbnail image for the cover, it might show a placeholder image.</span></span> <span data-ttu-id="f14fe-153">整個子系統對於應用程式來說可能不怎麼重要。</span><span class="sxs-lookup"><span data-stu-id="f14fe-153">Entire subsystems might be noncritical for the application.</span></span> <span data-ttu-id="f14fe-154">例如，在電子商務網站中，顯示產品建議可能就不如處理訂單來得重要。</span><span class="sxs-lookup"><span data-stu-id="f14fe-154">For example, in an e-commerce site, showing product recommendations is probably less critical than processing orders.</span></span>

<span data-ttu-id="f14fe-155">**對用戶端節流**。</span><span class="sxs-lookup"><span data-stu-id="f14fe-155">**Throttle clients**.</span></span> <span data-ttu-id="f14fe-156">有時候一小撮的使用者會產生過大的負載，而讓您的應用程式提供給其他使用者的可用性變低。</span><span class="sxs-lookup"><span data-stu-id="f14fe-156">Sometimes a small number of users create excessive load, which can reduce your application's availability for other users.</span></span> <span data-ttu-id="f14fe-157">在此情況下，請將該用戶端節流一段時間。</span><span class="sxs-lookup"><span data-stu-id="f14fe-157">In this situation, throttle the client for a certain period of time.</span></span> <span data-ttu-id="f14fe-158">請參閱[節流模式][throttle]。</span><span class="sxs-lookup"><span data-stu-id="f14fe-158">See the [Throttling pattern][throttle].</span></span>

<span data-ttu-id="f14fe-159">**封鎖不良執行者**。</span><span class="sxs-lookup"><span data-stu-id="f14fe-159">**Block bad actors**.</span></span> <span data-ttu-id="f14fe-160">對用戶端節流並不代表用戶端有惡意舉動。</span><span class="sxs-lookup"><span data-stu-id="f14fe-160">Just because you throttle a client, it doesn't mean client was acting maliciously.</span></span> <span data-ttu-id="f14fe-161">這麼做只代表用戶端已超過其服務配額。</span><span class="sxs-lookup"><span data-stu-id="f14fe-161">It just means the client exceeded their service quota.</span></span> <span data-ttu-id="f14fe-162">但是，如果用戶端持續超過其配額或另有不當行為，您可將其封鎖。</span><span class="sxs-lookup"><span data-stu-id="f14fe-162">But if a client consistently exceeds their quota or otherwise behaves badly, you might block them.</span></span> <span data-ttu-id="f14fe-163">請定義頻外程序，以供使用者要求解除封鎖。</span><span class="sxs-lookup"><span data-stu-id="f14fe-163">Define an out-of-band process for user to request getting unblocked.</span></span>

<span data-ttu-id="f14fe-164">**使用選出領導者**。</span><span class="sxs-lookup"><span data-stu-id="f14fe-164">**Use leader election**.</span></span> <span data-ttu-id="f14fe-165">當您需要協調工作時，請使用[選出領導者][leader-election]來選取協調器。</span><span class="sxs-lookup"><span data-stu-id="f14fe-165">When you need to coordinate a task, use [Leader Election][leader-election] to select a coordinator.</span></span> <span data-ttu-id="f14fe-166">這樣一來，協調器就不會成為單一失敗點。</span><span class="sxs-lookup"><span data-stu-id="f14fe-166">That way, the coordinator is not a single point of failure.</span></span> <span data-ttu-id="f14fe-167">如果協調器失敗，系統會選取新的協調器。</span><span class="sxs-lookup"><span data-stu-id="f14fe-167">If the coordinator fails, a new one is selected.</span></span> <span data-ttu-id="f14fe-168">請不要從頭開始實作選出領導者演算法，而是要考慮使用現成的解決方案，例如 Zookeeper。</span><span class="sxs-lookup"><span data-stu-id="f14fe-168">Rather than implement a leader election algorithm from scratch, consider an off-the-shelf solution such as Zookeeper.</span></span>

<span data-ttu-id="f14fe-169">**植入錯誤以進行測試**。</span><span class="sxs-lookup"><span data-stu-id="f14fe-169">**Test with fault injection**.</span></span> <span data-ttu-id="f14fe-170">成功的路徑總是經過完善的測試，但失敗的路徑則不是。</span><span class="sxs-lookup"><span data-stu-id="f14fe-170">All too often, the success path is well tested but not the failure path.</span></span> <span data-ttu-id="f14fe-171">系統可能會在生產環境中執行很久之後，才走到失敗的路徑。</span><span class="sxs-lookup"><span data-stu-id="f14fe-171">A system could run in production for a long time before a failure path is exercised.</span></span> <span data-ttu-id="f14fe-172">請使用錯誤植入機制，以測試系統在遇到失敗時是否能復原，方法為觸發實際的失敗或模擬失敗。</span><span class="sxs-lookup"><span data-stu-id="f14fe-172">Use fault injection to test the resiliency of the system to failures, either by triggering actual failures or by simulating them.</span></span>

<span data-ttu-id="f14fe-173">**採用混沌工程**。</span><span class="sxs-lookup"><span data-stu-id="f14fe-173">**Embrace chaos engineering**.</span></span> <span data-ttu-id="f14fe-174">混沌工程延伸了錯誤植入的概念，它會在生產執行個體中隨機植入失敗或異常狀況。</span><span class="sxs-lookup"><span data-stu-id="f14fe-174">Chaos engineering extends the notion of fault injection, by randomly injecting failures or abnormal conditions into production instances.</span></span>

<span data-ttu-id="f14fe-175">如需有結構地讓您的應用程式能夠自我修復，請參閱[設計具有復原功能的 Azure 應用程式][resiliency-overview]。</span><span class="sxs-lookup"><span data-stu-id="f14fe-175">For a structured approach to making your applications self healing, see [Design resilient applications for Azure][resiliency-overview].</span></span>

<!-- links -->

[circuit-breaker]: ../../patterns/circuit-breaker.md
[compensating-transactions]: ../../patterns/compensating-transaction.md
[leader-election]: ../../patterns/leader-election.md
[load-level]: ../../patterns/queue-based-load-leveling.md
[resiliency-overview]: ../../resiliency/index.md
[retry]: ../../patterns/retry.md
[throttle]: ../../patterns/throttling.md
[transient-fault-handling]: ../../best-practices/transient-faults.md
