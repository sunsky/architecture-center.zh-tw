---
title: 微服務的 CI/CD
description: 微服務的持續整合與持續傳遞。
author: MikeWasson
ms.date: 03/27/2019
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: f7f3f3d48087db51c40f134e3e4cf11ec58501bb
ms.sourcegitcommit: d58e6b2b891c9c99e951c59f15fce71addcb96b1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/12/2019
ms.locfileid: "59533085"
---
# <a name="cicd-for-microservices-architectures"></a><span data-ttu-id="a9dc1-103">微服務架構的 CI/CD</span><span class="sxs-lookup"><span data-stu-id="a9dc1-103">CI/CD for microservices architectures</span></span>

<span data-ttu-id="a9dc1-104">更快速的發行週期是其中一個微服務架構的主要優點。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-104">Faster release cycles are one of the major advantages of microservices architectures.</span></span> <span data-ttu-id="a9dc1-105">但沒有很好的 CI/CD 程序，就無法達到微服務所承諾的靈活度。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-105">But without a good CI/CD process, you won't achieve the agility that microservices promise.</span></span> <span data-ttu-id="a9dc1-106">本文章會說明所面臨的挑戰，並建議問題的一些方法。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-106">This article describes the challenges and recommends some approaches to the problem.</span></span>

## <a name="what-is-cicd"></a><span data-ttu-id="a9dc1-107">什麼是 CI/CD？</span><span class="sxs-lookup"><span data-stu-id="a9dc1-107">What is CI/CD?</span></span>

<span data-ttu-id="a9dc1-108">當我們談論 CI/CD 時，我們真正的意思了數個相關的處理程序：持續整合、持續傳遞和持續部署。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-108">When we talk about CI/CD, we're really talking about several related processes: Continuous integration, continuous delivery, and continuous deployment.</span></span>

- <span data-ttu-id="a9dc1-109">**持續整合**。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-109">**Continuous integration**.</span></span> <span data-ttu-id="a9dc1-110">程式碼變更經常會併入主要分支。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-110">Code changes are frequently merged into the main branch.</span></span> <span data-ttu-id="a9dc1-111">自動化建置和測試程序可讓您確保主要分支中的程式碼一定是實際執行品質。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-111">Automated build and test processes ensure that code in the main branch is always production-quality.</span></span>

- <span data-ttu-id="a9dc1-112">**持續傳遞**。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-112">**Continuous delivery**.</span></span> <span data-ttu-id="a9dc1-113">變更任何程式碼傳遞 CI 程序會自動發佈到類似生產的環境中。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-113">Any code changes that pass the CI process are automatically published to a production-like environment.</span></span> <span data-ttu-id="a9dc1-114">部署至即時生產環境可能需要手動核准，除此之外皆是自動化作業。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-114">Deployment into the live production environment may require manual approval, but is otherwise automated.</span></span> <span data-ttu-id="a9dc1-115">這麼做的目的是，您的程式碼應該總是「準備好」部署到生產環境。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-115">The goal is that your code should always be *ready* to deploy into production.</span></span>

- <span data-ttu-id="a9dc1-116">**連續部署**。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-116">**Continuous deployment**.</span></span> <span data-ttu-id="a9dc1-117">程式碼變更前的兩個步驟會自動部署該階段*運行*。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-117">Code changes that pass the previous two steps are automatically deployed *into production*.</span></span>

<span data-ttu-id="a9dc1-118">針對微服務架構，以下是強固 CI/CD 程序的一些目標：</span><span class="sxs-lookup"><span data-stu-id="a9dc1-118">Here are some goals of a robust CI/CD process for a microservices architecture:</span></span>

- <span data-ttu-id="a9dc1-119">每個小組都可建置並部署獨立擁有的服務，而不會影響或干擾其他小組。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-119">Each team can build and deploy the services that it owns independently, without affecting or disrupting other teams.</span></span>

- <span data-ttu-id="a9dc1-120">將新版服務部署到生產環境之前，可先部署到開發/測試/QA 環境來進行驗證。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-120">Before a new version of a service is deployed to production, it gets deployed to dev/test/QA environments for validation.</span></span> <span data-ttu-id="a9dc1-121">在每個階段上強制執行品質閘門 (Quality Gate)。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-121">Quality gates are enforced at each stage.</span></span>

- <span data-ttu-id="a9dc1-122">服務的新版本可以與舊版並存部署。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-122">A new version of a service can be deployed side by side with the previous version.</span></span>

- <span data-ttu-id="a9dc1-123">有足夠的存取控制原則。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-123">Sufficient access control policies are in place.</span></span>

- <span data-ttu-id="a9dc1-124">適用於容器化工作負載，您可以信任的容器映像，部署到生產環境。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-124">For containerized workloads, you can trust the container images that are deployed to production.</span></span>

## <a name="why-a-robust-cicd-pipeline-matters"></a><span data-ttu-id="a9dc1-125">為何很重要的強固的 CI/CD 管線</span><span class="sxs-lookup"><span data-stu-id="a9dc1-125">Why a robust CI/CD pipeline matters</span></span>

<span data-ttu-id="a9dc1-126">在傳統的單體式應用程式中，沒有一個建置管線，其輸出是可執行檔的應用程式。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-126">In a traditional monolithic application, there is a single build pipeline whose output is the application executable.</span></span> <span data-ttu-id="a9dc1-127">所有開發工作都會饋送到此管線中。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-127">All development work feeds into this pipeline.</span></span> <span data-ttu-id="a9dc1-128">如果發現高優先順序的錯誤 (bug)，則必須整合、測試及發行修正程式，這可能會延遲新功能的發行。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-128">If a high-priority bug is found, a fix must be integrated, tested, and published, which can delay the release of new features.</span></span> <span data-ttu-id="a9dc1-129">您可以藉由擁有構造良好的模組，並使用程式碼變更的影響降到最低的功能分支來緩和這些問題。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-129">You can mitigate these problems by having well-factored modules and using feature branches to minimize the impact of code changes.</span></span> <span data-ttu-id="a9dc1-130">但隨著應用程式日益複雜，並新增了更多功能，單體的發行程序就變得更加脆弱並可能中斷。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-130">But as the application grows more complex, and more features are added, the release process for a monolith tends to become more brittle and likely to break.</span></span>

<span data-ttu-id="a9dc1-131">根據微服務的原理，絕不會有每個小組都必須排隊的冗長發行序列。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-131">Following the microservices philosophy, there should never be a long release train where every team has to get in line.</span></span> <span data-ttu-id="a9dc1-132">建立服務 "A" 的小組可以隨時發行更新，而不需等待服務 "B" 的變更來進行合併、測試和部署。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-132">The team that builds service "A" can release an update at any time, without waiting for changes in service "B" to be merged, tested, and deployed.</span></span>

![CI/CD 整合型的圖表](./images/cicd-monolith.png)

<span data-ttu-id="a9dc1-134">若要達到高發行速度，您的發行管線必須自動化且高度可靠，風險降至最低。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-134">To achieve a high release velocity, your release pipeline must be automated and highly reliable, to minimize risk.</span></span> <span data-ttu-id="a9dc1-135">如果您發行至生產環境的每日或一天多次，迴歸或服務中斷必須是非常罕見。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-135">If you release to production daily or multiple times a day, regressions or service disruptions must be very rare.</span></span> <span data-ttu-id="a9dc1-136">同時，如果部署了錯誤的更新，您必須有可靠的方法能快速復原或向前復原至舊版的服務。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-136">At the same time, if a bad update does get deployed, you must have a reliable way to quickly roll back or roll forward to a previous version of a service.</span></span>

## <a name="challenges"></a><span data-ttu-id="a9dc1-137">挑戰</span><span class="sxs-lookup"><span data-stu-id="a9dc1-137">Challenges</span></span>

- <span data-ttu-id="a9dc1-138">**許多小型獨立的程式碼基底**。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-138">**Many small independent code bases**.</span></span> <span data-ttu-id="a9dc1-139">每個小組需利用自己的建置管線，負責建立自己的服務。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-139">Each team is responsible for building its own service, with its own build pipeline.</span></span> <span data-ttu-id="a9dc1-140">在某些組織中，小組可以使用不同的程式碼存放庫。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-140">In some organizations, teams may use separate code repositories.</span></span> <span data-ttu-id="a9dc1-141">了解如何建置系統會散佈到各小組，而在組織中沒有人知道如何部署整個應用程式的情況可能會導致個別的存放庫。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-141">Separate repositories can lead to a situation where the knowledge of how to build the system is spread across teams, and nobody in the organization knows how to deploy the entire application.</span></span> <span data-ttu-id="a9dc1-142">例如，如果您需要快速部署到新的叢集，災害復原案例會發生什麼情況？</span><span class="sxs-lookup"><span data-stu-id="a9dc1-142">For example, what happens in a disaster recovery scenario, if you need to quickly deploy to a new cluster?</span></span>

    <span data-ttu-id="a9dc1-143">**降低風險**：具有統一且自動化的管線，以建置及部署服務，因此這項知識不會 「 隱藏 」 內每個小組。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-143">**Mitigation**: Have a unified and automated pipeline to build and deploy services, so that this knowledge is not "hidden" within each team.</span></span>

- <span data-ttu-id="a9dc1-144">**多個語言和架構**。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-144">**Multiple languages and frameworks**.</span></span> <span data-ttu-id="a9dc1-145">如果每個小組都使用自己的各項技術，則可能很難建立適用於整個組織的單一建置程序。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-145">With each team using its own mix of technologies, it can be difficult to create a single build process that works across the organization.</span></span> <span data-ttu-id="a9dc1-146">建置程序必須有足夠的彈性，每個小組才能針對其選擇的語言或架構進行調整。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-146">The build process must be flexible enough that every team can adapt it for their choice of language or framework.</span></span>

    <span data-ttu-id="a9dc1-147">**降低風險**：將容器化每個服務的建置程序。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-147">**Mitigation**: Containerize the build process for each service.</span></span> <span data-ttu-id="a9dc1-148">如此一來，建置系統只需要能夠執行容器。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-148">That way, the build system just needs to be able to run the containers.</span></span>

- <span data-ttu-id="a9dc1-149">**整合及負載測試**。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-149">**Integration and load testing**.</span></span> <span data-ttu-id="a9dc1-150">如果小組依照自己的步調發行更新，則要設計強固的端對端測試可能具有挑戰性，特別是在服務相依於其他服務時。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-150">With teams releasing updates at their own pace, it can be challenging to design robust end-to-end testing, especially when services have dependencies on other services.</span></span> <span data-ttu-id="a9dc1-151">此外，執行完整生產叢集可能很昂貴，因此不太可能每個小組將會在生產環境的縮放比例，純粹作為測試執行它自己的完整叢集。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-151">Moreover, running a full production cluster can be expensive, so it's unlikely that every team will run its own full cluster at production scales, just for testing.</span></span>

- <span data-ttu-id="a9dc1-152">**發行管理**。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-152">**Release management**.</span></span> <span data-ttu-id="a9dc1-153">每個小組應該能夠將更新部署到生產環境。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-153">Every team should be able to deploy an update to production.</span></span> <span data-ttu-id="a9dc1-154">但這不表示每個小組成員都有權限這麼做。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-154">That doesn't mean that every team member has permissions to do so.</span></span> <span data-ttu-id="a9dc1-155">不過，擁有集中的發行管理員角色可能會降低部署的速度。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-155">But having a centralized Release Manager role can reduce the velocity of deployments.</span></span>

    <span data-ttu-id="a9dc1-156">**Migitation**:因此您的 CI/CD 程序愈加自動化和可靠，中央授權的需求就愈低。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-156">**Migitation**: The more that your CI/CD process is automated and reliable, the less there should be a need for a central authority.</span></span> <span data-ttu-id="a9dc1-157">儘管如此，您可能使用不同的原則來發行主要功能更新和次要錯誤修正。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-157">That said, you might have different policies for releasing major feature updates versus minor bug fixes.</span></span> <span data-ttu-id="a9dc1-158">分散管理並不表示零治理。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-158">Being decentralized doesn't mean zero governance.</span></span>

- <span data-ttu-id="a9dc1-159">**服務更新**。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-159">**Service updates**.</span></span> <span data-ttu-id="a9dc1-160">當您將服務更新為新版本時，其不得中斷與其相依的其他服務。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-160">When you update a service to a new version, it shouldn't break other services that depend on it.</span></span>

    <span data-ttu-id="a9dc1-161">**降低風險**：使用部署技術，例如藍綠色或淡黃色版本的非中斷變更。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-161">**Mitigation**: Use deployment techniques such as blue-green or canary release for non-breaking changes.</span></span> <span data-ttu-id="a9dc1-162">重大 API 變更，部署新的版本與舊版並存。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-162">For breaking API changes, deploy the new version side by side with the previous version.</span></span> <span data-ttu-id="a9dc1-163">如此一來，使用先前的 API 的服務可以更新並測試新的 API。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-163">That way, services that consume the previous API can be updated and tested for the new API.</span></span> <span data-ttu-id="a9dc1-164">請參閱[更新服務](#updating-services)底下。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-164">See [Updating services](#updating-services), below.</span></span>

## <a name="monorepo-vs-multi-repo"></a><span data-ttu-id="a9dc1-165">Monorepo vs 多存放庫</span><span class="sxs-lookup"><span data-stu-id="a9dc1-165">Monorepo vs multi-repo</span></span>

<span data-ttu-id="a9dc1-166">建立 CI/CD 工作流程之前，您必須知道如何結構化和管理程式碼基底。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-166">Before creating a CI/CD workflow, you must know how the code base will be structured and managed.</span></span>

- <span data-ttu-id="a9dc1-167">小組是使用不同的存放庫或使用 monorepo (單一存放庫)？</span><span class="sxs-lookup"><span data-stu-id="a9dc1-167">Do teams work in separate respositories or in a monorepo (single respository)?</span></span>
- <span data-ttu-id="a9dc1-168">您的分支策略是什麼？</span><span class="sxs-lookup"><span data-stu-id="a9dc1-168">What is your branching strategy?</span></span>
- <span data-ttu-id="a9dc1-169">誰可以將程式碼推送至生產環境？</span><span class="sxs-lookup"><span data-stu-id="a9dc1-169">Who can push code to production?</span></span> <span data-ttu-id="a9dc1-170">有版本管理員角色嗎？</span><span class="sxs-lookup"><span data-stu-id="a9dc1-170">Is there a release manager role?</span></span>

<span data-ttu-id="a9dc1-171">雖然 monorepo 方法較受青睞，但這兩者都有優點和缺點。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-171">The monorepo approach has been gaining favor but there are advantages and disadvantages to both.</span></span>

| &nbsp; | <span data-ttu-id="a9dc1-172">Monorepo</span><span class="sxs-lookup"><span data-stu-id="a9dc1-172">Monorepo</span></span> | <span data-ttu-id="a9dc1-173">多個存放庫</span><span class="sxs-lookup"><span data-stu-id="a9dc1-173">Multiple repos</span></span> |
|--------|----------|----------------|
| <span data-ttu-id="a9dc1-174">**優點**</span><span class="sxs-lookup"><span data-stu-id="a9dc1-174">**Advantages**</span></span> | <span data-ttu-id="a9dc1-175">程式碼共用</span><span class="sxs-lookup"><span data-stu-id="a9dc1-175">Code sharing</span></span><br/><span data-ttu-id="a9dc1-176">可更輕鬆地將程式碼及工具標準化</span><span class="sxs-lookup"><span data-stu-id="a9dc1-176">Easier to standardize code and tooling</span></span><br/><span data-ttu-id="a9dc1-177">可更輕鬆地重構程式碼</span><span class="sxs-lookup"><span data-stu-id="a9dc1-177">Easier to refactor code</span></span><br/><span data-ttu-id="a9dc1-178">可搜尋性 - 程式碼的單一檢視</span><span class="sxs-lookup"><span data-stu-id="a9dc1-178">Discoverability - single view of the code</span></span><br/> | <span data-ttu-id="a9dc1-179">每個小組有明確擁有權</span><span class="sxs-lookup"><span data-stu-id="a9dc1-179">Clear ownership per team</span></span><br/><span data-ttu-id="a9dc1-180">可能可減少合併衝突</span><span class="sxs-lookup"><span data-stu-id="a9dc1-180">Potentially fewer merge conflicts</span></span><br/><span data-ttu-id="a9dc1-181">有助於強制分離微服務</span><span class="sxs-lookup"><span data-stu-id="a9dc1-181">Helps to enforce decoupling of microservices</span></span> |
| <span data-ttu-id="a9dc1-182">**挑戰**</span><span class="sxs-lookup"><span data-stu-id="a9dc1-182">**Challenges**</span></span> | <span data-ttu-id="a9dc1-183">共用程式碼的變更可能會影響多個微服務</span><span class="sxs-lookup"><span data-stu-id="a9dc1-183">Changes to shared code can affect multiple microservices</span></span><br/><span data-ttu-id="a9dc1-184">很可能會有合併衝突</span><span class="sxs-lookup"><span data-stu-id="a9dc1-184">Greater potential for merge conflicts</span></span><br/><span data-ttu-id="a9dc1-185">工具必須擴充為大型程式碼基底</span><span class="sxs-lookup"><span data-stu-id="a9dc1-185">Tooling must scale to a large code base</span></span><br/><span data-ttu-id="a9dc1-186">存取控制</span><span class="sxs-lookup"><span data-stu-id="a9dc1-186">Access control</span></span><br/><span data-ttu-id="a9dc1-187">更複雜的部署程序</span><span class="sxs-lookup"><span data-stu-id="a9dc1-187">More complex deployment process</span></span> | <span data-ttu-id="a9dc1-188">難以共用程式碼</span><span class="sxs-lookup"><span data-stu-id="a9dc1-188">Harder to share code</span></span><br/><span data-ttu-id="a9dc1-189">難以強制執行編碼標準</span><span class="sxs-lookup"><span data-stu-id="a9dc1-189">Harder to enforce coding standards</span></span><br/><span data-ttu-id="a9dc1-190">相依性管理</span><span class="sxs-lookup"><span data-stu-id="a9dc1-190">Dependency management</span></span><br/><span data-ttu-id="a9dc1-191">擴散的程式碼基底、不佳的探索能力</span><span class="sxs-lookup"><span data-stu-id="a9dc1-191">Diffuse code base, poor discoverability</span></span><br/><span data-ttu-id="a9dc1-192">缺少共用的基礎結構</span><span class="sxs-lookup"><span data-stu-id="a9dc1-192">Lack of shared infrastructure</span></span>

## <a name="updating-services"></a><span data-ttu-id="a9dc1-193">更新服務</span><span class="sxs-lookup"><span data-stu-id="a9dc1-193">Updating services</span></span>

<span data-ttu-id="a9dc1-194">有各種策略可用來更新已在生產環境中的服務。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-194">There are various strategies for updating a service that's already in production.</span></span> <span data-ttu-id="a9dc1-195">我們在此討論三個常見的選項：輪流更新、藍綠色部署和 Canary 版本。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-195">Here we discuss three common options: Rolling update, blue-green deployment, and canary release.</span></span>

### <a name="rolling-updates"></a><span data-ttu-id="a9dc1-196">輪流更新</span><span class="sxs-lookup"><span data-stu-id="a9dc1-196">Rolling updates</span></span>

<span data-ttu-id="a9dc1-197">在輪流更新中，您會部署新的服務執行個體，而新的執行個體會立刻開始接收要求。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-197">In a rolling update, you deploy new instances of a service, and the new instances start receiving requests right away.</span></span> <span data-ttu-id="a9dc1-198">隨著新執行個體的出現，系統會移除先前的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-198">As the new instances come up, the previous instances are removed.</span></span>

<span data-ttu-id="a9dc1-199">**範例。**</span><span class="sxs-lookup"><span data-stu-id="a9dc1-199">**Example.**</span></span> <span data-ttu-id="a9dc1-200">在 Kubernetes 中，輪流更新，會是預設行為，當您更新部署的 pod 規格時。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-200">In Kubernetes, rolling updates are the default behavior when you update the pod spec for a Deployment.</span></span> <span data-ttu-id="a9dc1-201">部署控制器會為已更新的 pod 建立新的 ReplicaSet。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-201">The Deployment controller creates a new ReplicaSet for the updated pods.</span></span> <span data-ttu-id="a9dc1-202">然後它會相應增加新的 ReplicaSet，同時相應減少舊的 ReplicaSet，以維持所需的複本計數。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-202">Then it scales up the new ReplicaSet while scaling down the old one, to maintain the desired replica count.</span></span> <span data-ttu-id="a9dc1-203">在新的 pod 備妥之前，舊的 pod 不會遭到刪除。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-203">It doesn't delete old pods until the new ones are ready.</span></span> <span data-ttu-id="a9dc1-204">所以您可以回復更新如有需要 Kubernetes 會保存歷程記錄的更新。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-204">Kubernetes keeps a history of the update, so you can roll back an update if needed.</span></span>

<span data-ttu-id="a9dc1-205">輪流更新的其中一項挑戰就是在更新過程中，新舊版本會混合執行及接收流量。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-205">One challenge of rolling updates is that during the update process, a mix of old and new versions are running and receiving traffic.</span></span> <span data-ttu-id="a9dc1-206">在這段期間，所有要求會路由傳送至任一個版本。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-206">During this period, any request could get routed to either of the two versions.</span></span>

<span data-ttu-id="a9dc1-207">重大 API 變更，最好是支援並存，這兩個版本，直到前一版的所有用戶端會更新。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-207">For breaking API changes, a good practice is to support both versions side by side, until all clients of the previous version are updated.</span></span> <span data-ttu-id="a9dc1-208">請參閱[API 版本設定](./design/api-design.md#api-versioning)。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-208">See [API versioning](./design/api-design.md#api-versioning).</span></span>

### <a name="blue-green-deployment"></a><span data-ttu-id="a9dc1-209">藍綠部署</span><span class="sxs-lookup"><span data-stu-id="a9dc1-209">Blue-green deployment</span></span>

<span data-ttu-id="a9dc1-210">在藍綠色部署中，您可以一起部署新版本與前一個版本。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-210">In a blue-green deployment, you deploy the new version alongside the previous version.</span></span> <span data-ttu-id="a9dc1-211">在您驗證新版本之後，立刻將所有流量從前一個版本切換到新版本。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-211">After you validate the new version, you switch all traffic at once from the previous version to the new version.</span></span> <span data-ttu-id="a9dc1-212">切換之後，您可監視應用程式是否有任何問題。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-212">After the switch, you monitor the application for any problems.</span></span> <span data-ttu-id="a9dc1-213">如果發生錯誤，您可以換回舊版本。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-213">If something goes wrong, you can swap back to the old version.</span></span> <span data-ttu-id="a9dc1-214">假設沒有任何問題，您可以刪除舊版本。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-214">Assuming there are no problems, you can delete the old version.</span></span>

<span data-ttu-id="a9dc1-215">使用更傳統的單體式或多層式架構應用程式，藍綠部署通常是指佈建兩個相同的環境。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-215">With a more traditional monolithic or N-tier application, blue-green deployment generally meant provisioning two identical environments.</span></span> <span data-ttu-id="a9dc1-216">您會將新版本部署到預備環境，然後將用戶端流量重新導向至預備環境 &mdash; 例如，藉由交換 VIP 位址。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-216">You would deploy the new version to a staging environment, then redirect client traffic to the staging environment &mdash; for example, by swapping VIP addresses.</span></span> <span data-ttu-id="a9dc1-217">在微服務架構中，更新會發生在微服務層級，因此您通常會將更新部署到相同的環境，並使用服務探索機制來交換。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-217">In a microservices architecture, updates happen at the microservice level, so you would typically deploy the update into the same environment and use a service discovery mechanism to swap.</span></span>

<span data-ttu-id="a9dc1-218">**範例**。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-218">**Example**.</span></span> <span data-ttu-id="a9dc1-219">在 Kubernetes 中，您不需佈建個別的叢集來進行藍綠部署。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-219">In Kubernetes, you don't need to provision a separate cluster to do blue-green deployments.</span></span> <span data-ttu-id="a9dc1-220">您反而可以利用選取器。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-220">Instead, you can take advantage of selectors.</span></span> <span data-ttu-id="a9dc1-221">利用新的 pod 規格和一組不同的標籤，建立新的部署資源。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-221">Create a new Deployment resource with a new pod spec and a different set of labels.</span></span> <span data-ttu-id="a9dc1-222">建立此部署，而不需刪除先前的部署，或修改指向它的服務。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-222">Create this deployment, without deleting the previous deployment or modifying the service that points to it.</span></span> <span data-ttu-id="a9dc1-223">當新的 pod 執行時，您可以更新服務的選取器，以符合新的部署。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-223">Once the new pods are running, you can update the service's selector to match the new deployment.</span></span>

<span data-ttu-id="a9dc1-224">藍綠部署的缺點之一是在更新期間，您會執行兩倍 pod，服務 （目前和下一步）。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-224">One drawback of blue-green deployment is that during the update, you are running twice as many pods for the service (current and next).</span></span> <span data-ttu-id="a9dc1-225">如果 pod 需要大量 CPU 或記憶體資源，您可能需要暫時相應放大叢集，以處理資源耗用。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-225">If the pods require a lot of CPU or memory resources, you may need to scale out the cluster temporarily to handle the resource consumption.</span></span>

### <a name="canary-release"></a><span data-ttu-id="a9dc1-226">Canary 版本</span><span class="sxs-lookup"><span data-stu-id="a9dc1-226">Canary release</span></span>

<span data-ttu-id="a9dc1-227">在 Canary 版本中，您會向少數用戶端推出更新的版本。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-227">In a canary release, you roll out an updated version to a small number of clients.</span></span> <span data-ttu-id="a9dc1-228">然後您會先監視新服務的行為，然後再向所有的用戶端推出該服務。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-228">Then you monitor the behavior of the new service before rolling it out to all clients.</span></span> <span data-ttu-id="a9dc1-229">這可讓您以控制方式進行緩慢推出、觀察實際資料，以及在所有客戶受影響之前找出問題。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-229">This lets you do a slow rollout in a controlled fashion, observe real data, and spot problems before all customers are affected.</span></span>

<span data-ttu-id="a9dc1-230">Canary 版本的管理比藍綠或輪流更新更複雜，因為您必須動態將要求路由傳送到不同的服務版本。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-230">A canary release is more complex to manage than either blue-green or rolling update, because you must dynamically route requests to different versions of the service.</span></span>

<span data-ttu-id="a9dc1-231">**範例**。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-231">**Example**.</span></span> <span data-ttu-id="a9dc1-232">在 Kubernetes 中，您可以將服務設定為橫跨兩個複本集 (每個版本各一個) 並手動調整複本計數。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-232">In Kubernetes, you can configure a Service to span two replica sets (one for each version) and adjust the replica counts manually.</span></span> <span data-ttu-id="a9dc1-233">不過，此方法會因為 Kubernetes 在 pod 間進行平衡負載的方式而顯得相當粗糙。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-233">However, this approach is rather coarse-grained, because of the way Kubernetes load balances across pods.</span></span> <span data-ttu-id="a9dc1-234">比方說，如果您有 10 個複本的總計，您只可以轉換流量 10%的增量。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-234">For example, if you have a total of 10 replicas, you can only shift traffic in 10% increments.</span></span> <span data-ttu-id="a9dc1-235">如果您使用服務網格，則可以使用服務網格路由規則，實作更精緻的 Canary 版本策略。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-235">If you are using a service mesh, you can use the service mesh routing rules to implement a more sophisticated canary release strategy.</span></span>

## <a name="next-steps"></a><span data-ttu-id="a9dc1-236">後續步驟</span><span class="sxs-lookup"><span data-stu-id="a9dc1-236">Next steps</span></span>

<span data-ttu-id="a9dc1-237">了解特定的 CI/CD 做法適用於在 Kubernetes 上執行的微服務。</span><span class="sxs-lookup"><span data-stu-id="a9dc1-237">Learn specific CI/CD practices for microservices running on Kubernetes.</span></span>

- [<span data-ttu-id="a9dc1-238">在 Kubernetes 上的微服務的 CI/CD</span><span class="sxs-lookup"><span data-stu-id="a9dc1-238">CI/CD for microservices on Kubernetes</span></span>](./ci-cd-kubernetes.md)